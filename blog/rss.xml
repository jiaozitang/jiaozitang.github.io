<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>My Site Blog</title>
        <link>https://jiaozitang.github.io/blog</link>
        <description>My Site Blog</description>
        <lastBuildDate>Fri, 04 Nov 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[说实话，不得不用 pnpm 的原因，还得是电脑内存不够用]]></title>
            <link>https://jiaozitang.github.io/blog/2022/11/04/pnpm</link>
            <guid>/2022/11/04/pnpm</guid>
            <pubDate>Fri, 04 Nov 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[本文介绍的是 pnpm 管理 Monorepo 项目实践。]]></description>
            <content:encoded><![CDATA[<p>本文介绍的是 pnpm 管理 Monorepo 项目实践。</p><h2>什么是 Monorepo</h2><p>Monorepo 项目简称多包项目，一个包含多个子项目的仓库。</p><p>那为什么要放多个项目在一个仓库下呢？</p><p>是因为这些项目互相引用，相互依赖，放在一个仓库下方便管理及依赖。</p><p>所以管理一个多包项目的关键，需要实现以下 2 点：</p><ul><li>能够很方便的管理包与包之间的依赖关系</li><li>能够在发布其中一个包时，自动更新依赖了该包的其他包并发布</li></ul><h2>什么是 lerna</h2><p>使用最广泛成熟的 Monorepe 项目管理方案就是 lerna + yarn。</p><p>lerna 是一个优化使用 git 和 npm 管理多包存储库工作流的工具。</p><p>它具有以下功能：</p><ul><li>自动解决 packages 之间的依赖关系；</li><li>通过 git 检测文件改动，自动发布；</li><li>根据 git 提交记录，自动生成 CHANGELOG。</li></ul><p>更多详细的 lerna 介绍可以见我的另外一篇博客：<a href="https://juejin.cn/post/7136925215388499998">最详细的 lerna 中文手册</a>。</p><p>既然 lerna 这么好用也这么熟悉了，那为什么还要切换到 pnpm 呢？</p><p>有以下几个原因：</p><ul><li>pnpm 内置了管理 monorepe 功能，使用起来比 lerna 简单</li><li>pnpm 安装比 yarn 高效，也节省电脑内存</li></ul><h2>什么是 pnpm</h2><blockquote><p>pnpm 介绍可以查看 <a href="https://pnpm.io/zh/motivation">pnpm 官网</a>。</p></blockquote><p>pnpm 是新一代的包管理工具，相较于 npm 和 yarn，有以下 2 个优点：</p><h3>节约磁盘空间并提升安装速度</h3><p><strong>节约磁盘空间：</strong></p><ul><li><p>pnpm 安装依赖时，依赖会被存储在硬盘中，不同项目的同一依赖都会硬链接到硬盘位置，不会额外占用磁盘空间。</p></li><li><p>同一依赖包的不同版本，也只会将不同版本中有差异的文件添加到仓库中，不会下载整个包占用磁盘空间。</p></li></ul><p><strong>提升安装速度：</strong></p><ul><li>安装依赖时，会先去硬盘位置寻找包，如果能找到，则建立硬链接，比起重新下载包或者从缓存中拷贝移动包，速度快了很多</li></ul><h3>创建非扁平化的 node_modules 文件夹</h3><p>npm、yarn 为了解决同一依赖被安装多次的问题，将所有包都被提升到模块目录的根目录。</p><p>但是当依赖包有多个版本的时候，只会提升一个，其余版本的包依然会被安装多次。</p><p>另外扁平化 node_modules 时，项目可以访问到未被添加进当前项目的依赖，这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，代码就不能跑了，因为你依赖这个包，但是现在不会被安装了。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a8b229b8dcb4d7d8256d43d0d14973f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>pnpm 采用磁盘硬链接连接依赖，已经解决了依赖会被安装多次的问题。</p><p>为了避免幽灵依赖，pnpm 选择创建非扁平化的 node_modules，项目无法访问到未被添加进当前项目的依赖。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570dc9ad20444043adbd1f1f83404f69~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>快速开始</h2><p>上面已经了解到为什么选择 pnpm 了，那么下面就一起用 pnpm 来管理 Monorepo 吧。</p><h3>全局安装 pnpm</h3><pre><code class="language-bash">nvm use 16
npm i pnpm -g
</code></pre><h3>创建 Monorepo 项目</h3><p>创建目录结构：</p><pre><code class="language-bash">mkdir my-project
cd ./my-project
npm init -y
mkdir packages
cd ./packages
mkdir my-project-a
cd ./my-project-a
npm init -y
mkdir my-project-b
cd ./my-project-b
npm init -y
</code></pre><p>项目结构如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54a1debe910e4142847a6800271f8b66~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>启动 pnpm 的 workspace 功能，根目录新增 pnpm-workspace.yaml，指定工作空间的目录：</p><pre><code class="language-yaml">packages:
  - &quot;packages/**&quot;
</code></pre><p>当我们配置了指定工作空间的目录后，<strong>packages 里的包互相引用时，会自动依赖本地编译的路径，方便实时调试</strong>。</p><p>至此我们就解决了 Monorepre 项目的管理包与包之间的依赖关系的问题。</p><h3>安装项目内依赖</h3><p>限制仅允许 pnpm 安装依赖，更新 package.json：</p><pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;preinstall&quot;: &quot;npx only-allow pnpm&quot;
  }
}
</code></pre><p>安装 eslint 等全局依赖：</p><pre><code class="language-bash">pnpm i eslint -w -D
</code></pre><p>安装子项目内独立的依赖：</p><pre><code class="language-bash">cd ./packages/my-project-a
pnpm i rollup -D
</code></pre><h3>发布流程</h3><p>pnpm 没有提供内置的发布流程解决方案，官方推荐了两个开源的版本控制工具：</p><ul><li><a href="https://github.com/changesets/changesets">changesets</a></li><li><a href="https://rushjs.io/">rush</a></li></ul><p>changesets 的入手学习成本更低，于是乎选择了 changesets 来管理发布流程。</p><h4>安装 changesets</h4><pre><code class="language-bash">pnpm add -Dw @changesets/cli
</code></pre><h4>初始化 changesets</h4><pre><code class="language-bash">pnpm changeset init
</code></pre><p>初始化后生成的 .changeset/config.json：</p><pre><code class="language-json">{
  &quot;$schema&quot;: &quot;https://unpkg.com/@changesets/config@2.1.1/schema.json&quot;,
  &quot;changelog&quot;: &quot;@changesets/cli/changelog&quot;, // changelog 生成方式
  &quot;commit&quot;: false, // 不要让 changeset 在 publish 的时候帮我们做 git add
  &quot;fixed&quot;: [],
  &quot;linked&quot;: [], // 配置哪些包要共享版本
  &quot;access&quot;: &quot;restricted&quot;, // 公私有安全设定，内网建议 restricted ，开源使用 public
  &quot;baseBranch&quot;: &quot;master&quot;, // 项目主分支
  &quot;updateInternalDependencies&quot;: &quot;patch&quot;, // 确保某包依赖的包发生 upgrade，该包也要发生 version upgrade 的衡量单位（量级）
  &quot;ignore&quot;: [] // 不需要变动 version 的包
}
</code></pre><h4>管理 changelog</h4><p>如果是开源库可以安装 @changesets/changelog-github 来管理 changelog。</p><p>安装：</p><pre><code class="language-bash">pnpm add -Dw @changesets/changelog-github
</code></pre><p>更新 .changeset/config.json：</p><pre><code class="language-json">{
  &quot;changelog&quot;: [
    &quot;@changesets/changelog-github&quot;,
    {
      &quot;repo&quot;: &quot;worktile/slate-angular&quot; // 改为你的 github 仓储
    }
  ]
}
</code></pre><p>如果不是开源库，则保持 <code>&quot;changelog&quot;: &quot;@changesets/cli/changelog&quot;</code>。</p><h4>生成 changesets</h4><pre><code class="language-bash">npx changeset
</code></pre><p>选择要发布的包：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54f9e9e354c742f0bf1fe2173b822c76~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>选择发布的类型：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539fba0b0adf4ba69ead6ce2ce0bba12~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>填写发布备注：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a845368dcf943b9b2eb955d12835884~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>确认发布：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/588187cc8bc14ad8bf67b982c1e6b7d5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>生成临时文件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51887162db0f4454a21d14b73c57a10f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>更新版本</h4><p>更新版本前可以先把开发区的改动提交上去。</p><pre><code class="language-bash">git add .
git commit -m &#x27;feat: msg&#x27;
git push
</code></pre><p>更新版本：</p><pre><code class="language-bash">npx changeset version
</code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf5a3d93527849829a227894690aa544~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>自动生成 CHANGELOG.md 并更新 package.json 中的版本，同时<strong>如果子项目间有相互依赖，也会更新依赖版本</strong>。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671efa2a72484b4a8617a293a5b8166b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/176c4878b9774ee8bd7cf9836d20f169~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>发布版本</h4><p>发布至 npm：</p><pre><code class="language-bash">npx changeset publish
</code></pre><p>至此我们就解决了 Monorepre 项目的在发布其中一个包时，自动更新依赖了该包的其他包并发布的问题。</p><h2>小结</h2><p>pnpm 是不是比 yarn + lerna 更香？节省磁盘空间，安装依赖更快，内置 Monorepo 功能。</p><p>说实话，不得不用 pnpm 的原因，还得是电脑内存不够用，20个项目，40G node_modules 的内存就没了。</p><p>所以，赶紧转 pnpm 吧。</p><p>项目地址：<a href="https://github.com/jiaozitang/web-learn-note/tree/feat/pnpm">https://github.com/jiaozitang/web-learn-note/tree/feat/pnpm</a></p><p>希望能对你有所帮助，感谢阅读～</p><p>别忘了点个赞鼓励一下我哦，笔芯 ❤️</p><h2>参考资料</h2><ul><li><a href="https://juejin.cn/post/7098609682519949325">pnpm + workspace + changesets 构建你的 monorepo 工程</a></li><li><a href="https://zhuanlan.zhihu.com/p/373935751">使用 pnpm 构建 Monorepo 项目</a></li><li><a href="https://juejin.cn/post/7054144427622826020">使用 Changesets 管理类库版本及更新日志</a></li><li><a href="https://juejin.cn/post/7127295203177676837">pnpm 是凭什么对 npm 和 yarn 降维打击的</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【实战篇】最详细的Rollup打包项目教程]]></title>
            <link>https://jiaozitang.github.io/blog/2022/09/19/rollup</link>
            <guid>/2022/09/19/rollup</guid>
            <pubDate>Mon, 19 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[介绍]]></description>
            <content:encoded><![CDATA[<h2>介绍</h2><p>本文带你一起使用 Rollup 打包项目，实现以下功能：</p><ul><li><strong>自动将 dependencies 依赖声明为 externals</strong></li><li><strong>支持处理外部 npm 依赖</strong></li><li><strong>支持基于 CommonJS 模块引入</strong></li><li><strong>支持 typescript，并导出声明文件</strong></li><li><strong>支持 scss，并添加前缀</strong></li><li><strong>支持自动清除调试代码</strong></li><li><strong>打包输出文件保留原始模块结构</strong></li><li><strong>支持按需加载</strong></li></ul><h2>一、什么是 <code>rollup</code></h2><p><code>rollup</code> 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。</p><h2>二、为什么是 <code>rollup</code></h2><p>为什么是 <code>rollup</code> 而不是 <code>webpack</code> 呢？</p><p><code>rollup</code>的特色是 <code>ES6</code> 模块和代码 <code>Tree-shaking</code>，这些 <code>webpack</code> 同样支持，除此之外 <code>webpack</code> 还支持热模块替换、代码分割、静态资源导入等更多功能。</p><p>当开发应用时当然优先选择的是 <code>webpack</code>，但是若你项目只需要打包出一个简单的 <code>bundle</code> 包，并是基于 <code>ES6</code> 模块开发的，可以考虑使用 <code>rollup</code>。</p><p><code>rollup</code> 相比 <code>webpack</code>，它更少的功能和更简单的 api，是我们在打包类库时选择它的原因。</p><h2>三、支持打包的文件格式</h2><p>rollup 支持的打包文件的格式有 amd, cjs, es\esm, iife, umd。其中，amd 为 AMD 标准，cjs 为 CommonJS 标准，esm\es 为 ES 模块标准，iife 为立即调用函数， umd 同时支持 amd、cjs 和 iife。</p><h2>四、快速开始</h2><h3>1. 安装</h3><pre><code class="language-chain">npm install --global rollup
</code></pre><h3>2. 基础打包</h3><p>新增文件 <code>src/main.js</code>：</p><pre><code class="language-js">// src/main.js
import foo from &quot;./foo.js&quot;;
export default function () {
  console.log(foo);
}
</code></pre><p>新增文件 <code>src/foo.js</code>：</p><pre><code class="language-js">export default &quot;hello world!&quot;;
</code></pre><p>项目根目录下新增文件 <code>rollup.config.js</code>：</p><pre><code class="language-js">export default {
  input: &quot;src/main.js&quot;,
  output: {
    file: &quot;bundle.js&quot;,
    format: &quot;cjs&quot;,
  },
};
</code></pre><p>运行命令：</p><pre><code class="language-chain">rollup -c
</code></pre><p>得到产物 <code>bundle.js</code>：</p><pre><code class="language-js">&quot;use strict&quot;;

var foo = &quot;hello world!&quot;;

// src/main.js
function main() {
  console.log(foo);
}

module.exports = main;
</code></pre><p>这时我们使用 Rollup 将 <code>src/main.js</code>、<code>src/foo.js</code>打包成功，完成了第一个 bundle，。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cb44b7bbc31438897ac3105a00ac05a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h3>3. 引入外部资源</h3><p>更新 <code>src/main.js</code>，添加外部资源 <code>lodash-es</code> 引入：</p><pre><code class="language-js">// src/main.js
import foo from &quot;./foo.js&quot;;

import { sum } from &quot;lodash-es&quot;;

export default function () {
  console.log(foo);
  console.log(sum[(1, 2)]);
}
</code></pre><p>再次打包 <code>rollup -c</code>，发现有报错 <code>(!) Unresolved dependencies</code>：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70335a0186a64b539caca268c8b64654~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>这是因为当项目中引入外部资源时，如 npm 包，<code>rollup</code> 不知道如何打破常规去处理这些依赖。</p><p>有 2 种方法引入外部资源：</p><ul><li>添加插件 <code>@rollup/plugin-node-resolve</code> 将我们编写的源码与依赖的第三方库进行合并；</li><li>配置 external 属性，告诉 rollup.js 哪些是外部的类库。</li></ul><h4>3.1 resolve 插件</h4><p><code>@rollup/plugin-node-resolve</code> 插件让 rollup 能够处理外部依赖。</p><p>安装：</p><pre><code class="language-chain">yarn add @rollup/plugin-node-resolve -D
</code></pre><p>更新 <code>rollup.config.js</code>：</p><pre><code class="language-js">import resolve from &quot;@rollup/plugin-node-resolve&quot;;
export default {
  plugins: [resolve()],
};
</code></pre><p>重新打包得到产物，已经包含了 <code>lodash-es</code>：</p><pre><code class="language-js">&quot;use strict&quot;;

var foo = &quot;hello world!&quot;;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { &#x27;a&#x27;: 1 };
 *
 * console.log(_.identity(object) === object);
 * // =&gt; true
 */
function identity(value) {
  return value;
}

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
    index = -1,
    length = array.length;

  while (++index &lt; length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : result + current;
    }
  }
  return result;
}

/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // =&gt; 20
 */
function sum(array) {
  return array &amp;&amp; array.length ? baseSum(array, identity) : 0;
}

// src/main.js

function main() {
  console.log(foo);
  console.log(sum([1, 2]));
}

module.exports = main;
</code></pre><p>成功运行：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d7233456d124f52ae678d5a58723d69~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>3.2 external 属性</h4><p>有些场景下，虽然我们使用了 resolve 插件，但可能我们仍然想要某些库保持外部引用状态，这时我们就需要使用 external 属性，来告诉 rollup.js 哪些是外部的类库。</p><p>更新 <code>rollup.config.js</code>：</p><pre><code class="language-js">import commonjs from &quot;@rollup/plugin-commonjs&quot;;
import { nodeResolve } from &quot;@rollup/plugin-node-resolve&quot;;

export default {
  input: &quot;src/main.js&quot;,
  output: {
    file: &quot;bundle.js&quot;,
    format: &quot;esm&quot;,
    name: &quot;test&quot;,
  },
  plugins: [nodeResolve(), commonjs()],
  external: [&quot;react&quot;],
};
</code></pre><h4>3.3 external 插件</h4><p>每个类库都要手动添加至 externals 未免太麻烦，这时候可以用 <code>rollup-plugin-node-externals</code> 插件，自动将外部类库声明为 externals。</p><p>安装：</p><pre><code class="language-chain">yarn add rollup-plugin-node-externals -D
</code></pre><p>更新 <code>rollup.config.js</code>：</p><pre><code class="language-js">import externals from &quot;rollup-plugin-node-externals&quot;;

export default [
  {
    plugins: [
      externals({
        devDeps: false, // devDependencies 类型的依赖就不用加到 externals 了。
      }),
    ],
  },
];
</code></pre><h3>4. 引入 CommonJs 模块</h3><h4>4.1 CommonJs 插件</h4><p>rollup.js 编译源码中的模块引用默认只支持 ES6+的模块方式 import/export。然而大量的 npm 模块是基于 CommonJS 模块方式，这就导致了大量 npm 模块不能直接编译使用。</p><p>需要添加 @rollup/plugin-commonjs 插件来支持基于 CommonJS 模块方式 npm 包。</p><p>安装：</p><pre><code class="language-chain">yarn add @rollup/plugin-commonjs -D
</code></pre><p>更新 rollup.config.js：</p><pre><code class="language-js">import commonjs from &quot;@rollup/plugin-commonjs&quot;;

export default {
  plugins: [commonjs()],
};
</code></pre><p>更新 src/foo.js：</p><pre><code class="language-js">module.exports = {
  text: &quot;hello world!&quot;,
};
</code></pre><p>重新打包，打包成功：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c98d1d7466e54ead9bfa5da4c5e055ba~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h3>5. 引入 Sass 资源</h3><p>rollup-plugin-postcss 默认集成了对 scss、less、stylus 的支持。</p><h4>5.1 打包支持 sass 文件</h4><p>新增 <code>src/foo.scss</code>：</p><pre><code class="language-scss">body {
  background-color: red;
  display: flex;
}
</code></pre><p>更新 <code>src/main.js</code>：</p><pre><code class="language-js">// src/main.js
import foo from &quot;./foo.js&quot;;
import &quot;./foo.scss&quot;;

export default function () {
  console.log(foo.text);
}
</code></pre><p>安装：</p><pre><code class="language-chain">yarn add rollup-plugin-postcss -D
</code></pre><p>更新 rollup.config.js：</p><pre><code class="language-js">import commonjs from &quot;@rollup/plugin-commonjs&quot;;
import { nodeResolve } from &quot;@rollup/plugin-node-resolve&quot;;
import postcss from &quot;rollup-plugin-postcss&quot;;

export default {
  input: &quot;src/main.js&quot;,
  output: {
    file: &quot;bundle.js&quot;,
    format: &quot;esm&quot;,
    name: &quot;test&quot;,
  },
  plugins: [nodeResolve(), commonjs(), postcss()],
  external: [&quot;react&quot;],
};
</code></pre><p>打包产物：</p><pre><code class="language-js">&quot;use strict&quot;;

var foo = {
  text: &quot;hello world!&quot;,
};

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === &quot;undefined&quot;) {
    return;
  }

  var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0];
  var style = document.createElement(&quot;style&quot;);
  style.type = &quot;text/css&quot;;

  if (insertAt === &quot;top&quot;) {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = &quot;body {\n  background-color: red;\n}&quot;;
styleInject(css_248z);

// src/main.js

function main() {
  console.log(foo.text);
}

module.exports = main;
</code></pre><p>效果如图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d5d5e80b5d54910abe0836b8ca0144a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>5.2 css 加前缀</h4><p>安装：</p><pre><code class="language-chain">yarn add autoprefixer -D
</code></pre><p>更新 packages.json：</p><pre><code class="language-js">
  &quot;browserslist&quot;: [
    &quot;defaults&quot;,
    &quot;not ie &lt; 8&quot;,
    &quot;last 2 versions&quot;,
    &quot;&gt; 1%&quot;,
    &quot;iOS 7&quot;,
    &quot;last 3 iOS versions&quot;
  ]
</code></pre><p>更新 rollup.config.js：</p><pre><code class="language-js">import commonjs from &quot;@rollup/plugin-commonjs&quot;;
import { nodeResolve } from &quot;@rollup/plugin-node-resolve&quot;;
import autoprefixer from &quot;autoprefixer&quot;;
import postcss from &quot;rollup-plugin-postcss&quot;;

export default {
  input: &quot;src/main.js&quot;,
  output: {
    file: &quot;bundle.js&quot;,
    format: &quot;umd&quot;,
    name: &quot;test&quot;,
  },
  plugins: [
    nodeResolve(),
    commonjs(),
    postcss({
      plugins: [autoprefixer()],
    }),
  ],
  external: [&quot;react&quot;],
};
</code></pre><p>效果如图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdb1b417634e4b7cacb27d824ebebf00~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>5.3 css 压缩</h4><p>安装：</p><pre><code class="language-chain">yarn add cssnano -D
</code></pre><p>更新 rollup.config.js：</p><pre><code class="language-js">import commonjs from &quot;@rollup/plugin-commonjs&quot;;
import { nodeResolve } from &quot;@rollup/plugin-node-resolve&quot;;
import autoprefixer from &quot;autoprefixer&quot;;
import cssnano from &quot;cssnano&quot;;
import postcss from &quot;rollup-plugin-postcss&quot;;

export default {
  input: &quot;src/main.js&quot;,
  output: {
    file: &quot;bundle.js&quot;,
    format: &quot;umd&quot;,
    name: &quot;test&quot;,
  },
  plugins: [
    nodeResolve(),
    commonjs(),
    postcss({
      plugins: [autoprefixer(), cssnano()],
    }),
  ],
  external: [&quot;react&quot;],
};
</code></pre><p>效果如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84ac8ce365664db1a49a8d81f0256b4e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>5.4 抽离单独的 css 文件</h4><p>更新 <code>rollup.config.js</code>：</p><pre><code class="language-js">export default [
  {
    plugins: [
      postcss({
        plugins: [autoprefixer(), cssnano()],
        extract: &quot;css/index.css&quot;,
      }),
    ],
  },
];
</code></pre><p>效果如图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31aa7bcbac6e4a2a8a1576c1b35e90b3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h3>6. 引入 Typescript 资源</h3><h4>6.1 typescript 插件</h4><p>修改 <code>src/foo.js</code> -&gt; <code>src/foo.ts</code>：</p><pre><code class="language-ts">export default {
  text: &quot;hello world!&quot;,
};
</code></pre><p>更新 <code>src/main.js</code>：</p><pre><code class="language-js">// src/main.js
import foo from &quot;./foo.ts&quot;;
import &quot;./foo.scss&quot;;

export default function () {
  console.log(foo.text);
}
</code></pre><p>安装：</p><pre><code class="language-chain">yarn add @rollup/plugin-typescript -D
</code></pre><p>更新 rollup.config.js：</p><pre><code class="language-js">import typescript from &quot;@rollup/plugin-typescript&quot;;
export default [
  {
    plugins: [typescript()];
  }
];
</code></pre><p>成功支持 Ts 文件导出：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecdd7a565cac48c7a70d7cec2b2f8678~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>6.2 导出类型声明文件</h4><p>更新 rollup.config.js：</p><pre><code class="language-js">import typescript from &quot;@rollup/plugin-typescript&quot;;
export default [
  {
    plugins: [
        typescript({
            outDir: &quot;dist&quot;,
            declaration: true,
            declarationDir: &quot;dist&quot;,
        })
    ];
  }
];
</code></pre><p>成功支持类型声明文件导出：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a441501a9d54033a73529d9928a90a2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h3>7. 打包产物清除调试代码</h3><p>插件 <code>@rollup/plugin-strip</code> 用于从代码中删除 debugger 语句和函数。包括 assert.equal、console.log 等等。</p><p>安装：</p><pre><code class="language-chain">yarn add @rollup/plugin-strip -D
</code></pre><p>更新 rollup.config.js：</p><pre><code class="language-js">import strip from &quot;@rollup/plugin-strip&quot;;
export default [
  {
    plugins: [
        strip()
    ];
  }
];
</code></pre><h3>8. 打包输出文件保留原始模块结构</h3><p>上面我们的 output 配置是这样的：</p><pre><code class="language-js">output: {
    dir: path.dirname(&#x27;dist/bundle.js&#x27;),
    format: &#x27;es&#x27;,
  }
</code></pre><p>打包产物如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbade42b786b41a7b957d66052396733~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>那么怎么才能把 index.js、index2.js 改成 foo/index.js、hello/index.js 呢？</p><p>修改 output，更新 rollup.config.js：</p><pre><code class="language-js">output: {
    dir: path.dirname(&#x27;dist/bundle.js&#x27;),
    format: &#x27;es&#x27;,
    exports: &#x27;named&#x27;, // 指定导出模式（自动、默认、命名、无）
    preserveModules: true, // 保留模块结构
    preserveModulesRoot: &#x27;src&#x27;, // 将保留的模块放在根级别的此路径下
  },
</code></pre><p>这时打包产物就和源码的结构一致了：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfa326d7746a41fda5fa8fabd141c93b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h3>9. 按需加载</h3><p>rollup 支持输出格式为 <code>es</code> 模块化，就会按模块输出。</p><p>所以我们上面的配置已经实现了按需加载了。</p><h2>五、一个真实的组件库的 rollup 打包配置</h2><p>项目地址：<a href="https://github.com/jiaozitang/react-masonry-component2">https://github.com/jiaozitang/react-masonry-component2</a></p><p>该项目支持：</p><ul><li><strong>打包输出文件保留原始模块结构</strong></li><li><strong>自动将 dependencies 依赖声明为 externals</strong></li><li><strong>支持处理外部 npm 依赖</strong></li><li><strong>支持基于 CommonJS 模块引入</strong></li><li><strong>支持 typescript，并导出声明文件</strong></li><li><strong>支持 scss，并添加前缀</strong></li><li><strong>支持自动清除调试代码</strong></li><li><strong>支持按需加载</strong></li></ul><h3>1. 安装</h3><pre><code class="language-chain">npm i rollup -g

yarn add typescript postcss @rollup/plugin-commonjs @rollup/plugin-node-resolve @rollup/plugin-strip @rollup/plugin-typescript rollup-plugin-postcss rollup-plugin-node-externals autoprefixer -D
</code></pre><h3>2. 配置</h3><p>项目根目录下新增 <code>rollup.config.js</code>：</p><pre><code class="language-js">import commonjs from &quot;@rollup/plugin-commonjs&quot;;
import resolve from &quot;@rollup/plugin-node-resolve&quot;;
import strip from &quot;@rollup/plugin-strip&quot;;
import typescript from &quot;@rollup/plugin-typescript&quot;;
import autoprefixer from &quot;autoprefixer&quot;;
import path from &quot;path&quot;;
import externals from &quot;rollup-plugin-node-externals&quot;;
import postcss from &quot;rollup-plugin-postcss&quot;;

import pkg from &quot;./package.json&quot;;

export default [
  {
    input: &quot;./src/index.ts&quot;, // 入口文件
    output: [
      {
        // 出口文件
        dir: path.dirname(pkg.module),
        format: &quot;es&quot;, // es模块导出，支持按需加载
        name: pkg.name,
        exports: &quot;named&quot;, // 指定导出模式（自动、默认、命名、无）
        preserveModules: true, // 保留模块结构
        preserveModulesRoot: &quot;src&quot;, // 将保留的模块放在根级别的此路径下
      },
    ],
    plugins: [
      // 自动将dependencies依赖声明为 externals
      externals({
        devDeps: false,
      }),
      // 处理外部依赖
      resolve(),
      // 支持基于 CommonJS 模块引入
      commonjs(),
      // 支持 typescript，并导出声明文件
      typescript({
        outDir: &quot;es&quot;,
        declaration: true,
        declarationDir: &quot;es&quot;,
      }),
      // 支持 scss，并添加前缀
      postcss({
        plugins: [autoprefixer()],
      }),
      // 清除调试代码
      strip(),
    ],
  },
];
</code></pre><p>更新 packages.json：</p><pre><code class="language-json">{
  &quot;module&quot;: &quot;es/index.js&quot;,
  &quot;types&quot;: &quot;es/index.d.ts&quot;,
  &quot;files&quot;: [&quot;es&quot;]
}
</code></pre><p>新增 tsconfig.json：</p><pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;lib&quot;: [
      &quot;dom&quot;,
      &quot;dom.iterable&quot;,
      &quot;esnext&quot;
    ],
    &quot;allowJs&quot;: true,
    &quot;skipLibCheck&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;allowSyntheticDefaultImports&quot;: true,
    &quot;strict&quot;: true,
    &quot;forceConsistentCasingInFileNames&quot;: false,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;module&quot;: &quot;esnext&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;resolveJsonModule&quot;: true,
    &quot;isolatedModules&quot;: true,
    &quot;noEmit&quot;: true,
    &quot;jsx&quot;: &quot;react-jsx&quot;,
  },
  &quot;include&quot;: [
    &quot;src&quot;
  ],
  &quot;exclude&quot;: [
      &quot;src/**/stories.*&quot;,
      &quot;src/**/.spec.*&quot;,
      &quot;src/**/.mdx&quot;
  ]
}
</code></pre><p>项目结构：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc9ee49f5c64886bb5dc007335a0d43~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>打包产物：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a794eea6f1b42008cdb4b1eea8c3f1d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>小结</h2><p>本文介绍了 rollup 的各个功能的使用方法，rollup 自身能力较弱，依靠插件完成完整的组件库打包。</p><p>可以直接拷贝文中配置，实现一个按需加载的组件库打包。</p><p>项目地址：<a href="https://github.com/jiaozitang/react-masonry-component2">https://github.com/jiaozitang/react-masonry-component2</a></p><p>希望能对你有所帮助，感谢阅读～</p><p>别忘了点个赞鼓励一下我哦，笔芯 ❤️</p><h2>往期精彩</h2><ul><li><a href="https://juejin.cn/post/7144365208646418462">从0到1开发一个React组件库</a></li></ul><h2>参考资料</h2><ul><li><a href="https://www.rollupjs.com/">Rollup 官网</a></li><li><a href="https://juejin.cn/post/6934698510436859912">rollup 从入门到打包一个按需加载的组件库</a></li><li><a href="https://zhuanlan.zhihu.com/p/221968604">一文带你快速上手 Rollup</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[5 种瀑布流场景的实现原理解析]]></title>
            <link>https://jiaozitang.github.io/blog/2022/09/18/component</link>
            <guid>/2022/09/18/component</guid>
            <pubDate>Sun, 18 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[一、背景]]></description>
            <content:encoded><![CDATA[<h2>一、背景</h2><p>本文介绍 5 种瀑布流场景的实现，<strong>大家可以根据自身的需求场景进行选择</strong>。</p><p>5 种场景分别是：</p><table><thead><tr><th>瀑布流</th><th>特点</th></tr></thead><tbody><tr><td>纵向+高度排序</td><td>纯 CSS 多列实现，是<strong>最简单的瀑布流写法</strong></td></tr><tr><td>纵向+高度排序+根据宽度自适应列数</td><td>通过 JS 根据屏幕宽度计算列数，<strong>在 web 端更加灵活的展示瀑布流</strong></td></tr><tr><td>横向</td><td>纯 CSS 弹性布局实现，是<strong>最简单的横向瀑布流写法</strong></td></tr><tr><td>横向+高度排序</td><td>横向+高度排序的瀑布流，需要通过 JS 计算每一列高度，损耗性能，但是<strong>可以避免某列特别长的情况</strong>，体验更好</td></tr><tr><td>横向+高度排序+根据宽度自适应列数</td><td>需要通过 JS 计算每一列高度，并根据屏幕宽度计算列数，损耗性能，但是<strong>可以避免某列特别长的情况</strong>，并且可以<strong>在 web 端更加灵活的展示瀑布流</strong>，体验更好，<strong>是 5 种瀑布流中用户体验最好的</strong></td></tr></tbody></table><p>我已经将这 5 种场景的实现封装成 npm 包，npm 包地址：<a href="https://www.npmjs.com/package/react-masonry-component2">https://www.npmjs.com/package/react-masonry-component2</a>，可以直接在 React 项目中安装使用。</p><h2>二、介绍</h2><p>瀑布流，是比较流行的一种网站<a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80?fromModule=lemma_inlink">页面布局</a>，视觉表现为参差不齐的多栏布局，随着页面<a href="https://baike.baidu.com/item/%E6%BB%9A%E5%8A%A8%E6%9D%A1/7166861?fromModule=lemma_inlink">滚动条</a>向下滚动，这种布局还会不断加载<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%9D%97/107672?fromModule=lemma_inlink">数据块</a>并附加至当前尾部。</p><p>下图就是一个瀑布流布局的示意图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd8c644751e4d759e2198fb0d6b2706~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"/></p><h2>三、纵向+高度排序</h2><p>纵向+高度排序指的是，每列按照纵向排列，往高度最小的列添加内容，如下图所示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dda0f38a107e4f6aa89c84871fcabecf~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"/></p><p>实现纵向+高度排序瀑布流的方法是 <strong>CSS 多列布局</strong>。</p><h3>1. 多列布局介绍</h3><p><a href="https://www.runoob.com/css3/css3-multiple-columns.html">多列布局</a>指的是 CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37b388e681044880ab23729093014a60~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"/></p><p>CSS3 的多列属性:</p><ul><li><code>column-count</code>：指定了需要分割的列数；</li><li><code>column-gap</code>：指定了列与列间的间隙；</li><li><code>column-rule-style</code>：指定了列与列间的边框样式；</li><li><code>column-rule-width</code>：指定了两列的边框厚度；</li><li><code>column-rule-color</code>：指定了两列的边框颜色；</li><li><code>column-rule</code>：是 column-rule-<!-- -->*<!-- --> 所有属性的简写；</li><li><code>column-span</code>：指定元素跨越多少列；</li><li><code>column-width</code>：指定了列的宽度。</li></ul><h3>2. 实现思路</h3><p>瀑布流实现思路如下：</p><ul><li>通过 CSS <code>column-count</code> 分割内容为指定列；</li><li>通过 CSS <code>break-inside</code> 保证每个子元素渲染完再换行；</li></ul><h3>3. 实现代码</h3><pre><code class="language-css">.css-column {
  column-count: 4; //分为4列
}

.css-column div {
  break-inside: avoid; // 保证每个子元素渲染完在换行
}
</code></pre><h3>4. 直接使用 npm 包</h3><p><a href="https://www.npmjs.com/package/react-masonry-component2">npm - react-masonry-component2</a> 的使用方法：</p><pre><code class="language-tsx">import { Masonry } from &#x27;react-masonry-component2&#x27;

export const MyComponent = (args) =&gt; {
  return (
    &lt;Masonry direction=&#x27;column&#x27;&gt;
      &lt;div&gt;&lt;/div&gt;
      &lt;div&gt;&lt;/div&gt;
      &lt;div&gt;&lt;/div&gt;
    &lt;/Masonry&gt;
  )
}
</code></pre><p>在线预览：<a href="https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E7%BA%B5%E5%90%91%E5%B8%83%E5%B1%80">https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E7%BA%B5%E5%90%91%E5%B8%83%E5%B1%80</a></p><h2>四、纵向+高度排序+根据宽度自适应列数</h2><p>在纵向+高度排序的基础上，按照宽度自适应列数。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d18ab7e225ea45a3b217a9dee077a0dc~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"/></p><h3>1. 实现思路</h3><ul><li>监听 resize 方法，根据屏幕宽度得到该宽度下应该展示的列数</li></ul><h3>2. 实现代码</h3><pre><code class="language-ts">import { useCallback, useEffect, useMemo, useState } from &#x27;react&#x27;

import { DEFAULT_COLUMNS_COUNT } from &#x27;../const&#x27;

export const useHasMounted = () =&gt; {
  const [hasMounted, setHasMounted] = useState(false)
  useEffect(() =&gt; {
    setHasMounted(true)
  }, [])
  return hasMounted
}

export const useWindowWidth = () =&gt; {
  const hasMounted = useHasMounted()
  const [width, setWidth] = useState(0)

  const handleResize = useCallback(() =&gt; {
    if (!hasMounted) return
    setWidth(window.innerWidth)
  }, [hasMounted])

  useEffect(() =&gt; {
    if (hasMounted) {
      window.addEventListener(&#x27;resize&#x27;, handleResize)
      handleResize()
      return () =&gt; window.removeEventListener(&#x27;resize&#x27;, handleResize)
    }
  }, [hasMounted, handleResize])

  return width
}

export const useColumnCount = (columnsCountBreakPoints: {
  [props: number]: number
}) =&gt; {
  const windowWidth = useWindowWidth()
  const columnCount = useMemo(() =&gt; {
    const breakPoints = (
      Object.keys(columnsCountBreakPoints as any) as unknown as number[]
    ).sort((a: number, b: number) =&gt; a - b)
    let count =
      breakPoints.length &gt; 0
        ? columnsCountBreakPoints![breakPoints[0]]
        : DEFAULT_COLUMNS_COUNT

    breakPoints.forEach((breakPoint) =&gt; {
      if (breakPoint &lt; windowWidth) {
        count = columnsCountBreakPoints![breakPoint]
      }
    })

    return count
  }, [windowWidth, columnsCountBreakPoints])

  return columnCount
}
</code></pre><p>动态定义 <code>style columnCount</code>，实现根据屏幕宽度自适应列数：</p><pre><code class="language-tsx">const { columnsCountBreakPoints } = props
const columnCount = useColumnCount(columnsCountBreakPoints)
return (
  &lt;div className={classNames([&#x27;masonry-column-wrap&#x27;])} style={{ columnCount }}&gt;
    {children}
  &lt;/div&gt;
)
</code></pre><h3>3. 直接使用 npm 包</h3><p><a href="https://www.npmjs.com/package/react-masonry-component2">npm - react-masonry-component2</a> 的使用方法：</p><pre><code class="language-tsx">import { Masonry } from &#x27;react-masonry-component2&#x27;

export const MyComponent = (args) =&gt; {
  return (
    &lt;Masonry
      direction=&#x27;column&#x27;
      columnsCountBreakPoints={{
        1400: 5,
        1000: 4,
        700: 3,
      }}
    &gt;
      &lt;div&gt;&lt;/div&gt;
      &lt;div&gt;&lt;/div&gt;
      &lt;div&gt;&lt;/div&gt;
    &lt;/Masonry&gt;
  )
}
</code></pre><p>在线预览：<a href="https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E7%BA%B5%E5%90%91%E5%B8%83%E5%B1%80">https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E7%BA%B5%E5%90%91%E5%B8%83%E5%B1%80</a></p><h2>五、横向</h2><p>横向瀑布流指的是，每列按照横向排列，如下图所示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad5cc71b7cb140d3a8ad88cbb5d2dcf6~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"/></p><p>实现横向瀑布流的方法是<strong>CSS 弹性布局</strong>。</p><h3>1. 弹性布局介绍</h3><p>弹性布局，是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。</p><p>引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</p><p>CSS3 的弹性布局属性：</p><ul><li><code>flex-dicreation</code>：指定了弹性子元素的排列方式；</li><li><code>justify-content</code>：指定了弹性布局的主轴对齐方式；</li><li><code>align-items</code>：指定了弹性布局的侧轴对齐方式；</li><li><code>flex-wrap</code>：指定了弹性子元素的换行方式；</li><li><code>align-content</code>：指定弹性布局各行的对齐方式；</li><li><code>order</code>：指定弹性子元素的排列顺序；</li><li><code>align-self</code>：指定弹性子元素的纵向对齐方式；</li><li><code>flex</code>  属性用于指定弹性子元素如何分配空间；<ul><li><code>auto</code>: 计算值为 1 1 auto</li><li><code>initial</code>: 计算值为 0 1 auto</li><li><code>none</code>：计算值为 0 0 auto</li><li><code>inherit</code>：从父元素继承</li><li><code>[ flex-grow ]</code>：定义弹性盒子元素的扩展比率。</li><li><code>[ flex-shrink ]</code>：定义弹性盒子元素的收缩比率。</li><li><code>[ flex-basis ]</code>：定义弹性盒子元素的默认基准值。</li></ul></li></ul><h3>2. 实现思路</h3><p>瀑布流实现思路如下：</p><ul><li>CSS 弹性布局对 4 列按横向排列，对每一列内部按纵向排列。</li></ul><h3>3. 实现代码</h3><p>瀑布流实现代码如下：</p><pre><code class="language-tsx">&lt;div className={classNames([&#x27;masonry-flex-wrap&#x27;])}&gt;
  &lt;div className=&#x27;masonry-flex-wrap-column&#x27;&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div className=&#x27;masonry-flex-wrap-column&#x27;&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><pre><code class="language-css">.masonry-flex-wrap {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-content: stretch;

  &amp;-column {
    display: &#x27;flex&#x27;;
    flex-direction: &#x27;column&#x27;;
    justify-content: &#x27;flex-start&#x27;;
    align-content: &#x27;stretch&#x27;;
    flex: 1;
  }
}
</code></pre><h3>4. 直接使用 npm 包</h3><p><a href="https://www.npmjs.com/package/react-masonry-component2">npm - react-masonry-component2</a> 的使用方法：</p><pre><code class="language-tsx">import { Masonry } from &#x27;react-masonry-component2&#x27;

export const MyComponent = (args) =&gt; {
  return (
    &lt;Masonry
      columnsCountBreakPoints={{
        1400: 5,
        1000: 4,
        700: 3,
      }}
    &gt;
      &lt;div&gt;&lt;/div&gt;
      &lt;div&gt;&lt;/div&gt;
      &lt;div&gt;&lt;/div&gt;
    &lt;/Masonry&gt;
  )
}
</code></pre><p>在线预览：<a href="https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E6%A8%AA%E5%90%91%E5%B8%83%E5%B1%80">https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E6%A8%AA%E5%90%91%E5%B8%83%E5%B1%80</a></p><h2>六、横向+高度排序</h2><p>横向+高度排序指的是，每列按照横向排列，往高度最小的列添加内容，如下图所示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e2261defc1f4d1a864875db0b1a51dd~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"/></p><p>高度排序就需要用 JS 逻辑来做了。</p><h3>1. 实现思路</h3><ul><li>JS 将瀑布流的列表按高度均为分为指定列数，比如瀑布流为 4 列，那么就要把瀑布流列表分成 4 个列表</li></ul><h3>2. 实现代码</h3><pre><code class="language-ts">export const getColumnsSortWithHeight = (
  children: React.ReactNode,
  columnCount: number
) =&gt; {
  const columns: {
    height: number
    children: React.ReactNode[]
  }[] = Array.from({ length: columnCount }, () =&gt; ({
    height: 0,
    children: [],
  }))

  React.Children.forEach(children, (child: React.ReactNode, index) =&gt; {
    if (child &amp;&amp; React.isValidElement(child)) {
      if (index &lt; columns.length) {
        columns[index % columnCount].children.push(child)
        columns[index % columnCount].height += child.props.height
        return
      }

      const minHeightColumn = minBy(columns, (a) =&gt; a.height) as {
        height: number
        children: React.ReactNode[]
      }
      minHeightColumn.children.push(child)
      minHeightColumn.height += child.props.height
    }
  })

  return columns
}
</code></pre><h3>3. 直接使用 npm 包</h3><p><a href="https://www.npmjs.com/package/react-masonry-component2">npm - react-masonry-component2</a> 的使用方法：</p><pre><code class="language-tsx">import { Masonry, MasonryItem } from &#x27;react-masonry-component2&#x27;

export const MyComponent = (args) =&gt; {
  return (
    &lt;Masonry
      sortWithHeight
      columnsCountBreakPoints={{
        1400: 5,
        1000: 4,
        700: 3,
      }}
    &gt;
      &lt;MasonryItem height={200}&gt;
        &lt;div&gt;&lt;/div&gt;
      &lt;/MasonryItem&gt;
      &lt;MasonryItem height={300}&gt;
        &lt;div&gt;&lt;/div&gt;
      &lt;/MasonryItem&gt;
      &lt;MasonryItem height={400}&gt;
        &lt;div&gt;&lt;/div&gt;
      &lt;/MasonryItem&gt;
    &lt;/Masonry&gt;
  )
}
</code></pre><p>在线预览：<a href="https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E6%A8%AA%E5%90%91%E5%B8%83%E5%B1%80%E9%AB%98%E5%BA%A6%E6%8E%92%E5%BA%8F">https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E6%A8%AA%E5%90%91%E5%B8%83%E5%B1%80%E9%AB%98%E5%BA%A6%E6%8E%92%E5%BA%8F</a></p><h2>七、横向+高度排序+根据宽度自适应列数</h2><p>根据宽度自适应列数的做法和纵向场景一致，都是监听 resize 方法，根据屏幕宽度得到该宽度下应该展示的列数，这里不做赘述。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86de5c6a95b74e1da31d2065a361e3ab~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"/></p><h3>1. 直接使用 npm 包</h3><p><a href="https://www.npmjs.com/package/react-masonry-component2">npm - react-masonry-component2</a> 的使用方法：</p><pre><code class="language-tsx">import { Masonry } from &#x27;react-masonry-component2&#x27;

export const MyComponent = (args) =&gt; {
  return (
    &lt;Masonry
      sortWithHeight
      direction=&#x27;column&#x27;
      columnsCountBreakPoints={{
        1400: 5,
        1000: 4,
        700: 3,
      }}
    &gt;
      &lt;div&gt;&lt;/div&gt;
      &lt;div&gt;&lt;/div&gt;
      &lt;div&gt;&lt;/div&gt;
    &lt;/Masonry&gt;
  )
}
</code></pre><p>在线预览：<a href="https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E6%A8%AA%E5%90%91%E5%B8%83%E5%B1%80%E9%AB%98%E5%BA%A6%E6%8E%92%E5%BA%8F">https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E5%B8%83%E5%B1%80-masonry-%E7%80%91%E5%B8%83%E6%B5%81--%E6%A8%AA%E5%90%91%E5%B8%83%E5%B1%80%E9%AB%98%E5%BA%A6%E6%8E%92%E5%BA%8F</a></p><h2>小结</h2><p>本文介绍了 5 种瀑布流场景的实现：</p><ul><li>纵向+高度排序</li><li>纵向+高度排序+根据宽度自适应列数</li><li>横向</li><li>横向+高度排序</li><li>横向+高度排序+根据宽度自适应列数</li></ul><p>感兴趣的同学可以到<a href="https://github.com/jiaozitang/react-masonry-component2">项目源码</a>查看完整实现代码。</p><p>也可以下载 <a href="https://www.npmjs.com/package/react-masonry-component2">https://www.npmjs.com/package/react-masonry-component2</a> 直接使用。</p><h2>更多思考</h2><p>当瀑布流数据特别多时，dom 节点过多，会影响到页面性能，那么就需要为瀑布流添加滚动预加载和节点回收功能来进行优化了，在下个版本中将更新滚动预加载和节点回收功能的实现原理。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[从0到1开发一个React组件库]]></title>
            <link>https://jiaozitang.github.io/blog/2022/09/17/react-component</link>
            <guid>/2022/09/17/react-component</guid>
            <pubDate>Sat, 17 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[背景]]></description>
            <content:encoded><![CDATA[<h2>背景</h2><p>前端技术的不断发展过程中，组件化、模块化已成为主流。</p><p>当开发的项目中有一些公共组件可以沉淀的时候，将这些组件抽离出来，开发一个组件库无疑是一个好的选择。</p><p>那么怎么去开发一个组件库呢？本文将和你一起从零开发一个 React 组件库。</p><ul><li>本文项目源码：<a href="https://github.com/jiaozitang/react-masonry-component2">https://github.com/jiaozitang/react-masonry-component2</a></li><li>本文组件库 npm 包地址：<a href="https://www.npmjs.com/package/react-masonry-component2">https://www.npmjs.com/package/react-masonry-component2</a></li></ul><h2>一、搭建项目</h2><p>组件库的第一步是搭建项目，选择合适的技术，并制定代码规范。</p><h3>1. 技术选型</h3><h4>1.1 前端框架</h4><p>前端框架的选择不用多说，大家都是选择日常开发中使用到的框架，本文使用的是 React。</p><h4>1.2 组件库工具</h4><p>组件库工具，市面上比较流行的 2 个组件库工具分别的 dumi 和 Storybook。</p><p>dumi，是一款为组件开发场景而生的文档工具，与  <a href="https://github.com/umijs/father">father</a>  一起为开发者提供一站式的组件开发体验，<strong>father 负责构建，而 dumi 负责组件开发及组件文档生成</strong>。</p><p>Storybook 是一个用于单独构建 UI 组件和页面的前端工具。成千上万的团队将它用于 UI 开发、测试和文档。它是开源和免费的。</p><p>dumi 和 Storybook 都是专用于组件开发场景的工具，由于 Storybook 更加支持测试难以到达的状态和边缘案例，因此最终选择 Storybook 来开发组件库。</p><h3>2. 快速开始</h3><h4>2.1 creat-react-app</h4><p>使用 creat-react-app 创建一个支持 TypeScript 的 React 项目。</p><pre><code class="language-shell">npx create-react-app my-react-component --template typescript
</code></pre><h4>2.2 Storybook</h4><p>Storybook 教程：<a href="https://storybook.js.org/">https://storybook.js.org/</a>。</p><p>为 React 项目添加 Storybook 能力。</p><pre><code class="language-chain">cd ./my-react-component
npx storybook init
</code></pre><p>此时通过 <code>yarn storybook</code>，将在本地启动 Storybook 并输出地址。根据您的系统配置，它会自动在新的浏览器选项卡中打开地址，然后您会看到一个欢迎屏幕。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42e7a0a0000a4b79a7fa61da49e18aa1~tplv-k3u1fbpfcp-zoom-1.image"/></p><h3>3. 代码规范</h3><h4>3.1 Prettier</h4><p>Prettier 是一个代码格式化工具，可以让团队的<strong>代码风格</strong>保持一致。可支持的源码类型包括：JavaScript、JSX、Angular、Vue、Flow、TypeScript、CSS、HTML、JSON、YAML 等等。</p><p>安装：</p><pre><code class="language-shell">yarn add prettier -D
</code></pre><p>项目根目录下添加配置文件 <code>.prettierrc</code>：</p><pre><code class="language-json">{
  &quot;arrowParens&quot;: &quot;always&quot;,
  &quot;bracketSameLine&quot;: false,
  &quot;bracketSpacing&quot;: true,
  &quot;embeddedLanguageFormatting&quot;: &quot;auto&quot;,
  &quot;htmlWhitespaceSensitivity&quot;: &quot;css&quot;,
  &quot;insertPragma&quot;: false,
  &quot;jsxSingleQuote&quot;: false,
  &quot;printWidth&quot;: 80,
  &quot;proseWrap&quot;: &quot;preserve&quot;,
  &quot;quoteProps&quot;: &quot;as-needed&quot;,
  &quot;requirePragma&quot;: false,
  &quot;semi&quot;: true,
  &quot;singleQuote&quot;: false,
  &quot;tabWidth&quot;: 2,
  &quot;trailingComma&quot;: &quot;es5&quot;,
  &quot;useTabs&quot;: false,
  &quot;vueIndentScriptAndStyle&quot;: false
}
</code></pre><p>修改 <code>packages.json</code>：</p><pre><code class="language-json">&quot;scripts&quot;: {
    &quot;prettier&quot;: &quot;prettier src --write&quot;,
}
</code></pre><p>运行 <code>yarn prettier</code> 将会格式化 <code>src</code> 目录下所有文件的代码样式。</p><h4>3.2 ESlint</h4><p>ESLint 用于检测 JS 代码，发现<strong>代码质量问题</strong>并修复问题，还可以自己根据项目需要进行规则的自定义配置以及检查范围等等。</p><p>安装：</p><pre><code class="language-chain">yarn add eslint eslint-plugin-react eslint-plugin-simple-import-sort eslint-plugin-unused-imports @typescript-eslint/eslint-plugin @typescript-eslint/parser -D
</code></pre><p>项目根目录下添加配置文件 <code>.eslintrc.js</code>：</p><pre><code class="language-js">module.exports = {
  env: {
    browser: true,
    es2021: true,
  },
  extends: [
    &quot;eslint:recommended&quot;,
    &quot;plugin:react/recommended&quot;,
    &quot;plugin:@typescript-eslint/recommended&quot;,
  ],
  overrides: [],
  parser: &quot;@typescript-eslint/parser&quot;,
  parserOptions: {
    ecmaVersion: &quot;latest&quot;,
    sourceType: &quot;module&quot;,
  },
  plugins: [
    &quot;react&quot;,
    &quot;@typescript-eslint&quot;,
    &quot;unused-imports&quot;,
    &quot;simple-import-sort&quot;,
  ],
  rules: {
    &quot;no-unused-vars&quot;: &quot;off&quot;, // or &quot;@typescript-eslint/no-unused-vars&quot;: &quot;off&quot;,
    &quot;unused-imports/no-unused-imports&quot;: &quot;warn&quot;,
    &quot;unused-imports/no-unused-vars&quot;: [
      &quot;warn&quot;,
      {
        vars: &quot;all&quot;,
        varsIgnorePattern: &quot;^_&quot;,
        args: &quot;after-used&quot;,
        argsIgnorePattern: &quot;^_&quot;,
      },
    ],
    &quot;simple-import-sort/imports&quot;: &quot;warn&quot;,
    &quot;simple-import-sort/exports&quot;: &quot;warn&quot;,
    &quot;react/react-in-jsx-scope&quot;: &quot;off&quot;,
    &quot;react/prop-types&quot;: &quot;off&quot;,
  },
};
</code></pre><p>修改 <code>packages.json</code>：</p><pre><code class="language-json">&quot;scripts&quot;: {
    &quot;eslint&quot;: &quot;eslint src --fix&quot;,
}
</code></pre><p>运行 <code>yarn eslint</code> 将会检测 src 下所有 js、ts、jsx、tsx 的语法及样式问题并进行修复。</p><h4>3.3 lint-staged</h4><p><code>lint-staged</code>  相当于一个文件过滤器，每次提交时只检查本次提交的暂存区的文件，它不能格式化代码和校验文件，需要自己配置一下，如：<code>.eslintrc</code>、<code>.stylelintrc</code>  等，然后在  <code>package.json</code>  中引入。</p><p>安装：</p><pre><code class="language-chain">yarn add lint-staged -D
</code></pre><p>项目根目录下添加配置文件 .lintstagedrc：</p><pre><code class="language-json">{
  &quot;src/**/*.tsx&quot;: [&quot;prettier --write&quot;, &quot;eslint --fix&quot;],
  &quot;src/**/*.scss&quot;: [&quot;prettier --write&quot;],
  &quot;src/**/*.mdx&quot;: [&quot;prettier --write&quot;],
  &quot;src/**/*.md&quot;: [&quot;prettier --write&quot;]
}
</code></pre><p>修改 <code>packages.json</code>：</p><pre><code class="language-json">&quot;scripts&quot;: {
    &quot;ling-staged&quot;: &quot;ling-staged&quot;,
}
</code></pre><p>运行 <code>yarn lint-staged</code> 将对 <code>git</code> 暂存区所有文件执行 <code>.lintstagedrc</code> 中配置的命令。</p><h4>3.4 husky</h4><p><code>husky</code>  工具可以定义拦截  <code>git</code>  钩子，对提交的文件和信息做校验和自动修复。</p><p>安装：</p><pre><code class="language-shell">yarn add husky -D
</code></pre><p>修改 <code>packages.json</code>：</p><pre><code class="language-json">&quot;scripts&quot;: {
    &quot;prepare&quot;: &quot;husky install&quot;,
}
</code></pre><p>初始化 <code>husky</code> 配置文件：</p><pre><code class="language-chain">yarn prepare
</code></pre><p>初始化 <code>husky</code> 配置文件后根目录会生成以下目录：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1907be30937b42ca8891e4ba5fc12c30~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p><code>.husky</code> 下新增配置文件 <code>pre-commit</code>：</p><pre><code class="language-shell">#!/bin/sh
. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;

npx --no-install lint-staged
</code></pre><p>在 <code>git commit</code> 之前，将会自动执行上面 <code>pre-commit</code> 脚本配置的命令。</p><h4>3.5 commitlint</h4><p><strong>commitlint</strong> 是一个 <code>git commit</code> 信息校验工具。</p><p>安装：</p><pre><code class="language-chain">yarn add commitlint @commitlint/config-conventional -D
</code></pre><p>项目根目录下添加配置文件 <code>.commitlintrc.js</code>：</p><pre><code class="language-js">module.exports = {
  extends: [&quot;@commitlint/config-conventional&quot;],
};
</code></pre><p><code>.husky</code> 下新增配置文件 <code>commit-msg</code>：</p><pre><code class="language-shell">#!/bin/sh
. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;

npx --no-install commitlint --edit $1
</code></pre><p>在 <code>git commit-msg</code> 钩子函数触发时，将会自动执行 <code>commit-msg</code> 脚本配置的命令，校验 <code>commit msg</code> 是否符合规范。</p><h3>4. 新增组件</h3><p>在 <code>src</code> 目录下新增组件：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fed1edf88d334c939f2c99ddca175e70~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>每个组件包含 4 个基础文件：</p><ul><li><code>[component-name].tsx</code></li><li><code>[component-name].scss</code></li><li><code>index.ts</code></li><li><code>[component-name].stories.mdx</code></li></ul><p>下文将举例瀑布流组件源码：</p><p>完整的瀑布流组件代码地址：<a href="https://github.com/jiaozitang/react-masonry-component2/tree/dev/src/Masonry">https://github.com/jiaozitang/react-masonry-component2/tree/dev/src/Masonry</a>。</p><h4>4.1 <code>masonry.tsx</code></h4><p>React 组件。</p><pre><code class="language-tsx">import React from &quot;react&quot;;

import { DEFAULT_COLUMNS_COUNT_POINTS, MasonryDirection } from &quot;./const&quot;;
import { useColumnCount } from &quot;./hooks&quot;;
import MasonryAbsolute from &quot;./masonry-absolute&quot;;
import MasonryColumn from &quot;./masonry-column&quot;;
import MasonryFlex from &quot;./masonry-flex&quot;;

export interface MasonryProps extends React.HTMLAttributes&lt;HTMLElement&gt; {
  /** 排列方向 */
  direction?: &quot;row&quot; | &quot;column&quot;;
  sortWithHeight?: boolean; // 是否需要按高度排序
  useAbsolute?: boolean; // 是否开启绝对定位方法实现瀑布流，该模式默认开始按高度排序
  columnsCountBreakPoints?: {
    // 自适应的配置
    [props: number]: number;
  };
  children?: React.ReactNode;
  className?: string;
  style?: Record&lt;string, any&gt;;
  gutter?: number;
}

const Masonry: React.FC&lt;MasonryProps&gt; = (props) =&gt; {
  const {
    direction = MasonryDirection.row,
    columnsCountBreakPoints = DEFAULT_COLUMNS_COUNT_POINTS,
    useAbsolute,
  } = props;
  const columnCount = useColumnCount(columnsCountBreakPoints);

  if (useAbsolute) {
    return &lt;MasonryAbsolute {...props} columnCount={columnCount} /&gt;;
  }
  if (direction === MasonryDirection.column) {
    return &lt;MasonryColumn {...props} columnCount={columnCount} /&gt;;
  }
  if (direction === MasonryDirection.row) {
    return &lt;MasonryFlex {...props} columnCount={columnCount} /&gt;;
  }
  return &lt;div&gt;&lt;/div&gt;;
};

export default Masonry;
</code></pre><h4>4.2 <code>masonry.scss</code></h4><p>组件的样式文件。</p><h4>4.3 <code>index.ts</code></h4><p>组件需要导出的内容。</p><pre><code class="language-ts">import Masonry from &quot;./masonry&quot;;
import { MasonryAbsoluteItem, MasonryItem } from &quot;./masonry-item&quot;;

export { MasonryAbsoluteItem, MasonryItem };
export type { MasonryProps } from &quot;./masonry&quot;;
export default Masonry;
</code></pre><h4>4.4 <code>masonry.stories.mdx</code></h4><p>组件案例，Storybook 特定语法。</p><p>Storybook 教程：<a href="https://storybook.js.org/">https://storybook.js.org/</a>。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a03cc90d2b9e4cf483770b7f1b29a6b4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>组件案例在 <code>yarn storybook</code> 后可以在线查看效果：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc2fc6877fc489cb2873534bffe9a72~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/509c09d9205646568fff49a5eea8611f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>也可以通过 Storybook 官方提供的工具发布成一个在线的文档地址，详细的发布教程在第三章节将会介绍。</p><h2>二、打包组件库</h2><h3>1. 技术选型</h3><p>比较热门的打包工具有 Webpack、rollup。</p><p>Webpack 对于代码分割和静态资源导入有着“先天优势”，并且支持热模块替换(HMR)，而 Rollup 并不支持，所以当项目需要用到以上，则可以考虑选择 Webpack。但是，Rollup 对于代码的 Tree-shaking 和 ES6 模块有着算法优势上的支持，若你项目只需要打包出一个简单的 bundle 包，并是基于 ES6 模块开发的，可以考虑使用 Rollup。</p><p>因此组件库打包工具选择 rollup。</p><p>更详细的 rollup 使用教程见我的另一篇博客：<a href="https://juejin.cn/post/7145090564801691684">【实战篇】最详细的 Rollup 打包项目教程</a>。</p><h3>2. 快速开始</h3><h4>2.1 安装</h4><pre><code class="language-chain">npm i rollup -g

yarn add @rollup/plugin-commonjs @rollup/plugin-node-resolve @rollup/plugin-strip @rollup/plugin-typescript rollup-plugin-postcss rollup-plugin-node-externals autoprefixer -D
</code></pre><h4>2.2 打包配置</h4><p>项目根目录下新增配置文件 <code>rollup.config.js</code>：</p><pre><code class="language-js">import commonjs from &quot;@rollup/plugin-commonjs&quot;;
import resolve from &quot;@rollup/plugin-node-resolve&quot;;
import strip from &quot;@rollup/plugin-strip&quot;;
import typescript from &quot;@rollup/plugin-typescript&quot;;
import autoprefixer from &quot;autoprefixer&quot;;
import path from &quot;path&quot;;
import externals from &quot;rollup-plugin-node-externals&quot;;
import postcss from &quot;rollup-plugin-postcss&quot;;

import pkg from &quot;./package.json&quot;;

export default [
  {
    input: &quot;./src/index.ts&quot;, // 入口文件
    output: [
      {
        // 出口文件
        dir: path.dirname(pkg.module),
        format: &quot;es&quot;, // es模块导出，支持按需加载
        name: pkg.name,
        exports: &quot;named&quot;, // 指定导出模式（自动、默认、命名、无）
        preserveModules: true, // 保留模块结构
        preserveModulesRoot: &quot;src&quot;, // 将保留的模块放在根级别的此路径下
      },
    ],
    plugins: [
      // 自动将dependencies依赖声明为 externals
      externals({
        devDeps: false,
      }),
      // 处理外部依赖
      resolve(),
      // 支持基于 CommonJS 模块引入
      commonjs(),
      // 支持 typescript，并导出声明文件
      typescript({
        outDir: &quot;es&quot;,
        declaration: true,
        declarationDir: &quot;es&quot;,
      }),
      // 支持 scss，并添加前缀
      postcss({
        plugins: [autoprefixer()],
      }),
      // 清除调试代码
      strip(),
    ],
  },
];
</code></pre><h4>2.3 入口文件</h4><p>新增文件 <code>src/index.ts</code>：</p><pre><code class="language-ts">export {
  default as Masonry,
  MasonryAbsoluteItem,
  MasonryItem,
} from &quot;./masonry&quot;;
export type { MasonryProps } from &quot;./masonry&quot;;
</code></pre><h4>2.4 打包命令</h4><p>修改 <code>packages.json</code>：</p><pre><code class="language-json">&quot;scripts&quot;: {
    &quot;build&quot;: &quot;rimraf es &amp;&amp; rollup -c&quot;,
}
</code></pre><p>打包产物如图所示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52c997d3e8544d95acc584f954a9be6f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>三、发布组件库文档网站</h2><p>Storybook 文档发布教程地址：<a href="https://storybook.js.org/docs/react/sharing/publish-storybook#gatsby-focus-wrapper">https://storybook.js.org/docs/react/sharing/publish-storybook#gatsby-focus-wrapper</a>。</p><ol><li>安装 <code>chromatic</code>：</li></ol><pre><code class="language-chain">yarn add --dev chromatic
</code></pre><ol start="2"><li>发布 <code>Storybook</code>：</li></ol><p>注意：确保<code>your-project-token</code>用您自己的项目令牌替换。</p><pre><code class="language-chain">npx chromatic --project-token=&lt;your-project-token&gt;
</code></pre><p>然后就得到了一个线上的组件库文档网站：<a href="https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E4%BB%8B%E7%BB%8D--page">https://632339a3ed0b247d36b0fa3c-njrsmzdcdj.chromatic.com/?path=/story/%E4%BB%8B%E7%BB%8D--page</a></p><h2>四、发布项目</h2><h3>1. 注册 npm</h3><p>如已注册可跳过该步骤。</p><p>注册帮助文档：<a href="https://docs.npmjs.com/creating-a-new-npm-user-account">https://docs.npmjs.com/creating-a-new-npm-user-account</a></p><h3>2. 登录 npm</h3><p>进入项目根目录，并登录：</p><pre><code class="language-chain">npm login
</code></pre><p>如果已经登录过，可以查看登录过的账号是否是期望的账号：</p><pre><code class="language-chain">npm whoami
</code></pre><h3>3. 开源证书</h3><p>项目根目录下新增 <code>LICENCE.md</code>：</p><p>注意：替换<code>[npm username]</code>为你刚刚登录的 username。</p><pre><code class="language-md">The MIT License (MIT)

Copyright (c) [npm username]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</code></pre><h3>4. 更新 npm 包数据</h3><p>更新 <code>packages.json</code>：</p><p>注意：</p><ul><li>确认 name 未被注册过，如果已被注册过将无法发布成功；</li><li>module、types 需要和 rollup 配置的输出路径一致。</li></ul><pre><code class="language-json">&quot;name&quot;: &quot;xx&quot;,
  &quot;version&quot;: &quot;1.0.3&quot;,
  &quot;author&quot;: {
    &quot;name&quot;: &quot;xx&quot;,
    &quot;email&quot;: &quot;xx&quot;
  },
  &quot;description&quot;: &quot;xx&quot;,
  &quot;homepage&quot;: &quot;https://github.com/xx&quot;,
  &quot;keywords&quot;: [
    &quot;react&quot;,
    &quot;masonry&quot;,
    &quot;css&quot;,
    &quot;flexbox&quot;,
    &quot;responsive&quot;,
    &quot;absolute&quot;,
    &quot;column&quot;
  ],
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;module&quot;: &quot;es/index.js&quot;,
  &quot;types&quot;: &quot;es/index.d.ts&quot;,
  &quot;files&quot;: [
    &quot;es&quot;
  ],
</code></pre><h3>5. 发布</h3><p>更新 packages.json：</p><pre><code class="language-json">&quot;version&quot;: &quot;1.0.8&quot;,
</code></pre><p>发布：</p><pre><code class="language-chain">npm publish
</code></pre><h2>五、调试项目</h2><p>项目发布成功后，如果有问题，可以通过 <code>yarn link</code> 进行调试，确认没问题后再发布版本。</p><p>link 的本质就是软链接，这样可以让我们快速使用本地正在开发的其它包。</p><p>假设组件库仓库为项目 A，使用组件库的仓库为项目 B。</p><p>在项目 A 下运行 <code>yarn link</code>，在项目 B 下运行 <code>yarn link A</code>，就可以实时调试项目 A 了。</p><h2>小结</h2><p>本文是我个人在实际开发中沉淀 React 组件库的一次小结，不是一个完美的组件库，但是也足够日常开发使用。感兴趣的朋友可以跟着一起敲一遍，发布一个属于自己的组件库。</p><ul><li>本文项目源码：<a href="https://github.com/jiaozitang/react-masonry-component2">https://github.com/jiaozitang/react-masonry-component2</a></li><li>本文组件库 npm 包地址：<a href="https://www.npmjs.com/package/react-masonry-component2">https://www.npmjs.com/package/react-masonry-component2</a></li></ul><h2>往期精彩</h2><ul><li><a href="https://juejin.cn/post/7145090564801691684">【实战篇】最详细的 Rollup 打包项目教程</a>。</li></ul><h2>参考资料</h2><ul><li><a href="https://d.umijs.org/zh-CN/guide">dumi 官网</a></li><li><a href="https://storybook.js.org/">storybook 官网</a></li><li><a href="https://create-react-app.dev/docs/getting-started">create-react-app 官网</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[类型体操的9种类型运算、4种类型套路总结]]></title>
            <link>https://jiaozitang.github.io/blog/2022/09/08/ts</link>
            <guid>/2022/09/08/ts</guid>
            <pubDate>Thu, 08 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[本文所有参考资料来自《TypeScript 类型体操通关秘籍》，想了解更加全面的类型体操知识可前往学习。]]></description>
            <content:encoded><![CDATA[<blockquote><p><strong>本文所有参考资料来自<a href="https://juejin.cn/book/7047524421182947366">《TypeScript 类型体操通关秘籍》</a></strong>，想了解更加全面的类型体操知识可前往学习。</p></blockquote><p>今天给大家分享的主题是一起来做类型体操。</p><p>主要分为 4 个部分进行介绍：</p><ol><li>类型体操的背景，通过背景了解为什么要在项目中加入类型体操；</li><li>了解类型体操的主要类型、运算逻辑、和类型套路；</li><li>类型体操实践，解析 Typescript 内置高级类型，手写 <code>ParseQueryString</code> 复杂类型；</li><li>小结，综上分享，沉淀结论。</li></ol><h2>一、背景</h2><p>在背景章节介绍的是什么是类型，什么是类型安全，怎么实现类型安全，什么是类型体操？</p><p>以了解类型体操的意义。</p><h3>1. 什么是类型？</h3><p>了解什么是类型之前，先来介绍两个概念：</p><ul><li><strong>不同类型变量占据的内存大小不同</strong></li></ul><p>boolean 类型的变量会分配 4 个字节的内存，而 number 类型的变量则会分配 8 个字节的内存，给变量声明了不同的类型就代表了会占据不同的内存空间。</p><ul><li><strong>不同类型变量可做的操作不同</strong></li></ul><p>number 类型可以做加减乘除等运算，boolean 就不可以，复合类型中不同类型的对象可用的方法不同，比如 Date 和 RegExp，变量的类型不同代表可以对该变量做的操作就不同。</p><p>综上，可以得到一个简单的结论就是，<strong>类型就是编程语言提供对不同内容的抽象定义</strong>。</p><h3>2. 什么是类型安全？</h3><p>了解了类型的概念后，那么，什么是类型安全呢？</p><p>一个简单的定义就是，类型安全就是只做该类型允许的操作。比如对于 boolean 类型，不允许加减乘除运算，只允许赋值 true、false。</p><p>当我们能做到类型安全时，可以大量的减少代码中潜在的问题，大量提高代码质量。</p><h3>3. 怎么实现类型安全？</h3><p>那么，怎么做到类型安全？</p><p>这里介绍两种类型检查机制，分别是动态类型检查和静态类型检查。</p><h4>3.1 动态类型检查</h4><p>Javascript 就是典型的动态类型检查，它在编译时，没有类型信息，到运行时才检查，导致很多隐藏 bug。</p><h4>3.2 静态类型检查</h4><p>Typescript 作为 Javascript 的超集，采用的是静态类型检查，在编译时就有类型信息，检查类型问题，减少运行时的潜在问题。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/237d2cb8235344cdaf01cd3d086d9e3c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h3>4. 什么是类型体操</h3><p>上面介绍了类型的一些定义，都是大家熟悉的一些关于类型的背景介绍，这一章节回归到本次分享的主题概念，类型体操。</p><p>了解类型体操前，先介绍 3 种类型系统。</p><h4>4.1 简单类型系统</h4><p>简单类型系统，它只基于声明的类型做检查，比如一个加法函数，可以加整数也可以加小数，但在简单类型系统中，需要声明 2 个函数来做这件事情。</p><pre><code class="language-c">int add(int a, int b) {
    return a + b
}

double add(double a, double b) {
    return a + b
}
</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1de477f89198406793a5b263495202e9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>4.2 泛型类型系统</h4><p>泛型类型系统，它支持类型参数，通过给参数传参，可以动态定义类型，让类型更加灵活。</p><pre><code class="language-c">T add&lt;T&gt;(T a, T b) {
    return a + b
}

add(1, 2)
add(1.1, 2.2)
</code></pre><p>但是在一些需要类型参数逻辑运算的场景就不适用了，比如一个返回对象某个属性值的函数类型。</p><pre><code class="language-js">function getPropValue&lt;T&gt;(obj: T, key) {
  return obj[key]
}
</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d2dcc91b09b45f8aaf83bd709ca90a3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>4.3 类型编程系统</h4><p>类型编程系统，它不仅支持类型参数，还能给类型参数做各种逻辑运算，比如上面提到的返回对象某个属性值的函数类型，可以通过 keyof、T<!-- -->[K]<!-- --> 来逻辑运算得到函数类型。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d5df41e4c594395ae48a1e549cca4c8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>总结上述，<strong>类型体操就是类型编程，对类型参数做各种逻辑运算，以产生新的类型</strong>。</p><p>之所以称之为体操，是因为它的复杂度，右侧是一个解析参数的函数类型，里面用到了很多复杂的逻辑运算，等先介绍了类型编程的运算方法后，再来解析这个类型的实现。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67d0e24ef2c24eb59776f6cd69e5708b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>二、了解类型体操</h2><p>熟悉完类型体操的概念后，再来继续了解类型体操有哪些类型，支持哪些运算逻辑，有哪些运算套路。</p><h3>1. 有哪些类型</h3><p>类型体操的主要类型列举在图中。Typescript 复用了 JS 的基础类型和复合类型，并新增元组（Tuple）、接口（Interface）、枚举（Enum）等类型，这些类型在日常开发过程中类型声明应该都很常用，不做赘述。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51221a5aa57b47e9a4637a9a086846a7~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h3>2. 运算逻辑</h3><p>重点介绍的是类型编程支持的运算逻辑。</p><p>TypeScript 支持条件、推导、联合、交叉、对联合类型做映射等 9 种运算逻辑。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bb62c81a55b45e8b8c12cb89559e3db~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><ul><li><strong>条件：T extends U ? X : Y</strong></li></ul><p>条件判断和 js 逻辑相同，都是如果满足条件就返回 a 否则返回 b。</p><pre><code class="language-js">// 条件：extends ? :
// 如果 T 是 2 的子类型，那么类型是 true，否则类型是 false。
type isTwo&lt;T&gt; = T extends 2 ? true : false;
// false
type res = isTwo&lt;1&gt;;
</code></pre><ul><li><strong>约束：extends</strong></li></ul><p>通过约束语法 extends 限制类型。</p><pre><code class="language-js">// 通过 T extends Length 约束了 T 的类型，必须是包含 length 属性，且 length 的类型必须是 number。
interface Length {
    length: number
}

function fn1&lt;T extends Length&gt;(arg: T): number{
    return arg.length
}
</code></pre><ul><li><strong>推导：infer</strong></li></ul><p>推导则是类似 js 的正则匹配，都满足公式条件时，可以提取公式中的变量，直接返回或者再次加工都可以。</p><pre><code class="language-js">// 推导：infer
// 提取元组类型的第一个元素：
// extends 约束类型参数只能是数组类型，因为不知道数组元素的具体类型，所以用 unknown。
// extends 判断类型参数 T 是不是 [infer F, ...infer R] 的子类型，如果是就返回 F 变量，如果不是就不返回
type First&lt;T extends unknown[]&gt; = T extends [infer F, ...infer R] ? F : never;
// 1
type res2 = First&lt;[1, 2, 3]&gt;;
</code></pre><ul><li><strong>联合：|</strong></li></ul><p>联合代表可以是几个类型之一。</p><pre><code class="language-js">type Union = 1 | 2 | 3
</code></pre><ul><li><strong>交叉：&amp;</strong></li></ul><p>交叉代表对类型做合并。</p><pre><code class="language-js">type ObjType = { a: number } &amp; { c: boolean }
</code></pre><ul><li><strong>索引查询：keyof T</strong></li></ul><p>keyof 用于获取某种类型的所有键，其返回值是联合类型。</p><pre><code class="language-js">// const a: &#x27;name&#x27; | &#x27;age&#x27; = &#x27;name&#x27;
const a: keyof {
    name: string,
    age: number
} = &#x27;name&#x27;
</code></pre><ul><li><strong>索引访问：T<!-- -->[K]</strong></li></ul><p>T<!-- -->[K]<!-- --> 用于访问索引，得到索引对应的值的联合类型。</p><pre><code class="language-js">interface I3 {
  name: string,
  age: number
}

type T6 = I3[keyof I3] // string | number

</code></pre><ul><li><strong>索引遍历： in</strong></li></ul><p>in 用于遍历联合类型。</p><pre><code class="language-js">const obj = {
    name: &#x27;tj&#x27;,
    age: 11
}

type T5 = {
    [P in keyof typeof obj]: any
}

/*
{
  name: any,
  age: any
}
*/
</code></pre><ul><li><strong>索引重映射： as</strong></li></ul><p>as 用于修改映射类型的 key。</p><pre><code class="language-js">// 通过索引查询 keyof，索引访问 t[k]，索引遍历 in，索引重映射 as，返回全新的 key、value 构成的新的映射类型
type MapType&lt;T&gt; = {
    [
    Key in keyof T
    as `${Key &amp; string}${Key &amp; string}${Key &amp; string}`
    ]: [T[Key], T[Key], T[Key]]
}
// {
//     aaa: [1, 1, 1];
//     bbb: [2, 2, 2];
// }
type res3 = MapType&lt;{ a: 1, b: 2 }&gt;

</code></pre><h3>3. 运算套路</h3><p>根据上面介绍的 9 种运算逻辑，我总结了 4 个类型套路。</p><ul><li>模式匹配做提取；</li><li>重新构造做变换；</li><li>递归复用做循环；</li><li>数组长度做计数。</li></ul><h4>3.1 模式匹配做提取</h4><p>第一个类型套路是模式匹配做提取。</p><p>模式匹配做提取的意思是通过类型 extends 一个模式类型，把需要提取的部分放到通过 infer 声明的局部变量里。</p><p>举个例子，用模式匹配提取函数参数类型。</p><pre><code class="language-js">type GetParameters&lt;Func extends Function&gt; =
    Func extends (...args: infer Args) =&gt; unknown ? Args : never;

type ParametersResult = GetParameters&lt;(name: string, age: number) =&gt; string&gt;
</code></pre><p>首先用 extends 限制类型参数必须是 Function 类型。</p><p>然后用 extends 为 参数类型匹配公式，当满足公式时，提取公式中的变量 Args。</p><p>实现函数参数类型的提取。</p><h4>3.2 重新构造做变换</h4><p>第二个类型套路是重新构造做变换。</p><p>重新构造做变换的意思是想要变化就需要重新构造新的类型，并且可以在构造新类型的过程中对原类型做一些过滤和变换。</p><p>比如实现一个字符串类型的重新构造。</p><pre><code class="language-js">type CapitalizeStr&lt;Str extends string&gt; =
    Str extends `${infer First}${infer Rest}`
    ? `${Uppercase&lt;First&gt;}${Rest}` : Str;

type CapitalizeResult = CapitalizeStr&lt;&#x27;tang&#x27;&gt;
</code></pre><p>首先限制参数类型必须是字符串类型。</p><p>然后用 extends 为参数类型匹配公式，提取公式中的变量 First Rest，并通过 Uppercase 封装。</p><p>实现了首字母大写的字符串字面量类型。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4c3d22d80024369b178e5e748fc5d3b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h4>3.3 递归复用做循环</h4><p>第三个类型套路是递归复用做循环。</p><p>Typescript 本身不支持循环，但是可以通过递归完成不确定数量的类型编程，达到循环的效果。</p><p>比如通过递归实现数组类型反转。</p><pre><code class="language-js">type ReverseArr&lt;Arr extends unknown[]&gt; =
    Arr extends [infer First, ...infer Rest]
    ? [...ReverseArr&lt;Rest&gt;, First]
    : Arr;


type ReverseArrResult = ReverseArr&lt;[1, 2, 3, 4, 5]&gt;
</code></pre><p>首先限制参数必须是数组类型。</p><p>然后用 extends 匹配公式，如果满足条件，则调用自身，否则直接返回。</p><p>实现了一个数组反转类型。</p><h4>3.4 数组长度做计数</h4><p>第四个类型套路是数组长度做计数。</p><p>类型编程本身是不支持做加减乘除运算的，但是可以通过递归构造指定长度的数组，然后取数组长度的方式来完成数值的加减乘除。</p><p>比如通过数组长度实现类型编程的加法运算。</p><pre><code class="language-js">type BuildArray&lt;
    Length extends number,
    Ele = unknown,
    Arr extends unknown[] = []
    &gt; = Arr[&#x27;length&#x27;] extends Length
    ? Arr
    : BuildArray&lt;Length, Ele, [...Arr, Ele]&gt;;

type Add&lt;Num1 extends number, Num2 extends number&gt; =
    [...BuildArray&lt;Num1&gt;, ...BuildArray&lt;Num2&gt;][&#x27;length&#x27;];


type AddResult = Add&lt;32, 25&gt;
</code></pre><p>首先通过递归创建一个可以生成任意长度的数组类型</p><p>然后创建一个加法类型，通过数组的长度来实现加法运算。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75dfc700d11f4fe4aded0e9ab0b52601~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>三、类型体操实践</h2><p>分享的第三部分是类型体操实践。</p><p>前面分享了类型体操的概念及常用的运算逻辑。</p><p>下面我们就用这些运算逻辑来解析 Typescript 内置的高级类型。</p><h3>1. 解析 Typescript 内置高级类型</h3><ul><li><strong>partial 把索引变为可选</strong></li></ul><p>通过 in 操作符遍历索引，为所有索引添加 ？前缀实现把索引变为可选的新的映射类型。</p><pre><code class="language-js">type TPartial&lt;T&gt; = {
    [P in keyof T]?: T[P];
};

type PartialRes = TPartial&lt;{ name: &#x27;aa&#x27;, age: 18 }&gt;
</code></pre><ul><li><strong>Required 把索引变为必选</strong></li></ul><p>通过 in 操作符遍历索引，为所有索引删除 ？前缀实现把索引变为必选的新的映射类型。</p><pre><code class="language-js">type TRequired&lt;T&gt; = {
    [P in keyof T]-?: T[P]
}

type RequiredRes = TRequired&lt;{ name?: &#x27;aa&#x27;, age?: 18 }&gt;
</code></pre><ul><li><strong>Readonly 把索引变为只读</strong></li></ul><p>通过 in 操作符遍历索引，为所有索引添加 readonly 前缀实现把索引变为只读的新的映射类型。</p><pre><code class="language-js">type TReadonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P]
}

type ReadonlyRes = TReadonly&lt;{ name?: &#x27;aa&#x27;, age?: 18 }&gt;
</code></pre><ul><li><strong>Pick 保留过滤索引</strong></li></ul><p>首先限制第二个参数必须是对象的 key 值，然后通过 in 操作符遍历第二个参数，生成新的映射类型实现。</p><pre><code class="language-js">type TPick&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P]
}

type PickRes = TPick&lt;{ name?: &#x27;aa&#x27;, age?: 18 }, &#x27;name&#x27;&gt;
</code></pre><ul><li><strong>Record 创建映射类型</strong></li></ul><p>通过 in 操作符遍历联合类型 K，创建新的映射类型。</p><pre><code class="language-js">type TRecord&lt;K extends keyof any, T&gt; = {
    [P in K]: T
}

type RecordRes = TRecord&lt;&#x27;aa&#x27; | &#x27;bb&#x27;, string&gt;
</code></pre><ul><li><strong>Exclude 删除联合类型的一部分</strong></li></ul><p>通过 extends 操作符，判断参数 1 能否赋值给参数 2，如果可以则返回 never，以此删除联合类型的一部分。</p><pre><code class="language-js">type TExclude&lt;T, U&gt; = T extends U ? never : T

type ExcludeRes = TExclude&lt;&#x27;aa&#x27; | &#x27;bb&#x27;, &#x27;aa&#x27;&gt;
</code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377d8bba3606438daf9419f80b76e5c3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><ul><li><strong>Extract 保留联合类型的一部分</strong></li></ul><p>和 Exclude 逻辑相反，判断参数 1 能否赋值给参数 2，如果不可以则返回 never，以此保留联合类型的一部分。</p><pre><code class="language-js">type TExtract&lt;T, U&gt; = T extends U ? T : never

type ExtractRes = TExtract&lt;&#x27;aa&#x27; | &#x27;bb&#x27;, &#x27;aa&#x27;&gt;
</code></pre><ul><li><strong>Omit 删除过滤索引</strong></li></ul><p>通过高级类型 Pick、Exclude 组合，删除过滤索引。</p><pre><code class="language-js">type TOmit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;

type OmitRes = TOmit&lt;{ name: &#x27;aa&#x27;, age: 18 }, &#x27;name&#x27;&gt;
</code></pre><ul><li><strong>Awaited 用于获取 Promise 的 valueType</strong></li></ul><p>通过递归来获取未知层级的 Promise 的 value 类型。</p><pre><code class="language-js">type TAwaited&lt;T&gt; =
    T extends null | undefined
        ? T
        : T extends object &amp; { then(onfulfilled: infer F): any }
            ? F extends ((value: infer V, ...args: any) =&gt; any)
                ? Awaited&lt;V&gt;
                : never
            : T;


type AwaitedRes = TAwaited&lt;Promise&lt;Promise&lt;Promise&lt;string&gt;&gt;&gt;&gt;
</code></pre><p>还有非常多高级类型，实现思路和上面介绍的类型套路大多一致，这里不一一赘述。</p><h3>2. 解析 ParseQueryString 复杂类型</h3><p>重点解析的是在背景章节介绍类型体操复杂度，举例说明的解析字符串参数的函数类型。</p><p>如图示 demo 所示，这个函数是用于将指定字符串格式解析为对象格式。</p><pre><code class="language-js">function parseQueryString1(queryStr) {
  if (!queryStr || !queryStr.length) {
    return {}
  }
  const queryObj = {}
  const items = queryStr.split(&#x27;&amp;&#x27;)
  items.forEach((item) =&gt; {
    const [key, value] = item.split(&#x27;=&#x27;)
    if (queryObj[key]) {
      if (Array.isArray(queryObj[key])) {
        queryObj[key].push(value)
      } else {
        queryObj[key] = [queryObj[key], value]
      }
    } else {
      queryObj[key] = value
    }
  })
  return queryObj
}
</code></pre><p>比如获取字符串 a=1&amp;b=2 中 a 的值。</p><p>常用的类型声明方式如下图所示：</p><pre><code class="language-ts">function parseQueryString1(queryStr: string): Record&lt;string, any&gt; {
  if (!queryStr || !queryStr.length) {
    return {}
  }
  const queryObj = {}
  const items = queryStr.split(&#x27;&amp;&#x27;)
  items.forEach((item) =&gt; {
    const [key, value] = item.split(&#x27;=&#x27;)
    if (queryObj[key]) {
      if (Array.isArray(queryObj[key])) {
        queryObj[key].push(value)
      } else {
        queryObj[key] = [queryObj[key], value]
      }
    } else {
      queryObj[key] = value
    }
  })
  return queryObj
}
</code></pre><p>参数类型为 <code>string</code>，返回类型为 <code>Record&lt;string, any&gt;</code>，这时看到，<code>res1.a</code> 类型为 <code>any</code>，那么有没有办法，准确的知道 <code>a</code> 的类型是<code>字面量类型 1</code> 呢？</p><p>下面就通过类型体操的方式，来重写解析字符串参数的函数类型。</p><pre><code class="language-js">type ParseParam&lt;Param extends string&gt; =
    Param extends `${infer Key}=${infer Value}`
        ? {
            [K in Key]: Value
        } : Record&lt;string, any&gt;;

type MergeParams&lt;
    OneParam extends Record&lt;string, any&gt;,
    OtherParam extends Record&lt;string, any&gt;
&gt; = {
  readonly [Key in keyof OneParam | keyof OtherParam]:
    Key extends keyof OneParam
        ? OneParam[Key]
        : Key extends keyof OtherParam
            ? OtherParam[Key]
            : never
}

type ParseQueryString&lt;Str extends string&gt; =
    Str extends `${infer Param}&amp;${infer Rest}`
        ? MergeParams&lt;ParseParam&lt;Param&gt;, ParseQueryString&lt;Rest&gt;&gt;
        : ParseParam&lt;Str&gt;;
</code></pre><p>首先限制参数类型是 <code>string</code> 类型，然后为参数匹配公式 <code>a&amp;b</code>，如果满足公式，将 <code>a</code> 解析为 <code>key value</code> 的映射类型，将 <code>b</code> 递归 <code>ParseQueryString</code> 类型，继续解析，直到不再满足 <code>a&amp;b</code> 公式。</p><p>最后，就可以得到一个精准的函数返回类型，<code>res.a = 1</code>。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51e155583c2f4a7faa3fc2a9f6c4020b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>四、小结</h2><p>综上分享，从 3 个方面介绍了类型体操。</p><ul><li><p>第一点是类型体操背景，了解了什么是类型，什么是类型安全，怎么实现类型安全；</p></li><li><p>第二点是熟悉类型体操的主要类型、支持的逻辑运算，并总结了 4 个类型套路；</p></li><li><p>第三点是类型体操实践，解析了 Typescript 内置高级类型的实现，并手写了一些复杂函数类型。</p></li></ul><p>从中我们了解到需要动态生成类型的场景，必然是要用类型编程做一些运算，即使有的场景下可以不用类型编程，但是使用类型编程能够有更精准的类型提示和检查，减少代码中潜在的问题。</p><h2>参考资料+源码</h2><p>这里列举了本次分享的参考资料及示例源码，欢迎大家扩展阅读。</p><ul><li>参考资料：<a href="https://juejin.cn/book/7047524421182947366">《TypeScript 类型体操通关秘籍》</a></li><li>示例源码：<a href="https://github.com/jiaozitang/ts-demo">https://github.com/jiaozitang/ts-demo</a></li></ul><p>希望能对你有所帮助，感谢阅读～</p><p>别忘了点个赞鼓励一下我哦，笔芯 ❤️</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[20个常用的 Git 指令用法]]></title>
            <link>https://jiaozitang.github.io/blog/2022/09/04/git</link>
            <guid>/2022/09/04/git</guid>
            <pubDate>Sun, 04 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[背景]]></description>
            <content:encoded><![CDATA[<h2>背景</h2><p>两种最广泛被使用的版本管理工具就是 Git 和 svn，而 Git 优越的版本管理能力，及广被使用的 github、gitlab 开源平台，Git 成为了程序员必须掌握了一个工具。</p><p>大家都很熟练的使用着 vscode 等一些可视化工具来操作 Git，对 Git 的很多指令都不甚了解。</p><p>殊不知，可视化工具的底层就是 Git 的各个指令，当我们熟悉了 Git 指令的各种写法，将更理解在可视化工具中用到的功能的底层指令。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73fd9836ca0847d0b6f2d2e91354b983~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>Git 工作流程</h2><p>Git 分为 4 个工作区：</p><ul><li>工作区：指在本地仓库中的全部代码区域；</li><li>暂存区：指在本地仓库中通过 git add 后的代码区域；</li><li>本地仓库：指在本地仓库中的 git commit 后的代码区域；</li><li>远程仓库：远程仓库指的托管代码的服务器。</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be9dbaf612d145d1890de71f4a57829a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>常用指令</h2><h3>git clone</h3><p>git clone 命令用于将存储库克隆到本地。</p><pre><code>git clone [url] // 将存储库克隆到本地
</code></pre><h3>git init</h3><p><strong>git init 命令用于在目录中创建新的 Git 仓库。</strong></p><pre><code>- git init // 创建新的 Git 仓库，在当前路径下生成 .git 目录
</code></pre><h3>git remote</h3><p>git remote 用于管理跟踪远程仓库。</p><pre><code>git remote -v // 查看连接的远程仓库地址
git remote add origin [gitUrl] // 为本地仓库添加远程仓库地址
git push -u origin master // 将本地仓库的master和远程仓库的master进行关联
git remote origin set-url [gitUrl] // 为本地仓库修改远程仓库地址
git remote rm origin // 为本地仓库删除远程仓库连接
</code></pre><h3>git checkout</h3><p>git checkout 命令用于切换分支。</p><pre><code>git checkout [branchName] // 切换分支
git checkout -b [branchName] // 新建分支并切换到该分支
</code></pre><h3>git branch</h3><p>git branch 命令用于查看、创建、删除分支。</p><pre><code>git branch //查看本地分支
git branch -r //查看远程分支
git branch -a //查看本地和远程分支
git branch [branchName] //新建本地分支但不切换
git branch -D [branchName] //删除本地分支
git branch -m [oldBranchName] [newBranchName] //重新命名分支
</code></pre><h3>git tag</h3><p>git tag 用于创建、删除、查看标签。</p><pre><code>git tag [tagName] // 新建标签
git tag // 查看标签列表
git tag -d [tagName] // 删除标签
git push origin [tagName] // 推送标签到远程仓库
</code></pre><h3>git add</h3><p><strong>git add</strong> 命令用于将本地文件添加到暂存区。</p><pre><code>git add [file1] [file2] // 添加指定文件至暂存区
git add [dir] // 添加指定目录至暂存区
git add . // 添加当前目录下所有文件至暂存区
git add -A // 添加当前仓库下的所有文件改动至暂存区
</code></pre><h3>git commit</h3><p>git commit 命令用于将暂存区内容添加到本地仓库中。</p><pre><code>git commit -m &#x27;xxx&#x27; // 将暂存区文件添加到本地仓库，并记录下备注
git commit -m &#x27;xxx&#x27; -n // 将暂存区文件添加到本地仓库，并记录下备注，同时跳过 husky hooks 设置的规则校验
git commit -am &#x27;xxx&#x27; // 将文件添加到暂存区，再添加到本地仓库，并记录下备注
</code></pre><h3>git push</h3><p>git push 命令用于将本地分支推送到远程仓库。</p><pre><code>git push [remoteName] [branchName] // 推送分支
git push --set-upstream [remoteName] [branchName] // 推送分支并建立关联关系
</code></pre><h3>git pull</h3><p>git pull 命令用于从远程仓库拉取代码并合并到本地当前分支。</p><pre><code>git pull // 从远程仓库拉取代码合并到本地，等同于 git fetch &amp;&amp; git merge
git pull --rebase // 使用rebase的模式进行合并
</code></pre><h3>git fetch</h3><p>git fetch 命令用于从远程获取代码库。</p><pre><code>git fetch // 从所有远程仓库拉取当前分支代码
git fetch [remoteName] // 从指定远程仓库拉取当前分支代码
git fetch --all // 获取所有远程仓库所有分支的更新
</code></pre><h3>git cherry-pick</h3><p>git cherry-pick 命令用于获取指定的 commit，可以将分支 a 上的 commit 1，复制到分支 b上。</p><pre><code>git cherry-pick [commitId] // 获取指定的commit
</code></pre><h3>git merge</h3><p>git merge 命令用于分支合并，将其他分支的内容合并到当前分支中。</p><pre><code>git merge [branchName]
</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14b182abe7c54161959596eb5b140299~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"/></p><h3>git rebase</h3><p>git rebase 用于分支变基。</p><pre><code>git rebase master // 将当前分支变基到 master 分支上
</code></pre><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdee372fa7654715ba5e2538b562edef~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>git rebase -i 交互模式：</p><pre><code>git rebase -i [commitId] // 基于 commitId 进行 rebase，交互式变基，可以重新编辑 commit，比如压缩合并
</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45211ea91014b459befe44034917aac~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h3>git reset</h3><p>git reset 命令用于回退版本，可以指定退回某一次提交的版本。</p><pre><code>git reset HEAD^ // 回退所有内容到上一个版本
git reset HEAD^ [filename] // 回退某文件到上一个版本
git reset [commitId] // 回退所有内容到指定版本

git reset --soft HEAD~1 // 回退本地仓库到上一个版本
git reset --hard HEAD~1 // 回退本地仓库到上一个版本，并删除工作区所有未提交的修改内容
</code></pre><h3>git revert</h3><p>git revert 指令用于回滚提交，可以回滚某一次提交记录。</p><pre><code>git revert [commitId] // 回滚某次提交
git revert [commitId] -m 1 // 回滚某次 merge 的 commit，1 代表保留主分支代码
</code></pre><h3>git stash</h3><p>git stash 用于暂存文件。</p><pre><code>git stash // 暂存文件
git stash save &#x27;aa&#x27; // 暂存文件，添加备注
git stash pop // 应用最近一次暂存文件，并删除暂存记录
git stash apply // 应用最近一次暂存，但不删除该暂存记录
git stash apply stash@{第几次暂存的代码，例如0} // 应用某一次暂存，但不删除该暂存记录；
git stash list // 暂存记录
git stash clear // 删除所有暂存记录
</code></pre><h3>git reflog</h3><p>git reflog 记录了所有的 commit 操作记录，便于错误操作后找回。</p><pre><code>git reflog
</code></pre><h3>git rm</h3><p>git rm 用于从 git 仓库删除指定文件或目录。</p><pre><code>git rm [filname]
git rm [dir]
</code></pre><h3>git log</h3><p>git log 命令用于查看 git commit 记录。</p><pre><code>git log // 查看所有 commit 记录
git  log  --grep  瀑布流 // 搜索 commit msg 有瀑布流关键字的 记录
</code></pre><h2>参考资料</h2><ul><li><a href="https://juejin.cn/post/6974184935804534815">我在工作中是如何使用 git 的</a></li><li><a href="https://juejin.cn/post/7071780876501123085">Git不要只会pull和push，试试这5条提高效率的命令</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[lerna]]></title>
            <link>https://jiaozitang.github.io/blog/2022/08/28/lerna</link>
            <guid>/2022/08/28/lerna</guid>
            <pubDate>Sun, 28 Aug 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第 2 天，点击查看活动详情]]></description>
            <content:encoded><![CDATA[<p>携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第 2 天，点击<a href="https://juejin.cn/post/7123120819437322247">查看活动详情</a></p><h2>一、背景</h2><p>或许在开发多包的过程中，总会遇到多包的发布工作流问题，详细解释就是一个 npm 包，由多个 npm 相互依赖构成，发布 npm 包 1，对其有依赖的 npm 包 2 也要一同发布，那么怎么才能将这个发布工作流简单化呢？</p><p>实现在发布 npm 包 1 时，自动检测依赖 npm 包的其他包，并同时发布，更新版本。</p><p>答案大家都知晓，那便是使用多包管理工具 lerna。</p><p>但是 lerna 官方文档(<a href="https://www.lernajs.cn/">lerna 中文文档</a>)不齐全，学习成本甚高，本文欲打造一个最详细的 lerna 手册，帮助查阅指令，熟悉 lerna。</p><h2>二、lerna 介绍</h2><p>lerna 是一个优化使用 git 和 npm 管理多包存储库工作流的工具。</p><p>它具有以下功能：</p><ul><li>自动解决 packages 之间的依赖关系；</li><li>通过 git 检测文件改动，自动发布；</li><li>根据 git 提交记录，自动生成 CHANGELOG。</li></ul><h2>三、工作模式</h2><p>lerna 支持 2 种工作模式，分别是<strong>默认模式-Locked mode</strong>和<strong>Independent mode</strong>。</p><h3>默认模式-Locked mode</h3><p>每次发布，所有有改动的包自动更新版本号，所有包的版本一致，版本号维护在 lerna.json 的 version 中。</p><h3>Independent mode</h3><p>每次发布时，将提示每个已更改的包，以及其建议的版本号，每个 package 都有自己的版本号。</p><p>设置方式：</p><pre><code class="language-shell">lerna init --independent
</code></pre><p>或修改 lerna.json：</p><pre><code class="language-shell">version: &quot;independent&quot;
</code></pre><h2>四、常用指令</h2><h3>1. lerna init</h3><p>初始化一个 lerna 工程或者升级现有 lerna 项目到当前版本的 lerna。</p><pre><code class="language-shell">lerna init
</code></pre><p>执行成功后，目录下将会生成这样的目录结构。</p><pre><code> - packages(目录)
 - lerna.json(配置文件)
 - package.json(工程描述文件)
</code></pre><h3>2. lerna create</h3><p>创建一个 package，指定包名，可指定包位置。</p><pre><code class="language-shell">lerna create &lt; name &gt; [location]

lerna create package1
lerna create package1.1 packages/package1
</code></pre><h3>3. lerna add</h3><p>为包添加依赖。</p><ul><li><code>--dev</code> devDependencies 替代 <code>dependencies</code></li><li><code>--exact</code> 安装准确版本，就是安装的包版本前面不带<code>^</code>, Eg: <code>&quot;^2.20.0&quot; ➜ &quot;2.20.0&quot;</code></li></ul><pre><code class="language-shell">lerna add lodash packages/module-1
</code></pre><h3>4. lerna bootstrap</h3><p>将本地包链接在一起并安装其余的包依赖项。</p><pre><code class="language-shell">lerna bootstrap
</code></pre><h3>5. lerna list</h3><p>列出所有的包。</p><pre><code class="language-shell">lerna list
</code></pre><h3>6. lerna import</h3><p>导入本地已经存在的包。</p><pre><code class="language-shell">lerna import [npm 包所在路径]
</code></pre><h3>7. lerna link</h3><p>项目包建立软链，类似 npm link。</p><pre><code class="language-shell">lerna link
</code></pre><h3>8. lerna clean</h3><p>删除所有包的 node_modules 目录。</p><pre><code class="language-shell">lerna clean
</code></pre><h3>9. lerna changed</h3><p>列出自上次更改后已更改的本地包。</p><pre><code class="language-shell">lerna changed
</code></pre><h3>10. lerna publish</h3><p>发布包。</p><pre><code class="language-shell">lerna publish
</code></pre><h3>11. lerna diff</h3><p>区分自上次发布以来的所有包或单个包</p><pre><code class="language-shell">lerna diff
</code></pre><h3>12. lerna info</h3><p>打印有关本地环境的调试信息。</p><pre><code class="language-shell">lerna info
</code></pre><h3>13. lerna run</h3><p>在包含该脚本的每个包中运行 npm 脚本。</p><pre><code class="language-shell">lerna run dev
</code></pre><p>在包含该脚本的指定包中运行 npm 脚本。</p><pre><code class="language-shell">lerna run dev --scope=packageA
</code></pre><h3>14. lerna version</h3><p>更新版本。</p><pre><code class="language-shell">lerna version
</code></pre><h2>五、lerna + yarn workspaces 实践</h2><h3>1. 安装</h3><pre><code class="language-shell">npm install lerna -g
</code></pre><h3>2. 创建项目</h3><pre><code class="language-shell">mkdir lerna-demo
</code></pre><h3>3. 初始化项目</h3><pre><code class="language-shell">cd ./lerna-demo
lerna init
</code></pre><p>其中 package.json &amp; lerna.json 如下:</p><pre><code class="language-shell">// package.json
{
  &quot;name&quot;: &quot;root&quot;,
  &quot;private&quot;: true, // 私有的，不会被发布，是管理整个项目，与要发布到npm的解耦
  &quot;devDependencies&quot;: {
    &quot;lerna&quot;: &quot;^4.0.0&quot;
  }
}

// lerna.json
{
  &quot;packages&quot;: [
    &quot;packages/*&quot;
  ],
  &quot;version&quot;: &quot;0.0.0&quot;
}
</code></pre><h3>4. 启用 yarn workspaces</h3><p>各个库之间存在依赖，如 A 依赖于 B，因此我们通常需要将 B link 到 A 的 node_module 里，一旦仓库很多的话，手动的管理这些 link 操作负担很大，因此需要自动化的 link 操作，按照拓扑排序将各个依赖进行 link。</p><p>启用 yarn workspaces 可以把所有的依赖提升到顶层的 node_modules 中，并且在 node_modules 中链接到本地的 package，自动的帮忙解决安装和 link 问题。</p><p>修改 package.json：</p><pre><code class="language-shell">{
    &quot;private&quot;: true, // 只有私有项目可以开启
    &quot;workspaces&quot;: [&quot;packages/*&quot;]
}
</code></pre><p>修改 lerna.json：</p><pre><code class="language-shell">{
    &quot;useWorkspaces&quot;: true,
    &quot;npmClient&quot;: &quot;yarn&quot;
}
</code></pre><h3>5. 添加 package</h3><pre><code class="language-shell">lerna create packageA
lerna create packageB
</code></pre><h3>6. 添加、删除、清除包依赖</h3><p>yarn workspaces 添加依赖：</p><pre><code class="language-shell"># 将packageA作为packageB的依赖进行安装：
$ yarn workspace packageB add packageA
# 给所有的package安装依赖:
$ yarn workspaces add lodash
# 给root 安装依赖：
$ yarn add -W -D typescript
</code></pre><p>yarn workspaces 删除依赖：</p><pre><code class="language-shell"># 删除packageB的依赖packageA：
$ yarn workspace packageB remove packageA
# 给所有的packages删除依赖:
$ yarn workspaces remove lodash
# 给root 删除依赖：
$ yarn remove -W -D typescript
</code></pre><p>yarn workspaces 安装全部依赖：</p><pre><code class="language-shell">yarn install
</code></pre><p><code>yarn install</code> 等价于 <code>lerna bootstrap --npm-client yarn --use-workspaces</code>，把所有的依赖提升到顶层的 node_modules 中，并且在 node_modules 中链接到本地的 package，自动的帮忙解决安装和 link 问题。</p><p>yarn workspaces 清除 node_modules：</p><pre><code class="language-shell">yarn workspaces run clean
</code></pre><h3>7. 项目构建</h3><p>构建所有包：</p><p>区别于普通项目之处在于各个 package 之间存在相互依赖，如 packageB 只有在 packageA 构建完之后才能进行构建，否则就会出错，这实际上要求我们以一种拓扑排序的规则进行构建。</p><p>lerna 支持按照拓扑排序规则执行命令, --sort 参数可以控制以拓扑排序规则执行命令。</p><pre><code class="language-shell"># 以拓扑排序规则在包含该脚本的每个包中运行 npm run dev 脚本。
lerna run dev --stream --sort
# 以拓扑排序规则在包含该脚本的每个包中运行 npm run build 脚本。
lerna run build --stream --sort
</code></pre><p>构建指定包：</p><pre><code class="language-shell"># 在 packageA 包中运行 npm run dev 脚本。
lerna run dev --stream --scope=packageA
# 在 packageA 包中运行 npm run build 脚本。
lerna run build --stream --scope=packageA
</code></pre><h3>8. 发布</h3><pre><code class="language-shell">lerna publish
</code></pre><p>发布指令 lerna publish 内置以下步骤：</p><ul><li><p><strong>条件验证</strong>：包含验证测试是否通过，是否存在未提交的代码，是否在主分支上进行版本发布操作等等条件验证；</p></li><li><p><strong>version_bump</strong>：发版的时候需要更新版本号，这时候如何更新版本号就是个问题，一般大家都会遵循  semVer 语义；</p></li><li><p><strong>生成 changelog</strong>：为了方便查看每个 package 每个版本解决了哪些功能，我们需要给每个 package 都生成一份 changelog 方便用户查看各个版本的功能变化；</p></li><li><p><strong>生成 git tag</strong>：为了方便后续回滚问题及问题排查通常需要给每个版本创建一个 git tag；</p></li><li><p><strong>git 发布版本</strong>：每次发版我们都需要单独生成一个 commit 记录来标记 milestone；</p></li><li><p><strong>发布 npm 包</strong>：发布完 git 后我们还需要将更新的版本发布到 npm 上，以便外部用户使用。</p></li></ul><h2>小结</h2><p>本文从 5 个方面介绍了 lerna：</p><ul><li>背景</li><li>介绍</li><li>工作模式</li><li>常用指令</li><li>lerna + yarn workspaces 实践</li></ul><p>相信你已经很熟悉 lerna 的使用了，下方还列举了参考资料，可以自行扩展阅读。</p><p>希望能对你有所帮助，感谢阅读～</p><p>别忘了点个赞鼓励一下我哦，笔芯 ❤️</p><h2>参考资料</h2><ul><li><a href="https://juejin.cn/post/6844903568751722509">lerna 管理前端模块最佳实践</a></li><li><a href="https://juejin.cn/post/6844903856153821198">Lerna 中文教程详解</a></li><li><a href="https://www.lernajs.cn/">Lerna 中文官网</a></li><li><a href="https://segmentfault.com/a/1190000023954051">Lerna --多包存储管理工具（一）</a></li><li><a href="https://juejin.cn/post/7043998041786810398">One For All：基于 pnpm + lerna + typescript 的最佳项目实践 - 理论篇</a></li><li><a href="https://juejin.cn/post/6844903918279852046">lerna+yarn workspace+monorepo 项目的最佳实践</a></li><li><a href="https://juejin.cn/post/6847902224987717639">@lerna/run(翻译)</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[hooks]]></title>
            <link>https://jiaozitang.github.io/blog/2022/08/14/hooks</link>
            <guid>/2022/08/14/hooks</guid>
            <pubDate>Sun, 14 Aug 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第 1 天，点击查看活动详情]]></description>
            <content:encoded><![CDATA[<p>携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第 1 天，<a href="https://juejin.cn/post/7123120819437322247" title="https://juejin.cn/post/7123120819437322247">点击查看活动详情</a></p><h2>背景</h2><p>现在有一个需求，是在更新
Input 输入框时，搜索数据。</p><p>类似的功能图如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78145fcd2f03485b94132cc7dd2519e6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>通过 react useEffect，简单的 demo 实现如下：</p><pre><code class="language-js">import { Input } from &#x27;antd&#x27;
import { useEffect, useState } from &#x27;react&#x27;
import &#x27;./App.css&#x27;

function App() {
  const [val, setVal] = useState(&#x27;&#x27;)

  const onSearch = (val) =&gt; {
    console.log(&#x27;搜索&#x27;, val || &#x27;全部&#x27;)
  }

  // 当 val 发生变化时，请求搜索数据
  useEffect(() =&gt; {
    onSearch(val)
  }, [val])

  return (
    &lt;div className=&#x27;App&#x27;&gt;
      &lt;Input value={val} placeholder=&#x27;请输入&#x27; onChange={(e) =&gt; setVal(e.target.value)} allowClear /&gt;
    &lt;/div&gt;
  )
}
</code></pre><p>这时可以看到，首次进入页面，会发起 2 次查询全部的搜索数据请求，然后每次输入框更新，都会发起搜索数据的请求。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f9e13517d1745c09fc31dc4fb1802a6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>为了优化性能，我们可以在搜索数据时，加入防抖的逻辑，只有当输入操作停顿指定时间后，才发起搜索数据的请求。</p><h2>lodash debounce + useCallback</h2><p>引入 lodash 的 <a href="https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options">debounce</a> 方法。</p><p><code>lodash_.debounce(func, [wait=0], [options=])</code>创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 <code>wait</code> 毫秒后调用 <code>func</code> 方法。</p><p>将 onSearch 方法用 lodash.debounce + useCallback 封装后，可以实现防抖效果。</p><pre><code class="language-js">const onSearch = useCallback(
    debounce((val) =&gt; {
      console.log(&#x27;搜索&#x27;, val || &#x27;全部&#x27;)
    }, 500),
    []
  )
</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b27578332c0143ce97ca4d79b295cc33~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>useDebounceFn</h2><p>将上述 lodash debounce + useCallback 封装为自定义 Hooks useDebounceFn，useDebounceFn 将返回一个有防抖效果的函数。</p><p><code>useDebounceFn(fn1, options)</code> 返回防抖 Hooks。</p><pre><code class="language-js">interface DebounceOptions {
  wait?: number
}

const useDebounceFn = (fn: (...args: any) =&gt; any, options: DebounceOptions) =&gt; {
  return useCallback(debounce(fn, options.wait), [])
}

const onSearch = useDebounceFn(
    (val) =&gt; {
      console.log(&#x27;搜索&#x27;, val || &#x27;全部&#x27;)
    },
    {
      wait: 500,
    }
  )
</code></pre><h2>useDebounce</h2><p>在 useDebounceFn 基础上，实现 useDebounce，返回一个具有防抖效果的 state。</p><p>创建一个新 state，setState 用 useDebounceFn 封装，<code>useDebounce(state, options)</code> 返回防抖 state。</p><pre><code class="language-js">function useDebounce&lt;T&gt;(value: T, options: DebounceOptions) {
  const [debounced, setDebounced] = useState(value)

  const update = useDebounceFn((value) =&gt; {
    setDebounced(value)
  }, options)

  useEffect(() =&gt; {
    update(value)
  }, [value])

  return debounced
}
</code></pre><p>将 useEffect 的依赖项改成 useDebounce 返回的 state，同样可以实现搜索防抖：</p><pre><code class="language-js">const debounceVal = useDebounce(val, { wait: 500 })
const onSearch = (val: string) =&gt; {
console.log(&#x27;搜索&#x27;, val || &#x27;全部&#x27;)
}

// 当 debounceVal 发生变化时，请求搜索数据
useEffect(() =&gt; {
onSearch(debounceVal)
}, [debounceVal])
</code></pre><h2>useDebounceEffect</h2><p>在 useDebounceFn 基础上，实现 useDebounceEffect，返回一个具有防抖效果的 useEffect。</p><p>创建一个新 state，setState 用 useDebounceFn 封装，依赖更新时防抖更新 state，新 state 更新时执行副作用，这时副作用就防抖执行了。</p><p><code>useDebounceEffect(effect, deps, options)</code> 返回防抖 useEffect。</p><pre><code class="language-js">function useDebounceEffect(effect: EffectCallback, deps: DependencyList, options: DebounceOptions) {
  const [debounced, setDebounced] = useState({})

  const update = useDebounceFn(() =&gt; {
    setDebounced({})
  }, options)

  useEffect(() =&gt; {
    update()
  }, deps)

  useEffect(effect, [debounced])
}
</code></pre><p>将 useEffect 改成 useDebounceEffect，就可以实现搜索防抖：</p><pre><code class="language-js">useDebounceEffect(
    () =&gt; {
      onSearch(val)
    }
    [val],
    { wait: 500 }
  )
</code></pre><h2>小结</h2><p>本文实现了 useDebounceFn、useDebounce、useDebounceEffect 3 种防抖 Hooks，这 3 个 Hooks 可以直接下载 <a href="https://ahooks.js.org/zh-CN/hooks/use-debounce">ahooks</a> 使用。</p><h2>参考资料</h2><ul><li><a href="https://ahooks.js.org/zh-CN/hooks/use-debounce">ahooks 官网</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[一些有用的 JavaScript 调试技巧]]></title>
            <link>https://jiaozitang.github.io/blog/2022/07/31/devtools2</link>
            <guid>/2022/07/31/devtools2</guid>
            <pubDate>Sun, 31 Jul 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[---]]></description>
            <content:encoded><![CDATA[<hr/><p>本文翻译自 Tapas Adhikary 的原创文章。</p><ul><li>作者：Tapas Adhikary</li><li>译者：清汤饺子</li><li>原文链接：<a href="https://blog.greenroots.info/the-definitive-guide-to-javascript-debugging-2021-edition">https://blog.greenroots.info/the-definitive-guide-to-javascript-debugging-2021-edition</a></li></ul><hr/><p>日常开发工作中，我们常用到 <code>console.log()</code> 调试 Javascript，使用 <code>console.log()</code> 需要不断的修改源码来调试，非常麻烦。</p><p>本文将介绍另一个可以高效调试 Javascript 的工具 -- 浏览器开发者工具（DevTools）。</p><p>下图是一个表单模块，当输出不符合期望时，怎么使用 DevTools 去调试，发现并解决问题呢？</p><p>下文将为你一一揭晓。</p><p>在线调试代码地址：<a href="https://greet-me-debugging.vercel.app">greet-me-debugging.vercel.app</a>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3429d8ac59d54ac38bb933a767798919~tplv-k3u1fbpfcp-zoom-1.image" alt="1_app_error.png"/></p><h2>一、了解 Sources 面板</h2><p>DevTools 提供了许多不同的工具来执行调试任务，包括 DOM 检查、分析和网络调用检查。</p><p>首先介绍的是 Sources 面板，它可以帮助我们调试 JavaScript。</p><p>你可以通过按键 F12 或使用快捷键打开 DevTools：Control+Shift+I（Windows、Linux）或 Command+Option+I（Mac）。</p><p>单击 Sources 选项卡以导航到 Sources 面板。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94438b29ad0b4d0f8fe722c48e4e020e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="2_know_source.png图"/></p><p>该 Sources 面板具有三个主要部分。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45f9698c17d04713a2dc8798ceb86e23~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="3_know_source_sections.png图"/></p><ol><li>文件导航区：页面请求的所有文件都在此处列出；</li><li>编辑区：当你从导航窗格中选择一个文件时，该文件的内容将在此处列出。我们也可以从这里编辑代码；</li><li>调试区： 你会发现这里有很多工具可以用来设置断点、检查变量值、观察变化等。</li></ol><p>如果你的 DevTools 窗口较宽或未停靠在单独的窗口中，则调试器部分将显示在代码编辑器窗格的右侧。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85f399a1ea944dfe8bc8b086dd3f76ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="4_source_wide.png图"/></p><h2>二、设置断点</h2><p>要开始调试，首先要做的是设置断点。</p><p>断点是你希望代码执行暂停以便调试它的逻辑点。</p><p>DevTools 允许你以多种不同的方式设置断点。</p><p>主要包括以下 4 种方式：</p><ul><li>在代码行；</li><li>在条件语句中；</li><li>在 DOM 节点处；</li><li>在事件侦听器上。</li></ul><h3>1. 在代码行设置断点</h3><p>设置代码行断点：</p><ul><li>单击 Sources tab；</li><li>从文件导航区浏览源文件；</li><li>转到右侧代码编辑器区中的代码行；</li><li>单击行号列以在行上设置断点。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e6b022ab0e40f7ab791c14d09d2f17~tplv-k3u1fbpfcp-zoom-1.image" alt="5_line_of_code.png图"/></p><p>这里我们在第 6 行设置了一个断点，代码执行将在这里暂停。</p><h3>2. 设置条件断点</h3><p>设置条件断点：</p><ul><li>单击 Sources tab；</li><li>从文件导航区浏览源文件；</li><li>转到右侧代码编辑器区中的代码行；</li><li>右键单击行号并选择添加条件断点选项。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b59c088ec214ca2b87517b99a329790~tplv-k3u1fbpfcp-zoom-1.image" alt="6_add_conditional_1.png图"/></p><p>代码行下方会出现一个对话框，开始输入条件。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e404950079425591a1e6acdfb23d99~tplv-k3u1fbpfcp-zoom-1.image" alt="&#x27;6_add_conditional_2.png图&#x27;"/></p><p>按 Enter 激活断点，你应该会看到一个橙色图标出现在行号列的顶部。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f61b52e690d946e39adad8db18e2dc23~tplv-k3u1fbpfcp-zoom-1.image" alt="6_add_conditional_3.png图"/></p><p><code>print()</code> 执行时，只要满足 <code>name === Joe</code> 条件，代码将暂停执行。</p><blockquote><p>提示：当你知道要调查的特定代码区域时，可以使用条件断点进一步检查以找到问题的根本原因。</p></blockquote><h3>3. 在事件监听器上设置断点</h3><p>在事件监听器上设置断点：</p><ul><li>单击 Sources tab；</li><li>展开 Event Listener Breakpoints；</li><li>从事件监听器列表选择 click 事件来设置断点。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c1cf2fa7330460a81ef7c3ff85ff432~tplv-k3u1fbpfcp-zoom-1.image" alt="8_Event_listener_breakpoint.png图"/></p><h3>4. 在 DOM 节点处设置断点</h3><p>DevTools 在 DOM 检查和调试方面同样强大。</p><p>当在 DOM 中添加、删除或更改某些内容时，你可以设置断点来暂停代码执行。</p><p>要在 DOM 更改上设置断点：</p><ul><li>单击 Elements 选项卡。</li><li>选择要设置断点的元素。</li><li>右键单击元素以获取上下文菜单。选择 Break on，然后选择 Subtree modifications、Attribute modifications、Node removal 其中一个。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcafbc6e19db4a9b85a3e7a1840d7c69~tplv-k3u1fbpfcp-zoom-1.image" alt="7_DOM_breakpoint.png图"/></p><p>如上图所示，我们在 div 节点的更改上设置了一个断点，条件是 Subtree 修改。</p><p>当问候消息被添加到输出 div 时，代码将暂停执行。</p><h2>三、逐步执行源代码</h2><p>现在我们知道了设置断点的所有重要方法，接下来让我们看看如何通过断点来解决问题。</p><p>调试器区提供了 5 个控件来逐步执行代码。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49b5c7fa722649b6b5956c4bae16c030~tplv-k3u1fbpfcp-zoom-1.image" alt="9_debug_controls.png图"/></p><h3>1. 下一步（快捷键 - F9）</h3><p>此选项使你能够在 JavaScript 代码执行时逐行执行。如果途中有函数调用，单步执行也会进入函数内部，逐行执行，然后退出。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c0579e766b24aa8b8a80033845c396e~tplv-k3u1fbpfcp-zoom-1.image" alt="f9_step.gif图"/></p><h3>2. 跳过（快捷键 - F10）</h3><p>有时，你可能确定某些功能工作正常，不想花时间检查它们。此选项允许你在不单步执行功能的情况下执行该功能。</p><p>在下面的示例中，我们跳过了 <code>logger()</code> 函数的执行。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69d413fe302a4cbda61f2172a0f29e46~tplv-k3u1fbpfcp-zoom-1.image" alt="f10_step_over.gif图"/></p><h3>3. 进入（快捷键 - F11）</h3><p>单步执行时，你可能会感觉某个函数的行为异常并想要检查它。使用此选项可以更深入地研究函数。</p><p>在下面的示例中，我们正在单步执行函数 <code>logger()</code>。</p><p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1609737142403/Q2JkTsv3W.gif?auto=format,compress&amp;gif-q=60&amp;format=webm" alt="F11_step_into.gif图"/></p><h3>4. 跳出（快捷键 – Shift + F11）</h3><p>在单步执行一个函数时，你可能不想继续并退出它。使用此选项可退出函数。</p><p>在下面的示例中，我们进入 <code>logger()</code> 函数内部，然后立即退出。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b35094bdaa0341f991b08cf35957af82~tplv-k3u1fbpfcp-zoom-1.image" alt="shift_F11_step_out.gif图"/></p><h3>5. 跳转（快捷键 - F8）</h3><p>有时，你可能希望从一个断点跳转到另一个断点，而无需在其间调试任何代码。使用此选项跳转到下一个断点。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a46a71178c3404384b4219d152c865c~tplv-k3u1fbpfcp-zoom-1.image" alt="F8_run_jump.gif图"/></p><h3>6. 禁用和删除断点</h3><p>要一次禁用所有断点，请单击“停用断点”按钮（在下方圈出。）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/314f773f0da54695bbeaea5ce45ef446~tplv-k3u1fbpfcp-zoom-1.image" alt="disable_bp.png图"/></p><p>请注意，上述方法不会删除断点。它只是在你需要的时间内停用它们。要激活breakpoints，请再次单击相同的按钮。</p><p>你可以通过取消选中复选框从“断点”面板中删除一个或多个断点。你可以通过右键单击并选择 Remove all breakpoints 选项来永久删除所有断点。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/742f27438ff64ecfa63b24aa46d4392a~tplv-k3u1fbpfcp-zoom-1.image" alt="11_remove_all_bp.png图"/></p><h2>四、检查范围、调用堆栈和值</h2><p>当你逐行调试时，你可以检查变量的范围和值以及函数调用的调用堆栈。</p><h3>1. 范围</h3><p>你可以在 scope 选项中查看全局变量及 this 指向。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65007ee945084af0af6507d7ec658d97~tplv-k3u1fbpfcp-zoom-1.image" alt="9_scope.png图"/></p><h3>2. 调用堆栈</h3><p>调用堆栈面板有助于识别函数执行堆栈。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83830f17e4c0478fb4eb57edeb3ec9bd~tplv-k3u1fbpfcp-zoom-1.image" alt="9_call_stack.png图"/></p><h3>3. 值</h3><p>检查值是识别代码中的错误的主要方法。单步执行时，你只需将鼠标悬停在变量上即可检查值。</p><p>在下面的示例中，我们选择变量 name 以在代码执行阶段检查其值。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab56728756ad47428d4c4639167a8d65~tplv-k3u1fbpfcp-zoom-1.image" alt="9_see_values.png图"/></p><p>此外，你可以选择代码的一部分作为表达式来检查值。在下面的示例中，我们选择了一个表达式 <code>document.getElementById(&#x27;m_wish&#x27;)</code> 来检查值。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45373fb6554421783e0b6f76328112b~tplv-k3u1fbpfcp-zoom-1.image" alt="9_see_values_2.png图"/></p><h3>4. Watch</h3><p>Watch 选项使你能够添加一个或多个表达式并在执行时观察它们的值。当你想要在代码逻辑之外进行一些计算时，此功能非常有用。</p><p>你可以组合代码区域中的任何变量并形成有效的 JavaScript 表达式。在单步执行时，你将能够看到表达式的值。</p><p>以下是添加 Watch 所需的步骤：</p><ul><li>单击 Watch 部分上方的 + 图标</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e363035a894146c6872d0f028ef084a3~tplv-k3u1fbpfcp-zoom-1.image" alt="10_watch_1.png图"/></p><ul><li>添加要 Watch 的表达式。在这个例子中，我们添加了一个希望观察其值的变量。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7984a201b6b4a6894e62d6eb34ac219~tplv-k3u1fbpfcp-zoom-1.image" alt="10_watch_2.png图"/></p><p>另一种监听表达式的方法是在控制台里输入表达式。请参阅下面的示例以了解如何激活它。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be74841ef5014099ad8403dcef2c3154~tplv-k3u1fbpfcp-zoom-1.image" alt="10_watch_3.png图"/></p><h2>五、使用 Visual Studio Code 调试 JavaScript</h2><p>你最喜欢的代码编辑器是什么？就个人而言，我喜欢 Visual Studio 代码，因为它很简单。只需几个简单的步骤，我们就可以使用 VS Code 启用类似的调试环境。</p><h3>1. 用于调试的 VS Code 设置</h3><p>VS Code 支持安装插件来启用各种特性和功能。</p><p>要启用 JavaScript 调试，你需要安装一个名为 Debugger for Chrome 的插件。</p><p>你可以在 VS Code 的 Extensions 面板中搜索此扩展并安装它。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4aa86cc6ebc4614b4ba5c6b7d80e40a~tplv-k3u1fbpfcp-zoom-1.image" alt="图像.png图"/></p><ul><li>安装后，单击左侧的 Run 选项并创建配置以运行/调试 JavaScript 应用程序。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87dd5507368b44319e7a1ec826ad5b49~tplv-k3u1fbpfcp-zoom-1.image" alt="图像.png图"/></p><ul><li>将创建一个名为 launch.json 的文件，其中包含一些设置信息。它可能看起来像这样：</li></ul><pre><code class="language-js">{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: &lt;https://go.microsoft.com/fwlink/?linkid=830387&gt;
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
      {
          &quot;type&quot;: &quot;chrome&quot;,
          &quot;request&quot;: &quot;launch&quot;,
          &quot;name&quot;: &quot;Debug the Greet Me app&quot;,
          &quot;url&quot;: &quot;&lt;http://localhost:5500&gt;&quot;,
          &quot;webRoot&quot;: &quot;${workspaceFolder}&quot;
      }
  ]
}
</code></pre><p>你可能需要更改以下参数：</p><ol><li>name：项目名称。</li><li>url：项目在本地运行的 URL。</li><li>webRoot：默认值为 ${workspaceFolder}，即当前文件夹。你可能希望将其更改为 index.html 等文件所在的入口点文件夹。</li></ol><ul><li>最后一步是通过单击左上角的小播放图标开始调试。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1915f9440d894791898b266c233158e4~tplv-k3u1fbpfcp-zoom-1.image" alt="图像.png图"/></p><h3>2. 了解调试器面板</h3><p>VS Code 提供了类似 DevTools 的工具来调试 JavaScript。你会发现与我们目前在本文中看到的 Google Chrome JavaScript 调试器有很多相似之处。</p><p>以下是你应该注意的主要部分：</p><ol><li>启用调试。按播放按钮启用调试选项。</li><li>用于单步执行断点以及暂停或停止调试的控件。这与我们在 Chrome DevTools 中看到的几乎相似，只是某些键盘快捷键可能有所不同。</li><li>在源代码上设置断点。这是相似的。</li><li>范围面板查看变量范围和值。这些在两种情况下都是完全一样的。</li><li>用于创建和监视表达式的监视面板。</li><li>执行函数的调用栈。</li><li>要启用、禁用和删除的断点列表。</li><li>调试控制台读取控制台日志消息。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e72299ac177a49908cbcfc2fc0b8c255~tplv-k3u1fbpfcp-zoom-1.image" alt="vs_code_frame.png图"/></p><h3>3. 快速演示</h3><p>这是一个快速演示（1 分钟），展示了 VS Code 调试控件的用法：<a href="https://www.youtube.com/watch?v=xKkrKS77PIY">https://www.youtube.com/watch?v=xKkrKS77PIY</a>。</p><h2>总结</h2><p>总结一下：</p><ul><li>使用工具来调试 JavaScript 代码总是更好。像 Google ChromeDevTools 或 VS Code 调试器扩展这样的工具比仅仅依靠 console.log() 调试效率更高；</li><li>DevToolsSource Panel 非常强大，能够检查变量值、观察表达式、理解范围、读取调用堆栈等；</li><li>有几种设置方式断点，我们应该根据调试情况使用它们；</li><li>VS Code debugger 扩展程序功能非常强大。</li></ul><h2>往期精彩</h2><ul><li><a href="https://juejin.cn/post/7126050935746330654/">一些有用的 JavaScript 调试技巧（一）</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[devtools1]]></title>
            <link>https://jiaozitang.github.io/blog/2022/07/30/devtools1</link>
            <guid>/2022/07/30/devtools1</guid>
            <pubDate>Sat, 30 Jul 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[本文分享一些不常见但很有用的JavaScript 调试技巧，能够有效提高浏览器开发工具的使用效率。]]></description>
            <content:encoded><![CDATA[<blockquote><p>本文分享一些不常见但很有用的JavaScript 调试技巧，能够有效提高浏览器开发工具的使用效率。</p></blockquote><h2>一、元素面板</h2><p>首先介绍的是 Elements 面板。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/248a4723f47f45fab794841b22ad6775~tplv-k3u1fbpfcp-zoom-1.image" alt="元素.png"/></p><h3>1. 重新排列元素的位置</h3><p>可以拖放元素以在位置上上下移动，可用于编辑/调试 HTML 结构。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baed937d71fc46ca8e9e32034b0a3975~tplv-k3u1fbpfcp-zoom-1.image" alt="dom_move.gif"/></p><h3>2. 在元素面板中引用节点</h3><p>可以通过 <code>$0</code> 调试元素面板选中的 DOM 节点。</p><blockquote><p>注意：如果你在你的项目中使用 jQuery，你可以使用<code>$($0)</code>jQuery API 来访问和应用这个元素。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9776839a6f1c4acbb5c8b319f9de2ad2~tplv-k3u1fbpfcp-zoom-1.image" alt="参考元素.gif"/></p><h3>3. 用一个 DOM 节点做很多事情，比如截屏？</h3><p>可以在不退出调试器工具的情况下截取 DOM 节点的屏幕截图。</p><p>选择一个节点按下 <code>ctrl-shift-p</code>（Mac 快捷键），输入 <code>screen</code> 搜索截图功能，完成 DOM 节点的屏幕截图。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58a03aa60040442f99acf7b2c2a78c5b~tplv-k3u1fbpfcp-zoom-1.image" alt="截图.gif"/></p><blockquote><p>同时，按下 <code>ctrl-shift-p</code> 后还有很多功能可以使用，可以自行探索。</p></blockquote><h2>二、控制台面板</h2><p>接下来介绍的是 console 面板的使用技巧：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eac15ffa6be54cd0bea5310806c2e24b~tplv-k3u1fbpfcp-zoom-1.image" alt="cosnole.png"/></p><h3>1. 多行 console</h3><p>按住<code>shift-enter</code>以继续执行每一行，完成后，按<code>enter</code>键，可以实现多行日志。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/310a18a94c9e4a60bcc8a6b2591c0185~tplv-k3u1fbpfcp-zoom-1.image" alt="多行控制台.gif"/></p><h3>2. 控制台日志格式化</h3><p>除了 <code>console.log(&#x27;Hi&#x27;)</code>，还有一些更有用的格式化版本：</p><ul><li>%s 将变量格式化为字符串；</li><li>%d 将变量格式化为整数；</li><li>%f 将变量格式化为浮点数；</li><li>%o 可用于打印 DOM 元素；</li><li>%O 用于打印对象表示；</li><li>%c 用于传递 CSS 来格式化字符串。</li></ul><p>在控制台面板中下列代码：</p><pre><code>console.log(
  &#x27;%c I have %d %s&#x27;,
  &#x27;color: green; background:black; font-size: 20pt&#x27;,
  3,
  &#x27;Bikes!&#x27;
)
</code></pre><p>输出如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8788f2edd2b439082f90cfa6ef63aeb~tplv-k3u1fbpfcp-zoom-1.image" alt="格式控制台.png"/></p><h3>3. 存储为全局变量</h3><p>可以将 JSON 对象的任何部分保存为可在控制台面板中访问的全局变量：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/921d432878774428bad600b5083546da~tplv-k3u1fbpfcp-zoom-1.image" alt="global_var_console.gif"/></p><h3>4. 控制台面板中的高级日志记录</h3><h4>4.1 console.dir</h4><pre><code class="language-js">console.log([&#x27;Apple&#x27;, &#x27;Orange]);
</code></pre><p>输出：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e9b295a0c10454eb97137ce5dda426f~tplv-k3u1fbpfcp-zoom-1.image" alt="高级日志1.png"/></p><pre><code class="language-js">console.dir([&#x27;Apple&#x27;, &#x27;Orange&#x27;])
</code></pre><p>输出与上面几乎相同，但它明确表示类型为<code>Array</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e867a004c63a4fd28aaea721ee9e5063~tplv-k3u1fbpfcp-zoom-1.image" alt="高级日志2.png"/></p><h4>4.2 console.table</h4><p>console.table 会在控制台中打印一个表格。</p><p>当您处理复杂的对象时，只需将其打印为 table 即可。</p><p>看看它的实际效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/624acad3b0074a33b5b4f7ade00e75e1~tplv-k3u1fbpfcp-zoom-1.image" alt="控制台表.gif"/></p><h3>5.保存控制台日志</h3><p>只需选中图示复选框，即可在导航到其他页面时保留控制台中的日志：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a688435122c41ab9b583e6331018493~tplv-k3u1fbpfcp-zoom-1.image" alt="保存日志.gif"/></p><h3>6. console.group</h3><p>有时，保持日志松散会导致调试延迟。</p><p>console.group 可以将所有日志组合在一起。</p><pre><code class="language-js">console.group(&#x27;Testing my calc function&#x27;);
console.log(&#x27;adding 1 + 1 is&#x27;, 1 + 1);
console.log(&#x27;adding 1 - 1 is&#x27;, 1 - 1);
console.log(&#x27;adding 2 * 3 is&#x27;, 2 * 3);
console.log(&#x27;adding 10 / 2 is&#x27;, 10 / 2);
console.groupEnd();
`
</code></pre><p>输出是一个分组的日志：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17499251ce2b4dadaa8b491c998b4a5a~tplv-k3u1fbpfcp-zoom-1.image" alt="分组日志.png"/></p><h3>7. console.time</h3><p>console.time 可以测量执行一段代码需要多长时间。</p><pre><code class="language-js">function test time() {
  var users= [
    {
      firstname: &quot;Tapas&quot;,
      lastname: &quot;Adhikary&quot;,
      hobby: &quot;Blogging&quot;
    },
    {
      firstname: &quot;David&quot;,
      lastname: &quot;Williams&quot;,
      hobby: &quot;Chess&quot;
    },
    {
      firstname: &quot;Brad&quot;,
      lastname: &quot;Crets&quot;,
      hobby: &quot;Swimming&quot;
    },
    {
      firstname: &quot;James&quot;,
      lastname: &quot;Bond&quot;,
      hobby: &quot;Spying&quot;
    },
    {
      firstname: &quot;Steve&quot;,
      lastname: &quot;S&quot;,
      hobby: &quot;Talking&quot;
    }
  ];

  var getName = function (user) {
    return user.lastname;
  }

  // Start the time which will be bound to the string &#x27;loopTime&#x27; 
  console.time(&quot;loopTime&quot;);

  for (let counter = 0; counter &lt; 1000 * 1000 * 1000; counter++) {
    getName(users[counter &amp; 4]);
  }

  // End the time tick for &#x27;loopTime
  console.timeEnd(&quot;loopTime&quot;);
}
</code></pre><p>从控制台面板或节点环境中运行上述代码后，您将获得如下输出，</p><pre><code>loopTime: 2234.032958984375ms
</code></pre><p>这是计算十亿用户的姓氏所需的总时间（以毫秒为单位）。</p><h3>8. $_ 获取上一个的执行输出</h3><p><code>$_</code> 可以获取上一个的执行输出，作为输入提供给您的下一个执行逻辑。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/250fb34985384f23a45b21965194bb75~tplv-k3u1fbpfcp-zoom-1.image" alt="last_ref.gif"/></p><h2>小结</h2><p>以上是我整理的一小部分 DevTools 使用技巧。</p><p>您可以从 <a href="https://developers.google.com/web/tools/chrome-devtools/">Google 的 Web 开发人员工具</a> 中找到完整使用文档。</p><h2>往期精彩</h2><ul><li><a href="https://juejin.cn/post/7126455415394713631/">一些有用的 JavaScript 调试技巧（二）</a></li></ul><hr/><p>本文翻译自 Tapas Adhikary 的原创文章。</p><ul><li>作者：Tapas Adhikary</li><li>译者：清汤饺子</li><li>原文链接：<a href="https://blog.greenroots.info/devtools-my-favorite-tips-and-tricks">https://blog.greenroots.info/devtools-my-favorite-tips-and-tricks</a></li></ul><hr/>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[浅学一下 storybook]]></title>
            <link>https://jiaozitang.github.io/blog/2022/06/24/storybook</link>
            <guid>/2022/06/24/storybook</guid>
            <pubDate>Fri, 24 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[什么是 storybook]]></description>
            <content:encoded><![CDATA[<h2>什么是 storybook</h2><p><a href="https://storybook.js.org/docs/react/get-started/introduction/">storybook</a>是一个组件开发工具，它提供了完整的组件开发的生态环境，包括插件、用例、文档等等。</p><p>storybook 支持 react、vue、angular、web component 等主流前端 UI 框架。</p><h2>怎么用 storybook</h2><p>storybook 需要安装到已经设置了框架的项目中。</p><p>新建 react 应用</p><pre><code>npx create-react-app react-app
</code></pre><p>初始化 storybook 配置</p><pre><code>npx storybook init
</code></pre><p>启动 storybook</p><pre><code>npm run storybook
</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f606359fdc834fa38fb9c84ac8f8fe98~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>给组件写 story，一个 story 表示组件的一种状态。</p><p>story 的文件名约定为.stories.js。</p><pre><code>import React from &#x27;react&#x27;;

import { Button } from &#x27;./Button&#x27;;

export default {
  title: &#x27;Button&#x27;, // 侧边栏导航名称
  component: Button, // 组件地址
};

export const Primary = () =&gt; &lt;Button primary&gt;Button&lt;/Button&gt;;

</code></pre><p>storybook 呈现的用例展示如下</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/620e0dc2ff2544b18560a8efcc506944~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>storybook 附带了内置的工具栏：</p><ul><li>canvas：用于缩放组件、设置背景、设置尺寸及方向</li><li>docs：用于查看组件文档，从组件代码自动推断</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/160e54ad953b4066aa6dbd8a3db86882~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><p>storybook 附带了内置的插件：</p><ul><li>controls：支持动态修改组件参数</li><li>actions：验证交互是否通过回调产生正确的输出</li></ul><h2>参考资料</h2><ul><li><a href="https://storybook.js.org/docs/react/get-started/introduction/">storybook 官网</a></li><li><a href="https://juejin.cn/post/6862258700430606349">[Web 翻译]Storybook 6.0</a></li><li><a href="https://juejin.cn/post/6844903873602125838">StoryBook 实战</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[浅学一下 webpack5 module federation]]></title>
            <link>https://jiaozitang.github.io/blog/2022/06/13/module-federation</link>
            <guid>/2022/06/13/module-federation</guid>
            <pubDate>Mon, 13 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[背景]]></description>
            <content:encoded><![CDATA[<h2>背景</h2><p>在一个大中台项目中，怎么高效高性能的将多个子项目互相嵌入？</p><p>熟知的微前端解决方案有 micro-app、qiankun、webpack5 module federation 等等。</p><p>那 webpack5 module federation 是什么、如何使用、它的原理是什么呢？</p><p>本文将一一揭晓。</p><h2>module federation 是什么</h2><p>module federation 译为模块联邦，意思是模块可以在多个应用之间互相使用，应用 a 可以导出模块，也可以使用应用 b 导出的远程模块。</p><p>module federation 就是微前端的一种，而这种微前端和 micro-app、qiankun 等微前端框架确有本质的区别。</p><p>颗粒度的定义：</p><ul><li>module federation：多个互相独立的模块聚合；</li><li>qiankun：多个互相独立的应用聚合。</li></ul><p>技术实现：</p><ul><li>module federation：打包的 chunk 的聚合；</li><li>qiankun：打包的 main.js 的聚合。</li></ul><h2>如何使用</h2><p>在 webpack5 项目中新增 module federation plugin 配置。</p><p>配置项如下：</p><ul><li>name：应用名称，当作为 remote 引用时，路径为 name/expose；</li><li>library：声明全局变量的方式，name 为 umd 的 name；</li><li>filename：构建输出的文件名；</li><li>remotes：远程引用的应用名及其别名的映射，使用时以 key 值作为 name；</li><li>exposes：被远程引用时可暴露的资源路径及其别名；</li><li>shared：与其他应用之间可以共享的第三方依赖；<ul><li>requiredVersion: 依赖的版本；</li><li>singleton: 仅允许共享范围内的单个版本；</li><li>eager: 允许在初始块中使用这个共享模块。</li></ul></li></ul><p>项目 1 的配置：</p><pre><code class="language-js">new ModuleFederationPlugin({
      name: &#x27;host&#x27;,
      remotes: {
        remote1: &#x27;remote1@[remote1Url]/remoteEntry.js&#x27;,
        libs: &#x27;libs@[libsUrl]/remoteEntry.js&#x27;,
      },
    })
</code></pre><p>项目 2 的配置：</p><pre><code class="language-js">new ModuleFederationPlugin({
  name: &#x27;remote1&#x27;,
  filename: &#x27;remoteEntry.js&#x27;,
  exposes: {
    &#x27;./Button&#x27;: &#x27;./src/Button&#x27;,
  },
  remotes: {
    libs: &#x27;libs@[libsUrl]/remoteEntry.js&#x27;,
  },
})
</code></pre><p>通过 module federation 实现了项目 1 的 Button 组件在项目 2 的聚合。</p><p>示例 demo 见：<a href="https://github.com/jiaozitang/mf-demo">https://github.com/jiaozitang/mf-demo</a>。</p><h2>原理</h2><p>module federation 远程模块 remotes 和共享模块 shared 都是异步 chunk，通过 import 动态引入，实现按需加载。</p><h2>小结</h2><p>module federation 的应用场景有限，因为它仅仅是模块的聚合，不具备应用之间的隔离性。</p><p>通常适用于多个应用依赖不同组件库的组件的场景。</p><p>这些组件库将组件通过 module federation 暴露，应用通过 module federation 引入远程组件。</p><h2>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/352936804">Module Federation 没有魔法仅仅是异步chunk</a></li><li><a href="https://www.cnblogs.com/breakdown/p/15336672.html">ModuleFederation-模块联邦</a></li><li><a href="https://webpack.docschina.org/concepts/module-federation/">https://webpack.docschina.org/concepts/module-federation/</a></li><li><a href="https://webpack.docschina.org/plugins/module-federation-plugin">https://webpack.docschina.org/plugins/module-federation-plugin</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Typescript 常用特性小结]]></title>
            <link>https://jiaozitang.github.io/blog/2022/05/23/ts</link>
            <guid>/2022/05/23/ts</guid>
            <pubDate>Mon, 23 May 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[一、高级类型]]></description>
            <content:encoded><![CDATA[<h2>一、高级类型</h2><h3>交叉类型</h3><p>交叉类型就是通过 &amp; 符号，将多个类型合并为一个类型。</p><pre><code class="language-js">interface I1 {
  name: string;
}

interface I2 {
  age: number;
}

type T3 = I1 &amp; I2

const a: T3 = {
  name: &#x27;tj&#x27;,
  age: 11,
}
</code></pre><h3>联合类型</h3><p>联合类型就是通过 | 符号，表示一个值可以是几种类型之一。</p><pre><code class="language-js">const a: string | number = 1
</code></pre><h3>字符串字面量类型</h3><p>字符串字面量类型就是使用一个字符串类型作为变量的类型。</p><pre><code class="language-js">const a: &#x27;number&#x27; = &#x27;number&#x27;
</code></pre><h3>数字字面量类型</h3><p>数字字面量类型就是使用一个数字作为变量的类型。</p><pre><code class="language-js">const a: 1 = 1
</code></pre><h3>布尔字面量类型</h3><p>数字字面量类型就是使用一个布尔值作为变量的类型。</p><pre><code class="language-js">const a: true = true
</code></pre><h3>字符串模板类型</h3><p>字符串模板类型就是通过 ES6 的模板字符串语法，对类型进行约束。</p><pre><code class="language-js">type https = `https://${string}`
const a:https = `https://jd.com`
</code></pre><h2>二、操作符</h2><h3>keyof</h3><p>keyof 用于获取某种类型的所有键，其返回值是联合类型。</p><pre><code class="language-js">// const a: &#x27;name&#x27; | &#x27;age&#x27; = &#x27;name&#x27;
const a: keyof {
    name: string,
    age: number
} = &#x27;name&#x27;
</code></pre><h3>typeof</h3><p>typeof 用于获取对象或者函数的结构类型。</p><pre><code class="language-js">const a2 = {
  name: &#x27;tj&#x27;,
}

type T1 = typeof a2 // {name: string}

function fn1(x: number): number {
  return x * 10
}

type T2 = typeof fn1 // (x: number) =&gt; number
</code></pre><h3>in</h3><p>in 用于遍历联合类型。</p><pre><code class="language-js">const obj = {
    name: &#x27;tj&#x27;,
    age: 11
}

type T5 = {
    [P in keyof typeof obj]: any
}

/*
{
  name: any,
  age: any
}
*/
</code></pre><h3>T<!-- -->[K]</h3><p>T<!-- -->[K]<!-- --> 用于访问索引，得到索引对应的值的联合类型。</p><pre><code class="language-js">interface I3 {
  name: string,
  age: number
}

type T6 = I3[keyof I3] // string | number

</code></pre><h2>三、运算符</h2><h3>非空断言运算符</h3><p>非空断言运算符 ! 用于强调元素是非 null 非 undefined，告诉 Typescript 该属性会被明确的赋值。</p><pre><code class="language-js">function Demo(): JSX.Element () {
  const divRef = useRef&lt;HTMLDivElement&gt;()
  useEffect(() =&gt; {
    divRef.current!.scrollIntoView() // 断言divRef.current 是非 null 非 undefined
  }, [])
  return &lt;div ref={divRef}&gt;divDemo&lt;/div&gt;
}
</code></pre><h3>可选链运算符</h3><p>可选链运算符 ?. 用于判断左侧表达式的值是否是 null 或 undefined，如果是将停止表达式运行。</p><pre><code class="language-js">const a = b?.a
</code></pre><h3>空值合并运算符</h3><p>空值合并运算符 ?? 用于判断左侧表达式的值是否是 null 或 undefined，如果不是返回右侧的值。</p><pre><code class="language-js">const a = b ?? 10
</code></pre><h3>数字分隔符</h3><p>数字分隔符 <!-- -->_<!-- --> 用于对长数字进行分割，便于数字的阅读，编译结果将会自动去除 <!-- -->_<!-- -->。</p><pre><code class="language-js">const num: number = 1_111_111_111
</code></pre><h2>四、类型别名</h2><p>类型别名用来给一个类型起个新名字。</p><pre><code class="language-js">type Message = string | string[]
let greet = (message: Message) =&gt; {
  // ...
}
</code></pre><h2>五、类型断言</h2><p>类型断言就是告诉浏览器我非常确定的类型。</p><pre><code class="language-js">// 尖括号 语法
let someValue: any = &quot;this is a string&quot;;
let strLength: number = (&lt;string&gt;someValue).length;

// as 语法
let someValue: any = &quot;this is a string&quot;;
let strLength: number = (someValue as string).length;

</code></pre><h2>七、类型守卫</h2><p>类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。</p><pre><code class="language-js">interface A {
  name: string;
  age: number;
}
interface B {
  sex: string;
  home: string;
}
function doSomething(person: A | B): void {
  if (person.name) {
    // Error
    // ...
  }
}
// 使用 in 类型守卫
function doSomething(person: A | B): void {
  if (&#x27;name&#x27; in person) {
    // OK
    // ...
  }
}
// 使用 typeof 类型守卫
function A(a: string | number): string | number {
  if (typeof a === &#x27;string&#x27;) {
    // OK
    return a + &#x27;&#x27;
  }
  if (typeof a === &#x27;number&#x27;) {
    // OK
    return a + 2
  }
  return &#x27;&#x27;
}
// instanceof类型守卫
class Foo {}
class Bar {}

function test(input: Foo | Bar) {
  if (input instanceof Foo) {
    // 这里 input 的类型「收紧」为 Foo
  } else {
    // 这里 input 的类型「收紧」为 Bar
  }
}
</code></pre><h2>八、泛型</h2><h3>1. 泛型介绍</h3><p>泛型就是通过给类型传参，得到一个更加通用的类型，就像给函数传参一样。</p><p>如下我们得到一个通用的泛型类型 T1，通过传参，可以得到 T2 类型 string[]、T3 类型 number[]：</p><pre><code class="language-js">type T1&lt;T&gt; = T[]

type T2 = T1&lt;string&gt; // string[]

type T3 = T1&lt;number&gt; // number[]
</code></pre><p>如上 T 是变量，我们可以用任意其他变量名代替他。</p><pre><code class="language-js">type T4&lt;A&gt; = A[]

type T5 = T4&lt;string&gt; // string[]

type T6 = T4&lt;number&gt; // number[]
</code></pre><h3>2. 命名规范</h3><p>在 Typescript 泛型变量的命名规范中，默认了 4 种常见的泛型变量名，为提高可读性，不建议改为其他的变量名来定义。</p><ul><li>T：表示第一个参数</li><li>K： 表示对象的键类型</li><li>V：表示对象的值类型</li><li>E：表示元素类型</li></ul><h3>3. 泛型接口</h3><p>泛型接口和上述示例类似，为接口类型传参：</p><pre><code class="language-js">interface I1&lt;T, U&gt; {
  name: T;
  age: U;
}

type I2 = I1&lt;string, number&gt;
</code></pre><h3>4. 泛型约束(extends 操作符)</h3><p>有时候，我们需要对泛型参数进行约束，限制每个变量的类型。Typescript 通过 extends 实现类型约束。</p><p>泛型约束语法如下：</p><pre><code class="language-js">泛型名 extends 类型
</code></pre><p>通过 T extends Length 约束了 T 的类型，必须是包含 length 属性，且 length 的类型必须是 number。</p><pre><code class="language-js">interface Length {
    length: number
}

function fn1&lt;T extends Length&gt;(arg: T): number{
    return arg.length
}
</code></pre><p>通过 extends 约束了 K 必须是 T 的 key。</p><pre><code class="language-js">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
    return obj[key];
}

let tsInfo = {
    name: &quot;Typescript&quot;,
    supersetOf: &quot;Javascript&quot;,
    difficulty: Difficulty.Intermediate
}

let difficulty: Difficulty =
    getProperty(tsInfo, &#x27;difficulty&#x27;); // OK

let supersetOf: string =
    getProperty(tsInfo, &#x27;superset_of&#x27;); // Error

</code></pre><h3>5. 泛型参数默认值</h3><p>泛型参数默认值，和函数参数默认值一样，在没有传参时，给定默认值。</p><pre><code class="language-js">interface I4&lt;T = string&gt; {
  name: T;
}

const S1: I4 = { name: &#x27;123&#x27; } // 默认 name: string类型
const S2: I4&lt;number&gt; = { name: 123 }
</code></pre><h3>6. 泛型条件</h3><p>条件类型和 Js 的条件判断意思一样，都是指如果满足条件，就 xx，否则 xx。</p><p>条件类型表达式：</p><pre><code class="language-js">T extends U ? X : Y
</code></pre><p>如果 T 能够赋值给 U，那么类型是 X，否则类型是 Y。</p><pre><code class="language-js">type T1&lt;T&gt; = T extends string ? &#x27;string&#x27; : &#x27;number&#x27;
type T2 = T1&lt;string&gt; // &#x27;string&#x27;
type T3 = T1&lt;number&gt; // &#x27;number
</code></pre><h3>7. 泛型推断(infer 操作符)</h3><p>泛型推断的关键字是 infer，语法是 <code>infer 类型</code>。</p><p>一般是和泛型条件结合使用，结合实际例子理解：</p><p>如果泛型参数 T 能赋值给类型 <code>{t: infer Test}</code>，那么类型是推断类型 Test，否则类型是 string。</p><pre><code class="language-js">type Foo&lt;T&gt; = T extends {t: infer Test} ? Test : string
</code></pre><ul><li>泛型参数 number 没有 t 属性，所以类型是 string</li></ul><pre><code class="language-js">type One = Foo&lt;number&gt; // string
</code></pre><ul><li>泛型参数的 t 属性是 boolean，所以类型是推断类型 boolean</li></ul><pre><code class="language-js">type Two = Foo&lt;{ t: boolean }&gt; // boolean
</code></pre><p>泛型参数的 t 属性是 () =&gt; void，所以类型是推断类型 () =&gt; void</p><pre><code class="language-js">type Three = Foo&lt;{ a: number, t: () =&gt; void }&gt; // () =&gt; void
</code></pre><h3>8. 泛型工具类型</h3><h4>映射类型</h4><p>映射类型，它是一种泛型类型，可用于把原有的对象类型映射成新的对象类型。</p><p>常见的映射类型语法：</p><pre><code class="language-js">{ [ P in K ] : T }
{ [ P in K ] ?: T }
{ [ P in K ] -?: T }
{ readonly [ P in K ] : T }
{ readonly [ P in K ] ?: T }
{ -readonly [ P in K ] ?: T }
</code></pre><p>举例说明，通过映射类型将所有属性变为可选：</p><pre><code class="language-js">type Partial&lt;T&gt; = {
  [P in keyof T]?: T[P]
}
</code></pre><h4>Partial</h4><p>Typescript 已将一些常用的映射类型进行封装，如 Partial 就是用于将泛型的全部属性变为可选。</p><pre><code class="language-js">type Partial&lt;T&gt; = {
  [P in keyof T]?: T[P]
}

type T1 = Partial&lt;{
  name: string,
}&gt;

const a: T1 = {} // 没有name属性也不会报错
</code></pre><h4>Required</h4><p>Required 将泛型的所有属性变为必选。</p><pre><code class="language-js">type Required&lt;T&gt; = {
  [P in keyof T]-?: T[P]
}

type T2 = Required&lt;{
  name?: string,
}&gt;

const b: T2 = {} // ts报错，类型 &quot;{}&quot; 中缺少属性 &quot;name&quot;，但类型 &quot;Required&lt;{ name?: string | undefined; }&gt;&quot; 中需要该属性。ts(2741)
</code></pre><blockquote><p>语法-?，是把?可选属性减去的意思</p></blockquote><h4>Readonly</h4><p>Readonly 将泛型的所有属性变为只读。</p><pre><code class="language-js">type T3 = Readonly&lt;{
  name: string,
}&gt;

const c: T3 = {
  name: &#x27;tj&#x27;,
}

c.name = &#x27;tj1&#x27; // ts 报错，无法分配到 &quot;name&quot; ，因为它是只读属性。ts(2540)
</code></pre><h4>Pick</h4><p>Pick 从类型中选择一下属性，生成一个新类型。</p><pre><code class="language-js">type Pick&lt;T, K extends keyof T&gt; = {
  [P in K]: T[P]
}

type T4 = Pick&lt;
  {
    name: string,
    age: number,
  },
  &#x27;name&#x27;
&gt;

/*

这是一个新类型，T4={name: string}

*/

const d: T4 = {
  name: &#x27;tj&#x27;,
}
</code></pre><h4>Record</h4><p>Record 将 key 和 value 转化为 T 类型。</p><pre><code class="language-js">type Record&lt;K extends keyof any, T&gt; = {
  [key in K]: T
}

const e: Record&lt;string, string&gt; = {
  name: &#x27;tj&#x27;,
}

const f: Record&lt;string, number&gt; = {
  age: 11,
}
</code></pre><blockquote><p>keyof any 对应的类型为 number | string | symbol，是可以做对象键的类型集合。</p></blockquote><h4>ReturnType</h4><p>ReturnType 获取 T 类型对应的返回值类型。</p><pre><code class="language-js">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any
</code></pre><h4>Exclude</h4><p>Exclude 将某个类型中属于另一个的类型移除掉。</p><pre><code class="language-js">type Exclude&lt;T, U&gt; = T extends U ? never : T;

type T0 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // &quot;b&quot; | &quot;c&quot;
type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;; // &quot;c&quot;
type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // string | number

</code></pre><h4>Extract</h4><p>Extract 从 T 中提取出 U。</p><pre><code class="language-js">type Extract&lt;T, U&gt; = T extends U ? T : never;

type T0 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;; // &quot;a&quot;
type T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt;void
</code></pre><h4>Omit</h4><p>Omit 使用 T 类型中除了 K 类型的所有属性，来构造一个新的类型。</p><pre><code class="language-js">type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;

interface Todo {
  title: string;
  completed: boolean;
  description: string;
}

type TodoPreview = Omit&lt;Todo, &quot;description&quot;&gt;;

/*
{
  title: string;
  completed: boolean;
}
*/
</code></pre><h4>NonNullable</h4><p>NonNullable 用来过滤类型中的 null 及 undefined 类型。</p><pre><code class="language-js">type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;

type T0 = NonNullable&lt;string | number | undefined&gt;; // string | number
type T1 = NonNullable&lt;string[] | null | undefined&gt;; // string[]
</code></pre><h4>Parameters</h4><p>Parameters 用于获得函数的参数类型组成的元组类型。</p><pre><code class="language-js">type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any
? P : never;

type A = Parameters&lt;() =&gt;void&gt;; // []
type B = Parameters&lt;typeofArray.isArray&gt;; // [any]
type C = Parameters&lt;typeofparseInt&gt;; // [string, (number | undefined)?]
type D = Parameters&lt;typeofMath.max&gt;; // number[]
</code></pre><h2>参考资料</h2><ul><li><p><a href="https://juejin.cn/post/7018805943710253086">2021 typescript 史上最强学习入门文章(2w 字)</a></p></li><li><p><a href="https://juejin.cn/post/6926794697553739784">TypeScript 高级用法</a></p></li><li><p><a href="https://juejin.cn/post/7003171767560716302#heading-70">重学 TypeScript</a></p></li><li><p><a href="https://www.tslang.cn/docs/handbook/advanced-types.html">Typescript 官网</a></p></li><li><p><a href="https://juejin.cn/post/6844904184894980104#heading-2">一文读懂 TypeScript 泛型及应用（ 7.8K 字）</a></p></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JavaScript 函数式编程-入门篇]]></title>
            <link>https://jiaozitang.github.io/blog/2022/03/12/function-code</link>
            <guid>/2022/03/12/function-code</guid>
            <pubDate>Sat, 12 Mar 2022 19:11:14 GMT</pubDate>
            <description><![CDATA[本文将从什么是函数式编程、函数式编程的特点、如何使用函数式编程等 3 个方面带你入门 Javascript 函数式编程。]]></description>
            <content:encoded><![CDATA[<p><img src="https://img14.360buyimg.com/ling/jfs/t1/211906/13/12376/431721/6208fae4E49caa61b/7f286fcdbf89fd66.jpg"/></p><p>本文将从什么是函数式编程、函数式编程的特点、如何使用函数式编程等 3 个方面带你入门 Javascript 函数式编程。</p><h2>一、什么是函数式编程</h2><p>先来一个官方的解释：</p><blockquote><p><strong>函数式编程</strong>，是一种<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F">编程范式</a>，它将<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E9%81%8B%E7%AE%97">电脑运算</a>视为<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>运算，并且避免使用程序<a href="https://zh.wikipedia.org/w/index.php?title=%E7%8A%B6%E6%80%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&amp;action=edit&amp;redlink=1">状态</a>以及<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6">易变对象</a>。</p></blockquote><p>比起<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B">命令式编程</a>，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p><h3>1. 举例说明</h3><p>有一个数据转换的需求，需要将 <code>[&#x27;tom&#x27;, &#x27;bob&#x27;, &#x27;alice&#x27;]</code> 转换为 <code>[{name: &#x27;Tom&#x27;}, {name: &#x27;Bob&#x27;}, {name: &#x27;Alice&#x27;}]</code>。</p><p>解析一下功能点：</p><ul><li>字符串数组转 <code>key</code> 为 <code>name</code> 数组对象；</li><li><code>name</code> 字符串转换为首字符大写。</li></ul><h4>命令式编程</h4><p>命令式编程实现该需求，实现思路如下：</p><ul><li>声明临时变量 <code>arr2</code> 存放新数组；</li><li>声明临时变量 <code>first</code>、<code>rest</code> 存放字符串，并进行转首字母大写的操作；</li><li>通过 <a href="http://array.map">array.map</a> 得到新数组，赋值给 <code>arr2</code>。</li></ul><p>实现代码如下：</p><pre><code class="language-javascript">const arr = [&#x27;tom&#x27;, &#x27;bob&#x27;, &#x27;alice&#x27;]
const arr2 = arr.map(i =&gt; {
 const first = i.substring(0, 1)
 const rest = i.substring(1, i.length)
 return {
  name: first.toUpperCase() + rest.toLowerCase()
 }
})
</code></pre><h4>函数式编程</h4><p>函数式编程实现该需求，实现思路如下：</p><ul><li>字符串转首字母大写的函数；</li><li>字符串生成对象的函数；</li><li>字符串转指定格式对象的函数；</li><li>数组转数组对象的函数。</li></ul><p>实现代码如下：</p><pre><code class="language-javascript">const { curry, compose, map } = require(&#x27;ramda&#x27;)

// 首字符大写
const capitalize = (x) =&gt; x[0].toUpperCase() + x.slice(1).toLowerCase()

// 字符串生成对象
const genObj = curry((key, x) =&gt; {
  let obj = {}
  obj[key] = x
  return obj
})

// 字符串转对象，ex：&#x27;tom&#x27; =&gt; { name: &#x27;Tom&#x27; }
const convert2Obj = compose(genObj(&#x27;name&#x27;), capitalize)

// 数组转数组对象，ex：[&#x27;tom&#x27;] =&gt; [{ name: &#x27;Tom&#x27; }]
const convertName = map(convert2Obj)

console.log(convertName([&#x27;tom&#x27;, &#x27;bob&#x27;, &#x27;alice&#x27;]))
</code></pre><blockquote><p>这儿使用到了 <a href="https://ramda.cn/">ramda</a>  包中的 <code>curry</code> 和 <code>compose</code> 函数。</p></blockquote><p>从上面例子可知，函数式编程就是通过函数的组合变换去解决问题的一种编程方式。</p><p>在函数式编程中，函数是<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%AF%B9%E8%B1%A1">头等对象</a>，意思是说一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值，被修改或者被分配给一个变量。</p><h2>二、函数式编程的特点</h2><p>在上述例子中，函数式编程看起来比命令式编程更加复杂，难以理解，那我们为什么要学习函数式编程，它能够给我们带来什么呢？</p><p>学习函数式编程，是为了让我们在编程过程中有更多编程范式的选择，可以根据不同的场景选择不同的编程范式。</p><p>那为什么 React、Redux 这些流行框架都选择并推荐函数式编程呢？因为函数式编程相较于命令式编程、面向对象编程而言，更易维护，可读性高，方便扩展。</p><h3>1. 声明式编程</h3><p>函数式编程大多时候都是在声明我需要做什么，而非怎么去做。这种编程风格称为 <a href="https://baike.baidu.com/item/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B/9939512">声明式编程</a>。</p><p>举例说明：在使用 React 时，只要描述UI，接下来状态变化后 UI 如何更新，是 React 在运行时帮你处理的，而不用开发者去写渲染逻辑和优化 diff 算法。</p><p>声明式编程具有以下优点：</p><ul><li><strong>简化开发者的工作</strong></li><li><strong>减少重复工作</strong></li><li><strong>留下改进的空间</strong></li><li><strong>提供全局协调能力</strong></li></ul><blockquote><p>更详细的声明式编程介绍：<a href="https://zhuanlan.zhihu.com/p/26085755">从年会看声明式编程(Declarative Programming)</a>。</p></blockquote><h3>2. 纯函数</h3><p>函数式编程使用<strong>纯函数</strong>组合变换计算，纯函数指的是<strong>相同的输入，永远会得到相同的输出</strong>，纯函数有以下特征：</p><h4>2.1 不依赖外部状态</h4><p>纯函数不会依赖全局变量、<code>this</code> 等外部状态。</p><pre><code class="language-javascript">// 非纯函数
let counter = 0

function increment() {
  // 引用了外部变量
    return counter++
}

// 纯函数
const increment = (counter) =&gt; counter + 1
</code></pre><h4>2.2 数据不可变</h4><p>纯函数不修改全局变量，不修改入参，不修改对象，当需要修改一个对象时，应该创建一个新的对象用来修改，而不是修改已有的对象。</p><pre><code class="language-javascript">// 非纯函数
let obj = {}

function genObj() {
    obj.a = &#x27;a&#x27;
}

// 纯函数
const genObj = (a) =&gt; {
    return {
        [a]: a
    }
}
</code></pre><h4>2.3 没有副作用</h4><p>纯函数没有副作用，副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p><blockquote><p>副作用可能包含，但不限于：更改文件系统、往数据库插入记录、发送一个 http 请求、可变数据、打印/log、获取用户输入、DOM 查询、访问系统状态等。</p></blockquote><h4>2.4 小结</h4><p>纯函数不会指向不明的 <code>this</code>、不会引用全局变量、不会直接修改数据，可以大大的提升代码的易维护性。</p><h2>三、如何使用函数式编程</h2><p>函数式编程中，函数是一等公民，那么怎么把一个复杂函数转换成多个单元函数，然后怎么把多个单元函数组合起来按顺序依次执行呢，这时候就需要用到柯里化（curry）和函数组合（compose）了。</p><h3>1. 柯里化（curry）</h3><p>柯里化的就是将一个多元函数，转换成一个依次调用的单元函数。</p><pre><code class="language-javascript">f(a,b,c) → f(a)(b)(c)
</code></pre><p>如下是一个柯里化的加法函数：</p><pre><code class="language-javascript">var add = function(x) {
  return function(y) {
    return x + y;
  };
};

var increment = add(1);
var addTen = add(10);

increment(2);
// 3

addTen(2);
// 12
</code></pre><p>如下是使用 ramda 封装的 curry 生成的单元函数：</p><pre><code class="language-javascript">const { curry } = require(&#x27;ramda&#x27;);
const replace = curry((a, b, str) =&gt; str.replace(a, b));
const replaceSpaceWith = replace(/\s*/);
const replaceSpaceWithComma = replaceSpaceWith(&#x27;,&#x27;);
const replaceSpaceWithDash = replaceSpaceWith(&#x27;-&#x27;);
</code></pre><h3>2. 函数组合（compose）</h3><p>函数组合就是将多个函数组合成一个函数。</p><p>如下是使用 ramda 封装的 compose 生成的函数组合：</p><pre><code class="language-javascript">const compose = require(&#x27;ramda&#x27;)

const f = x =&gt; x + 1;
const g = x =&gt; x * 2;
const fg = compose(f, g);
fg(1) //3

</code></pre><p>函数组合让代码变得简单而富有可读性，同时通过不同的组合方式，我们可以轻易组合出其他常用函数，让我们的代码更具表现力。</p><h2>小结</h2><p>通过上文，相信你已经对函数式编程有了一些了解，下方有一些参考资料，推荐你进行更深入的学习。</p><p>学习函数式编程只是为了让你在开发过程中多一个编程范式的选择，大多时候我们无法将所有函数写成纯函数的形式，但是我们仍可以学习函数式编程的不依赖外部状态、不改写数据的做法，通过减少共享的数据来减少开发过程的 bug 数。</p><p>希望本文能对你有所帮助，感谢阅读～</p><p>别忘了点个赞鼓励一下我哦，笔芯❤️</p><h2>参考资料</h2><ul><li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">函数式编程指北</a></li><li><a href="https://juejin.cn/post/6844903936378273799">简明 JavaScript 函数式编程——入门篇</a></li><li><a href="https://juejin.cn/post/6844903743117361165#heading-2">函数式编程，真香</a></li><li><a href="https://zhuanlan.zhihu.com/p/26085755">从年会看声明式编程(Declarative Programming)</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React-你有完全了解 Hooks 吗]]></title>
            <link>https://jiaozitang.github.io/blog/2022/02/12/React-Hooks</link>
            <guid>/2022/02/12/React-Hooks</guid>
            <pubDate>Sat, 12 Feb 2022 19:11:14 GMT</pubDate>
            <description><![CDATA[本文从 Hooks 究竟是什么，为什么要使用 Hooks，React 提供了哪些常用 Hooks，以及如何自定义 Hooks 4 个方面带你深入理解 React Hooks。]]></description>
            <content:encoded><![CDATA[<p><img src="https://img14.360buyimg.com/ling/jfs/t1/211906/13/12376/431721/6208fae4E49caa61b/7f286fcdbf89fd66.jpg"/></p><blockquote><p>本文从 Hooks 究竟是什么，为什么要使用 Hooks，React 提供了哪些常用 Hooks，以及如何自定义 Hooks 4 个方面带你深入理解 React Hooks。</p></blockquote><h2>一、前言</h2><p>Hooks 用于在不编写 class 的情况下，使用 state 以及其他 React 特性。那么 Hooks 究竟是什么，为什么要使用 Hooks，React 提供了哪些常用 Hooks，以及如何自定义 Hooks 呢，下文将为您一一揭晓。</p><blockquote><p>本文的学习资料主要来自 <a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">React 官方文档-Hook</a>和王沛老师的专栏<a href="https://time.geekbang.org/column/article/376577">《React Hooks 核心原理与实战》</a>。</p></blockquote><h2>二、什么是 Hooks</h2><p>Hooks 译为钩子，Hooks 就是在函数组件内，负责钩进外部功能的函数。</p><p>React 提供了一些常用钩子，React 也支持自定义钩子，这些钩子都是用于为函数引入外部功能。</p><p>当我们在组件中，需要引入外部功能时，就可以使用 React 提供的钩子，或者自定义钩子。</p><p>比如在组件内引入可管理 state 的功能，就可以使用 useState 函数，下文会详细介绍 useState 的用法。</p><h2>三、为什么要用 Hooks</h2><p>使用 Hooks 有 2 大原因：</p><ul><li>简化逻辑复用；</li><li>让复杂组件更易理解。</li></ul><h3>1. 简化逻辑复用</h3><p>在 Hooks 出现之前，React 必须借用高阶组件、render props 等复杂的设计模式才能实现逻辑的复用，但是高阶组件会产生冗余的组件节点，让调试更加复杂。</p><p>Hooks 让我们可以在无需修改组件结构的情况下复用状态逻辑，下文会详细介绍自定义 Hooks 的用法。</p><h3>2. 让复杂组件更易理解</h3><p>在 class 组件中，同一个业务逻辑的代码分散在组件的不同生命周期函数中，而 Hooks 能够让针对同一个业务逻辑的代码聚合在一块，让业务逻辑清晰地隔离开，让代码更加容易理解和维护。</p><h2>四、常用的 Hooks</h2><h3>1. useState</h3><p>useState 是允许你在 React 函数组件中添加 state 的 Hook。</p><p>使用示例如下：</p><pre><code class="language-javascript">import React, { useState } from &#x27;react&#x27;;

function Example() {
  // 声明一个叫 &quot;count&quot; 的 state 变量
  const [count, setCount] = useState(0);
  // ...
</code></pre><p>以上代码声明了一个初始值为 0 的 state 变量 count，通过调用 setCount 来更新当前的 count。</p><h3>2. useEffect</h3><p>useEffect 可以让你在函数组件中执行副作用操作。</p><p>副作用是指一段和当前执行结果无关的代码，常用的副作用操作如数据获取、设置订阅、手动更改 React 组件中的 DOM。</p><p>useEffect 可以接收两个参数，代码如下：</p><pre><code class="language-javascript">useEffect(callback, dependencies)
</code></pre><p>第一个参数是要执行的函数 callback，第二个参数是可选的依赖项数组 dependencies。</p><p>其中依赖项是可选的，如果不指定，那么 callback 就会在每次函数组件执行完后都执行；如果指定了，那么只有依赖项中的值发生变化的时候，它才会执行。</p><p>使用示例如下：</p><pre><code class="language-javascript">function Example() {
  const [count, setCount] = useState(0);

  // Similar to componentDidMount and componentDidUpdate:
  useEffect(() =&gt; {
    // Update the document title using the browser API
    document.title = `You clicked ${count} times`;

    return () =&gt; {
        // 可用于做清除，相当于 class 组件的 componentWillUnmount
    }

  }, [count]); // 指定依赖项为 count，在 count 更新时执行该副作用
  // ...
</code></pre><p>以上代码通过 useEffect 实现了当依赖项 count 更新时，执行副作用函数，并通过返回回调函数清除上一次的执行结果。</p><p>另外，useEffect 提供了四种执行副作用的时机：</p><ul><li><strong>每次 render 后执行</strong>：不提供第二个依赖项参数。比如 useEffect(() =&gt; {})；</li><li><strong>仅第一次 render 后执行</strong>：提供一个空数组作为依赖项。比如 useEffect(() =&gt; {}, [])；</li><li><strong>第一次以及依赖项发生变化后执行</strong>：提供依赖项数组。比如 useEffect(() =&gt; {}, <!-- -->[deps]<!-- -->)；</li><li><strong>组件 unmount 后执行</strong>：返回一个回调函数。比如 useEffect() =&gt; { return () =&gt; {} }, [])。</li></ul><h3>3. useCallback</h3><p>useCallback 定义的回调函数只会在依赖项改变时重新声明这个回调函数，这样就保证了<strong>组件不会创建重复的回调函数</strong>。而接收这个回调函数作为属性的组件，也<strong>不会频繁地需要重新渲染</strong>。</p><p>使用示例如下：</p><pre><code class="language-javascript">const memoizedCallback = useCallback(() =&gt; {
  doSomething(a, b)
}, [a, b])
</code></pre><p>以上代码在依赖项 a、b 发生变化时，才会重新声明回调函数。</p><h3>4. useMemo</h3><p>useMemo 定义的创建函数只会在某个依赖项改变时才重新计算，有助于每次渲染时<strong>不会重复的高开销的计算</strong>，而接收这个计算值作为属性的组件，也<strong>不会频繁地需要重新渲染</strong>。</p><p>使用示例如下：</p><pre><code class="language-javascript">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b])
</code></pre><p>以上代码在依赖项 a、b 发生变化时，才会重新计算。</p><h3>5. useRef</h3><p>useRef 返回一个 ref 对象，这个 ref 对象在组件的整个生命周期内持续存在。</p><p>他有 2 个用处：</p><ul><li><strong>保存 DOM 节点的引用</strong>；</li><li><strong>在多次渲染之间共享数据</strong>。</li></ul><p>保存 DOM 节点的引入使用示例如下：</p><pre><code class="language-javascript">function TextInputWithFocusButton() {
  const inputEl = useRef(null)
  const onButtonClick = () =&gt; {
    // `current` 指向已挂载到 DOM 上的文本输入元素
    inputEl.current.focus()
  }
  return (
    &lt;&gt;
      &lt;input ref={inputEl} type=&#x27;text&#x27; /&gt;
      &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre><p>以上代码通过 useRef 创建了 ref 对象，保存了 DOM 节点的引用，可以对 ref.current 做 DOM 操作。</p><p>在多次渲染之间共享数据示例如下：</p><pre><code class="language-javascript">import React, { useState, useCallback, useRef } from &#x27;react&#x27;

export default function Timer() {
  // 定义 time state 用于保存计时的累积时间
  const [time, setTime] = useState(0)

  // 定义 timer 这样一个容器用于在跨组件渲染之间保存一个变量
  const timer = useRef(null)

  // 开始计时的事件处理函数
  const handleStart = useCallback(() =&gt; {
    // 使用 current 属性设置 ref 的值
    timer.current = window.setInterval(() =&gt; {
      setTime((time) =&gt; time + 1)
    }, 100)
  }, [])

  // 暂停计时的事件处理函数
  const handlePause = useCallback(() =&gt; {
    // 使用 clearInterval 来停止计时
    window.clearInterval(timer.current)
    timer.current = null
  }, [])

  return (
    &lt;div&gt;
      {time / 10} seconds.
      &lt;br /&gt;
      &lt;button onClick={handleStart}&gt;Start&lt;/button&gt;
      &lt;button onClick={handlePause}&gt;Pause&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre><p>以上代码通过 useRef 创建了一个变量名为 timer 的 ref 对象，该对象可以在跨组件渲染时调用，在开始计时时新建计时器，在暂停计时时清空计时器。</p><h3>6. useContext</h3><p>useContext 用于接收一个 context 对象并返回该 context 的值，可以实现跨层级的数据共享。</p><p>示例如下：</p><pre><code class="language-javascript">// 创建一个 context 对象
const MyContext = React.createContext(initialValue)
function App() {
  return (
    // 通过 Context.Provider 传递 context 的值
    &lt;MyContext.Provider value=&#x27;1&#x27;&gt;
      &lt;Container /&gt;
    &lt;/MyContext.Provider&gt;
  )
}

function Container() {
  return &lt;Test /&gt;
}

function Test() {
  // 获取 Context 的值
  const theme = useContext(MyContext) // 1
  return &lt;div&gt;&lt;/div&gt;
}
</code></pre><p>以上代码通过 useContext 取得了 App 组件中定义的 Context，做到了跨层次组件的数据共享。</p><h3>7. useReducer</h3><p>useReducer 用来引入 Reducer 功能。</p><p>示例如下：</p><pre><code class="language-javascript">const [state, dispatch] = useReducer(reducer, initialState)
</code></pre><p>它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的 dispatch 函数。</p><h2>五、自定义 Hooks</h2><p>通过自定义 Hooks，可以将组件逻辑提取到可重用的函数中。</p><h3>1. 如何创建自定义 Hooks？</h3><p>自定义 Hooks 就是函数，它有 2 个特征区分于普通函数：</p><ul><li>名称以 “use” 开头；</li><li>函数内部调用其他的 Hook。</li></ul><p>示例如下：</p><pre><code class="language-javascript">import { useState, useCallback } from &#x27;react&#x27;

function useCounter() {
  // 定义 count 这个 state 用于保存当前数值
  const [count, setCount] = useState(0)
  // 实现加 1 的操作
  const increment = useCallback(() =&gt; setCount(count + 1), [count])
  // 实现减 1 的操作
  const decrement = useCallback(() =&gt; setCount(count - 1), [count])
  // 重置计数器
  const reset = useCallback(() =&gt; setCount(0), [])

  // 将业务逻辑的操作 export 出去供调用者使用
  return { count, increment, decrement, reset }
}

// 组件1
function MyComponent1() {
  const { count, increment, decrement, reset } = useCounter()
}

// 组件2
function MyComponent2() {
  const { count, increment, decrement, reset } = useCounter()
}
</code></pre><p>以上代码通过自定义 Hooks useCounter，轻松的在 MyComponent1 组件和 MyComponent2 组件之间复用业务逻辑。</p><h3>2. 自定义 Hooks 库 - react-use</h3><p>React 官方提供了 <a href="https://github.com/streamich/react-use">react-use</a> 库，其中封装了大量可直接使用的自定义 Hooks，帮助我们简化组件内部逻辑，提高代码可读性、可维护性。</p><p>其中我们常用的自定义 Hooks 有：</p><ul><li>useLocation 和 useSearchParam：跟踪页面导航栏位置状态；</li><li>useScroll：跟踪 HTML 元素的滚动位置；</li><li>useScrolling：跟踪 HTML 元素是否正在滚动；</li><li>useAsync, useAsyncFn, and useAsyncRetry：解析一个 async 函数；</li><li>useTitle：设置页面的标题。</li></ul><blockquote><p>可至 <a href="https://github.com/streamich/react-use">react-use 官网</a>学习使用。</p></blockquote><h2>六、小结</h2><p>本文从 Hooks 究竟是什么，为什么要使用 Hooks，React 提供了哪些常用 Hooks，以及如何自定义 Hooks 4 个方面介绍了 React Hooks，相信大家对 React Hooks 已经有了更加深入的理解。</p><p>希望能对你有所帮助，感谢阅读～</p><p>别忘了点个赞鼓励一下我哦，笔芯 ❤️</p><h2>参考资料</h2><ul><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">React 官方文档-Hook</a></li><li><a href="https://time.geekbang.org/column/article/376577">React Hooks 核心原理与实战</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/09/react-hooks.html">React Hooks 入门教程</a></li><li><a href="https://segmentfault.com/a/1190000038768433">轻松掌握 React Hooks 底层实现原理</a></li><li><a href="https://juejin.cn/post/6844903704437456909">阅读源码后，来讲讲 React Hooks 是怎么实现的</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[专栏学习心得《大厂晋升指南》]]></title>
            <link>https://jiaozitang.github.io/blog/2022/02/11/up-up-up</link>
            <guid>/2022/02/11/up-up-up</guid>
            <pubDate>Fri, 11 Feb 2022 19:11:14 GMT</pubDate>
            <description><![CDATA[s08502502142022]]></description>
            <content:encoded><![CDATA[<p><img src="https://img12.360buyimg.com/ling/jfs/t1/109470/8/23866/494812/6209a784E3a20dad5/22cf45c213a15cc0.jpg" alt="s08502502142022"/></p><blockquote><p>本文从晋升体系、学习方法、做事方法 4 个方向介绍了学习大厂晋升指南的心得，其中晋升体系、职级详解提升认知，学习方法、做事方法提高效率，相信会对你有所帮助。</p></blockquote><h2>一、前言</h2><p>在比较长的一段时间，我的学习方向非常随心所欲，想学什么就开始读官方文档，找源码，学习效率不高。</p><p>我也开始反思，我这样的学习方法是不是太过于浪费好不容易在下班后挤出的宝贵时间。</p><p>我开始找提高学习效率的教程，于是找到了<a href="https://time.geekbang.org/column/intro/100064501?tab=catalog">《大厂晋升指南》</a>。在专栏中，我找到了好的学习方法和做事方法，下文将分享我的一些学习心得。</p><p><strong>薅羊毛 tips：</strong>
<strong>如果你有点进去你会发现这个专栏是收费的！不过不怕，可以薅羊毛，下载 app 可以免费阅读 5 天，差不多也能学完这个专栏。</strong></p><h2>二、晋升体系</h2><p>在第一章节晋升体系中，了解职级体系、晋升流程、晋升原则、晋升逻辑、职级档次，不再无的放矢的寻找晋升的方法。</p><h3>1. 职级体系</h3><p>互联网公司晋升体系包含介跨越式职级体系和阶梯式职级体系两种，跨越式相邻级别差异大、晋升机会少，阶梯式相邻级别差异小、晋升机会多。</p><p>了解了职级体系后，判断自己所在公司属于哪个类别，清晰自己的目标。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d544789786481c902e47c2bc3eca77~tplv-k3u1fbpfcp-zoom-1.image" alt="s11141202112022"/></p><h3>2. 晋升流程</h3><p>晋升流程包括主管提名-&gt;部门内初筛-&gt;评委团考察-&gt;部门调控-&gt;高层确认-&gt;主管/HR 沟通。</p><ul><li>主管提名：<strong>绩效满足、年限满足、能力满足</strong>；</li><li>部门内初筛：横向对比多个团队提名的人时，<strong>能力满足</strong>；</li><li>评委团考察：<strong>答辩材料过关、答辩现场表现过关</strong>；</li><li>部门调控：横向对比多个团队答辩的人时，<strong>答辩过关</strong>；</li><li>高层确认：等待即可；</li><li>主管/HR 沟通：等待即可。</li></ul><p>因此，技术能力和答辩的技巧是同等重要，不仅在日常要储备技术能力，也要加强表达技巧，能够把自己优秀的点非常好的表现出来。</p><h3>3. 晋升原则</h3><p>晋升有 3 大原则，满足以下原则会更容易晋升：</p><ul><li>主动原则：<strong>主动做事</strong>（主动找 leader 沟通工作、主动找别人沟通了解更多信息）；</li><li>成长原则：<strong>一边做事一边挖掘成长点提升自己</strong>（而不是一直原地踏步用熟悉的技术）；</li><li>价值原则：<strong>学习为公司产出价值的技能</strong>（而不是只学习自己感兴趣的技能）。</li></ul><p>因此，在日常工作中，应该更加主动的沟通工作，在工作中发掘可成长的点，如引用新技术，并且持续的学习对工作有帮助的技能。</p><h3>4. 晋升逻辑</h3><p>怎么判断有没有达到晋升要求呢？应该满足以下两点：</p><ul><li><strong>能够做好当前级别的事</strong>（做到精通的水平，精通=优化和创造新的经验）；</li><li><strong>寻找机会提前做下一级别的事，并取得工作成果</strong>。</li></ul><p>因此，在日常工作中，不能仅仅埋头干活，还应该思考优化，去创造新的经验，在完全精通当前工作时，主动沟通，寻找机会提前做下一级别的事。</p><p>因为晋升和表白一样，表白是两个人时机到了互有感觉就能成功，而晋升是你已经掌握了下一级别的能力就能晋升到下一级别。两者都是充分准备后，水到渠成的事情。</p><h3>5. COMD 能力模型</h3><p>通过 COMD 能力模型把抽象的能力要求具体化，帮助我们清晰成长的目标包含的能力范围。</p><p>COMD 能力模型包含 4 种复杂度 + 3 个维度，核心思想是通过事情的复杂度来判断能力的高低。</p><p>4 种复杂度：</p><ul><li>规模复杂度：规模越大，规模复杂度越高；</li><li>时间复杂度：时间跨度越大，时间复杂度越高；</li><li>环境复杂度：环境不确定性越高，环境复杂度越高；</li><li>创新复杂度：创新程度越高，创新复杂度越高。</li></ul><p>3 个维度：</p><ul><li>技术；</li><li>业务；</li><li>管理。</li></ul><p>COMD 模型应用在 P6 的例子：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a61a1f0af9ff4485949735d8f0af396a~tplv-k3u1fbpfcp-zoom-1.image" alt="s11383702112022"/></p><p>掌握 COMD 模型后，更加清晰各个级别的能力要求，可以按照列出的能力要求进行针对性提升。</p><h3>6. 职级档次</h3><p>以阿里为例列举了 P5-P10 的职级档次对应的角色：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5cdabce7f194c5f864dc536a5ce9f69~tplv-k3u1fbpfcp-zoom-1.image" alt="s11264202112022"/></p><p>一般来说，高级别的能力要求默认包含了低级别的要求。</p><h2>三、职级详解</h2><p>从技术、业务、管理 3 个方向对 P5-P9 进行职级详解：</p><blockquote><p>各个职级具体的提升攻略见<a href="https://time.geekbang.org/column/article/319262">《大厂晋升指南-职级详解》</a>。</p></blockquote><h3>1. P5</h3><ul><li>技术：工作岗位中实际用到的基础技术的积累；</li><li>业务：熟悉各项业务的处理逻辑；</li><li>管理：了解公司的管理制度和项目流程。</li></ul><h3>2. P6</h3><ul><li>技术：掌握团队用到的技术“套路”；</li><li>业务：掌握所有功能并深度理解处理逻辑；</li><li>管理：推进项目中的子任务。</li></ul><h3>3. P7</h3><ul><li>技术：精通团队相关技术；</li><li>业务：关注业务整体；</li><li>管理：指挥 10 人以内的小团队。</li></ul><h3>4. P8</h3><ul><li>技术：精通领域相关技术；</li><li>业务：熟悉多个业务或精通端到端业务；</li><li>管理：核心是抓重点。</li></ul><h3>5. P9</h3><ul><li>技术：跨领域整合能力；</li><li>业务：从理解规划到亲自导演；</li><li>管理：授权但不要放羊。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/417289a1591241ab8c3ccfbedc6c2ade~tplv-k3u1fbpfcp-zoom-1.image" alt="s11272702112022"/></p><h2>四、学习方法</h2><h3>1. 学习方向</h3><p>找到正确的学习方向，学习方向应该围绕以下 2 个方面：</p><ul><li>工作强相关（与工作弱相关的学习优先级可降低）；</li><li>能产出价值（没有产出的学习优先级可降低）。</li></ul><h3>2. 链式学习法</h3><p>链式学习法，可以提升技术深度，让知识形成锁链，环环相扣。</p><p>分为以下步骤：</p><ul><li>明确一项技术的深度可以分为哪些层；</li><li>明确要学到哪一层；</li><li>明确每一层应该怎么学。</li></ul><h3>3. 比较学习法</h3><p>比较学习法，通过横向对比不同技术，让技术选型更加有理有据。</p><p>分为以下步骤：</p><ul><li>整理领域关键技术点；</li><li>整理不同技术的差异点；</li><li>整理差异点背后的原理和对应用场景的影响。</li></ul><h3>4. 间隔学习法</h3><blockquote><p>该方法来自<a href="https://time.geekbang.org/column/article/331463">大厂晋升指南 - 19 | 链式 &amp; 比较 &amp; 环式学习法：怎么多维度提升技术能力？</a>评论区</p></blockquote><p>长期记忆的形成，需要有个巩固的过程，可能是数小时，可能是数天，在这期间，记忆痕迹得到加深，所学的新知识与旧知识建立连接，带来稳固的长期记忆，因此不要频繁的进行集中式学习，而是有间隔的进行。</p><p>拿学习专栏来说，不要反复地去学习同一章节，而是有间隔地进行，等遗忘一些后进行练习，能够形成长久的记忆。</p><h3>5. Teach 学习法</h3><p>通过教别人来提升自己，我的方式是<strong>写博客</strong>。</p><p>学习完技术后，将学到的东西通过博客的方式，传授给其他人。</p><p>在写博客的过程中可以巩固、梳理知识，并且输出学习成果，加强学习的深度。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bde90cba595e452290e5c688e4d4a817~tplv-k3u1fbpfcp-zoom-1.image" alt="s11450402112022"/></p><h2>五、做事方法</h2><h3>1. 3C 方案设计法</h3><p>每次做事的时候至少设计 3 个方案，择优执行。</p><p>能够帮助我们系统的梳理一个领域，提升整体流程和工作效率。</p><h3>2. PDCA 执行法</h3><p>PDCA 执行法把事情的执行过程分成四个环节，保证具体事项高效高质地落地：</p><ul><li>计划：确定具体任务、阶段目标、时间节点和具体责任人；</li><li>执行：落地各项具体活动；</li><li>检查：检查实际执行结果；</li><li>行动：明确下一步需要采取的措施。</li></ul><h3>3. 5Why 分析法</h3><p>找准问题源头才能治标又治本，通过追问 5 个为什么来分析问题的根本原因，从而得到彻底的解决方案。</p><h3>4. 金字塔汇报法</h3><p>金字塔汇报法来源于金字塔原理，金字塔原理的核心思想是任何事情都可以归纳出一个中心思想，中心思想可由三到七个论点支持，每个论点可以由三到七个论据支撑。</p><p>金字塔汇报法：</p><ul><li>总体结论：先抛出关键性结论；</li><li>具体分析：分析结论的因果；</li><li>关键事项：介绍做过的关键事项的情况；</li><li>总结改进：总结经验教训和后续改进措施。</li></ul><p>关键事项汇报技巧：</p><ul><li>全局大图：展示整体情况；</li><li>演进路径：展示个体的发展路径和当前所处阶段；</li><li>时间轴：展示事情发生过程；</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5f173682c3e47949c82eda655bf5880~tplv-k3u1fbpfcp-zoom-1.image" alt="s21093702112022"/></p><h3>5. 5W1H1D 分析法</h3><p>5W1H1D 分析法用于帮助我们深入理解业务，理解业务功能=分析功能需求+分析质量需求+总结上线效果。</p><p><strong>5W：需求产生的背景和功能上线后的运行环境</strong>。</p><p><strong>1H：如何去实现，整个流程是怎么运行的</strong>。</p><p><strong>1D：上线之后的业务效果</strong>。</p><p>5W 的具体描述如下：</p><ul><li>何时：需要用到该功能的时间；</li><li>何地：需要用到该功能的地点，也可以指场所，如地铁、开车等；</li><li>何人：该功能面向的人群；</li><li>何事：这个功能具体是什么，一般描述在需求文档中；</li><li>何因：为什么需要这个功能，只有真正了解客户提出需求的驱动力，才能真正解决客户的问题。</li></ul><p>通过 5W1H8C1D 分析法快速入门，上线前分析和理解业务功能，上线后熟悉运行数据。</p><h2>六、小结</h2><p>本文从晋升体系、职级详解、学习方法、做事方法 4 个方向介绍了学习<a href="https://time.geekbang.org/column/intro/100064501?tab=catalog">《大厂晋升指南》</a>的心得，其中晋升体系、职级详解提升认知，学习方法、做事方法提高效率，想了解更多可以至原文-<a href="https://time.geekbang.org/column/intro/100064501?tab=catalog">《大厂晋升指南》</a>进行学习。</p><p>希望能对你有所帮助，感谢阅读～</p><p>别忘了点个赞鼓励一下我哦，笔芯 ❤️</p><h2>参考资料</h2><ul><li><a href="https://time.geekbang.org/column/intro/100064501?tab=catalog">《大厂晋升指南》</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[【译】你知道 Code Review 应该检查哪些问题吗]]></title>
            <link>https://jiaozitang.github.io/blog/2022/01/31/【译】你知道 Code Review 应该检查哪些问题吗</link>
            <guid>/2022/01/31/【译】你知道 Code Review 应该检查哪些问题吗</guid>
            <pubDate>Mon, 31 Jan 2022 19:11:14 GMT</pubDate>
            <description><![CDATA[原文：https://www.michaelagreiler.com/code-review-checklist-2/]]></description>
            <content:encoded><![CDATA[<p>原文：<a href="https://www.michaelagreiler.com/code-review-checklist-2/">https://www.michaelagreiler.com/code-review-checklist-2/</a></p><p>原文作者：<a href="https://www.michaelagreiler.com/">Dr. McKayla</a></p><h2>一、前言</h2><p>Code Review 可以帮助我们提高代码质量、减少项目问题，那么您知道 Code Review 可以从哪些地方开始审查吗？</p><p>下文将列出一个详细的代码审查清单，该清单是作者 Dr. McKayla 在 Microsoft 与数百名工程师一起工作，分析了数千次代码审查后，总结得出的最全代码审核清单。</p><p>它分为 7 个独立的部分，每个部分都会引导我们完成几个问题。</p><h2>二、代码审查清单</h2><h3>1. 功能检查</h3><ul><li>此代码更改是否完成了它应该做的事情？</li><li>这个解决方案可以简化吗？</li><li>您是否会以在代码的可维护性、可读性、性能和安全性等方面有更好的方式解决问题？</li><li>代码库中是否有类似的功能？如果有，为什么不复用此功能？</li><li>这段代码是否遵循面向对象的分析和设计原则，如单一职责原则、开闭原则、Liskov 替换原则、接口隔离、依赖注入？</li></ul><h3>2. bug 检查</h3><ul><li>您能想到代码未按预期运行的任何用例吗？</li><li>您能想到任何可能破坏代码的输入或外部事件吗？</li></ul><h3>3. 依赖项检查</h3><ul><li>如果此更改需要在代码之外进行更新，例如更新文档、配置、自述文件，是否已完成？</li><li>这种变化是否会对系统的其他部分产生任何影响，是否已经兼容？</li><li>如果代码处理用户输入，它是否解决了跨站点脚本、SQL 注入等安全漏洞，它是否进行输入清理和验证？</li></ul><h3>4. 可用性和可访问性</h3><ul><li>从可用性的角度来看，提议的解决方案是否设计良好？</li><li>API 是否有据可查？</li><li>UI 是否可访问？</li><li>API/UI 使用起来是否直观？</li></ul><h3>5. 表现</h3><ul><li>您是否认为此代码更改会对系统性能产生负面影响？</li><li>您是否看到任何提高代码性能的潜力？</li></ul><h3>6. 测试</h3><ul><li>代码是否可测试？</li><li>它是否有足够的自动化测试（单元/集成/系统测试）？</li><li>现有的测试是否合理地涵盖了代码更改？</li><li>是否有一些测试用例、输入或边缘用例需要额外测试？</li></ul><h3>7. 可读性</h3><ul><li>代码容易理解吗？</li><li>哪些部分让您感到困惑，为什么？</li><li>可以通过更小的方法来提高代码的可读性吗？</li><li>代码的可读性可以通过不同的函数/方法或变量名来提高吗？</li><li>代码是否位于正确的文件/文件夹/包中？</li><li>更多注释会使代码更易于理解吗？</li><li>是否可以通过使代码本身更具可读性来删除一些注释？</li><li>您认为某些方法应该被重组以拥有更直观的控制流程吗？</li></ul><h2>三、自审代码</h2><p>代码审查清单不仅适用于代码审查人员。我们应该并首先成为自己的审查者，遵循代码审查最佳实践。</p><p>因此，在发送代码进行审核之前，请确保：</p><ul><li>代码编译并通过静态分析，没有警告</li><li>代码通过所有测试（单元、集成和系统测试）</li><li>您已经仔细检查了拼写错误并进行了清理（评论、待办事项等）</li><li>您概述了此更改的内容，包括更改的原因和更改的内容</li><li>除此之外，作为代码作者，您应该通过与审阅者相同的代码审查清单。</li></ul><h2>四、关注重要问题</h2><p>作为代码审查员，您的任务是首先寻找最重要的问题。结构或逻辑问题比代码格式等小问题更有价值。</p><p>一份出色的清单将您的注意力引导到重要和最有价值的问题上。</p><h2>五、自动化编码风格及约定</h2><p>清晰的编码风格指南是在代码库中强制执行一致性的唯一方法。而且，一致性使代码审查更快，允许人们轻松更改项目，并使您的代码库保持可读性和可维护性。</p><p>上文的审查清单没有介绍编码风格相关的内容，是因为我们建议使用自动化工具来强制遵守编码风格。通过安装及配置 prettier、eslint、tslint、stylelint 等格式化工具，节省编码风格的代码审查时间。</p><h2>六、注意表达方式</h2><p>最后，代码审查反馈的质量不仅取决于您在说什么，还取决于您怎么说。
建议将您的反馈表述为建议而不是要求。
例如，不要写“变量名应该是 removeObject ”，而是说“调用变量 removeObject 怎么样？”。</p><h2>七、总结</h2><p>代码审查清单以及围绕代码审查的明确规则和指南至关重要。代码审查清单可以使您的代码审查实践对您的团队更加有益，并显着加快代码审查速度。</p><p>本文详细介绍了 Code Review 的 7 种审查类型，帮助您在 Code Review 聚焦到重要和最有价值的问题上，提升 Code Review 质量。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[实践指南-快速搭建文档系统]]></title>
            <link>https://jiaozitang.github.io/blog/实践指南-快速搭建文档系统</link>
            <guid>实践指南-快速搭建文档系统</guid>
            <pubDate>Thu, 13 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[一、背景]]></description>
            <content:encoded><![CDATA[<h2>一、背景</h2><p>需求就是生产力，常规项目的文档说明，大多放在 <code>README.md</code> 下进行记录和说明，而对于为外部赋能的项目来说，一个对外开放的文档系统是必不可少的。</p><p>如下是可供参考一个标准的在线文档系统界面 - <a href="https://taro-docs.jd.com/taro/docs/README/index.html">taro 官网</a>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c32c48d991741f4845bf30d9a17e1c8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>二、技术选型</h2><p>首先理清搭建一个在线的文档系统的要求：</p><ol><li>内置 markdown 文件转网页</li><li>对 SEO 友好</li></ol><ul><li>可通过 React 扩展网页</li><li>界面美观</li><li>文档清晰，上手简单，方便部署</li><li>拓展功能丰富，如可搜索、文档版本化</li></ul><p>在上述需求背景下，找出了以下可供参考的技术栈：</p><blockquote><p>下表格数据来源：<a href="https://blog.hming.org/2019/05/15/wen-dang-wang-zhan-sheng-cheng-gong-ju-xuan-xing/">文档网站生成工具选型</a></p></blockquote><table><thead><tr><th>开源工具对比</th><th>Hexo</th><th>VuePress</th><th>Docute</th><th>Docsify</th><th>Docusaurus</th></tr></thead><tbody><tr><td>文档生成方式</td><td>预先渲染 HTML</td><td>预先渲染 HTML</td><td>运行时解析</td><td>运行时解析</td><td>预先渲染 HTML</td></tr><tr><td>对 SEO 友好程度</td><td>友好</td><td>友好</td><td>不友好</td><td>不友好</td><td>友好</td></tr><tr><td>语法</td><td>-</td><td>Vue</td><td>Vue</td><td>Vue</td><td>React</td></tr><tr><td>官网地址</td><td><a href="https://hexo.io/zh-cn/docs/">hexo</a></td><td><a href="https://vuepress.vuejs.org/zh/">vuepress</a></td><td><a href="https://docute.org/zh/">docute</a></td><td>docsify</td><td><a href="https://docusaurus.io/zh-CN/docs">docusaurus</a></td></tr><tr><td>适用场景</td><td>个人博客</td><td>需要 SEO 支持的技术文档</td><td>公司或团队内部的文档系统</td><td>公司或团队内部的文档系统</td><td>需要 SEO 支持的技术文档</td></tr><tr><td>特点</td><td>与主题解耦，更换主题成本低</td><td>采用 vue，对 vue 开发友好</td><td>Docute（60kB）使用 Vue，Vue Router 和 Vuex</td><td>Docsify（20kB）使用的是 vanilla JavaScript </td><td>采用 React，对 React 开发友好</td></tr></tbody></table><p>选择使用了上手简单、对 SEO 友好、功能丰富的 Docusaurus 来搭建文档系统。</p><h2>三、快速搭建</h2><h3>1. 开始</h3><h4>1.1 新建项目</h4><p>安装  Node，并创建新的 Docusaurus 站点</p><pre><code class="language-chain">npx create-docusaurus@latest my-website classic
</code></pre><h4>1.2 启动项目</h4><p>本地启动项目</p><pre><code>yarn start
</code></pre><p>一个本地的文档系统已经搭建完成：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9267ab999fe44139b2bcbdb4e66ea56a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h3>2. 目录结构</h3><p>熟悉 Docusaurus 文档系统的目录结构，清晰后续自定义配置及文档存放位置。</p><pre><code class="language-json">.
├── blog // 包含博客的 Markdown 文件
│   └── 2022-01-13-first-blog-post.markdown
├── docs // 包含文档的 Markdown 文件
│   ├── README.markdown
│   ├── api.markdown
│   └── changelog.markdown
├── src // 非文档文件
│   ├── components
│   │   ├── HomepageFeatures.js
│   │   └── HomepageFeatures.module.css
│   ├── css
│   │   └── custom.css
│   └── pages // 转换成网站页面
│       ├── index.js
│       ├── index.module.css
│       └── markdown-page.markdown
├── static // 静态资源
│    └── img
├── docusaurus.config.js // 配置文件
└── sidebars.js // 指定侧边栏文档顺序

</code></pre><h3>3. 自定义内容</h3><p>熟悉了目录结构后，开始自定义配置，将初始化的文档项目，改成我们自己的内容。</p><h4>3.1 配置站点元数据</h4><p>包括：</p><ul><li><code>title</code>：标题</li><li><code>url</code>：文档系统域名</li><li><code>baseUrl</code>：域名下的一级地址</li><li><code>favicon</code>：网站图标</li></ul><p>修改 docusaurus.config.js：</p><pre><code class="language-javascript">const config = {
  title: &#x27;distribute-sdk&#x27;,
  url: &#x27;http://tls-pre.jd.com&#x27;,
  baseUrl: &#x27;/distribute-sdk-docs/&#x27;,
  favicon: &#x27;img/favicon.ico&#x27;,
};
</code></pre><h4>3.2 配置导航栏</h4><p>包括导航栏、logo、主站名称、coding 地址。</p><p>修改 docusaurus.config.js：</p><pre><code class="language-javascript">const config = {
  themeConfig:
    /** @type {import(&#x27;@docusaurus/preset-classic&#x27;).ThemeConfig} */
    ({
      navbar: {
        title: &#x27;Distribute SDK&#x27;,
        logo: {
          alt: &#x27;Distribute SDK Logo&#x27;,
          src: &#x27;https://img11.360buyimg.com/ling/jfs/t1/103667/23/20676/2779/61d59cd2Ef2665258/239330f23ecbae81.png&#x27;,
          href: &#x27;docs/&#x27;,
        },
        items: [
          {
            type: &#x27;doc&#x27;,
            docId: &#x27;README&#x27;,
            position: &#x27;left&#x27;,
            label: &#x27;文档&#x27;,
          },
          { to: &#x27;/blog&#x27;, label: &#x27;Blog&#x27;, position: &#x27;left&#x27; },
          {
            href: &#x27;xx&#x27;, // git remote 地址
            label: &#x27;Coding&#x27;,
            position: &#x27;right&#x27;,
          },
        ],
      },
    }),
};
</code></pre><h4>3.3 新增文档</h4><p>在 blog 路径下新建 markdown 文件，会以标题为顺序，自动生成一级目录，展示 blog 下的 markdown 文件转的静态网页。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/394f23b601184d67922762999d30e3d7~tplv-k3u1fbpfcp-zoom-1.image" alt="s11364401222022"/>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6881496fd1204df581fdeba4b8c7e8c7~tplv-k3u1fbpfcp-zoom-1.image" alt="s11362001222022"/></p><p>在 docs 路径下新建 markdown 文件，以 markdown 文件内声明的 sidebar_position 大小排序，自动生成一级目录。展示 docs 下的 markdown 文件转的静态网页。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3048ad2030d44f398a59b00974688b04~tplv-k3u1fbpfcp-zoom-1.image" alt="s11381701222022"/></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f81f9d744294cf0aa47f9b1635abaf8~tplv-k3u1fbpfcp-zoom-1.image" alt="s11383101222022"/></p><p>如下是文档网站效果：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c2b8e2634a34411b9c14d2ed0b631f5~tplv-k3u1fbpfcp-watermark.image?" alt="Untitled7.gif"/></p><h2>四、丰富功能</h2><h3>1. 自动部署</h3><p>通过公司内部 <a href="http://talos.jd.com/main/deploy">talos</a> 系统内新建项目，并在 coding 配置 webhook，实现自动部署。</p><blockquote><p>中间遇到了 talos 上编译时，node 版本低于 Docusaurus 要求的 v14 问题，故只能将编译流程放在本地进行。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4222051881d64b31a975a62a9a97e79e~tplv-k3u1fbpfcp-zoom-1.image" alt="s11441601222022"/></p><blockquote><p>外网可通过 Github Pages、Gitee Pages 实现自动部署。</p></blockquote><h3>2. 自动更新 changelog</h3><p><code>lerna version</code> 提供自动更新 changelog 功能，本文档系统也是为 lerna 搭建的项目服务。</p><p>规范了如下发布 lerna 版本流程，可实现更新版本时自动更新文档系统内的 changelog 页面：</p><ul><li><p><code>lerna version --conventional-commits</code> 确定版本号并自动生成 changelog；</p></li><li><p><code>npm run changelog</code> 将自动生成的 changelog 部署至文档系统（写一个脚本复制文件至指定位置即可）；</p></li><li><p><code>lerna publish from-git</code> 发布版本。</p></li></ul><h2>五、总结</h2><p>本文讲述了快速搭建文档系统的完整过程，总结为以下 3 点：</p><ul><li>技术选型，根据需求场景选择合适的手段实现功能；</li><li>通过官方文档快速搭建网站；</li><li>根据需求丰富更多功能。</li></ul><h2>往期精彩</h2><ul><li><a href="https://juejin.cn/post/6969538044890185758">实践指南-网页生成 PDF</a></li></ul><h2>参考资料</h2><ul><li><a href="https://juejin.cn/post/7001776879531196424#heading-6">[边写边学系列] — 超级好用的文档站建站框架 Docusaurus</a></li><li><a href="https://blog.hming.org/2019/05/15/wen-dang-wang-zhan-sheng-cheng-gong-ju-xuan-xing/">文档网站生成工具选型</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何参与大型开源项目-Taro 共建]]></title>
            <link>https://jiaozitang.github.io/blog/2021/12/20/how-to-join-Taro</link>
            <guid>/2021/12/20/how-to-join-Taro</guid>
            <pubDate>Mon, 20 Dec 2021 19:11:14 GMT</pubDate>
            <description><![CDATA[一、背景]]></description>
            <content:encoded><![CDATA[<p><img src="https://img12.360buyimg.com/ling/jfs/t1/96463/39/20942/268881/61ee05a4Eadf9afcb/cbcda37e2be5aae0.jpg"/></p><h2>一、背景</h2><p>在开发的工作中，我们都引用过大量的社区优秀的开源项目，但怎么才能更好的了解这些开源项目呢，答案是 <strong>Join it</strong>。</p><p>参与开源项目，能够帮助我们拓宽对研发项目的认识，更好的理解开源项目的原理，以及提高个人影响力、竞争力。</p><h2>二、选择项目</h2><p>人对于不熟悉的东西总是觉得高深莫测的，没有参与开源项目的经验的时候，会对参与开源项目不知道从何下手。</p><p>其实不然，在我们开发日常需求时就可以参与到开源项目中来，开发时用到的技术栈，就是我们最值得入手的开源项目了。</p><p>像我自己日常有开发微信小程序、京东小程序等跨平台的需求，这类型需求主要技术栈是 <a href="https://github.com/NervJS/taro">Taro</a>，<a href="https://github.com/NervJS/taro">Taro</a> 本身就是 github star 近 30 k 的优秀开源项目了，那么我就可以从 Taro 着手，参与到开源项目的建设工作中。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a28ef429b4047ea838208d14143f1f5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"/></p><h2>三、快速开始</h2><p>首先要了解、遵守开源项目的贡献规范，一般可以在官网找到贡献规范文档，如 <a href="https://taro-docs.jd.com/taro/docs/CONTRIBUTING">Taro 贡献指南</a>。</p><h3>1. 确定贡献形式</h3><p>贡献形式多种多样，下面我以 <strong>“提交代码”</strong> 类型快速开始贡献流程。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b01d363357f24181835ac08d43196231~tplv-k3u1fbpfcp-zoom-1.image" alt="s17110101222022"/></p><h3>2. 找到感兴趣的 issue</h3><blockquote><p>Taro 官网：issue 中会列出所有被标记为 Help Wanted 的 Issues，并且会被分为 Easy、 Medium、 Hard 三种难易程度。</p></blockquote><p>通过 issue 标签筛选，选择自己感兴趣的 issue，可以先从 <strong>&quot;Easy&quot;</strong> 的开始：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70b054166ff542e7be25584fde5f6de8~tplv-k3u1fbpfcp-zoom-1.image" alt="s17454801222022"/></p><p>在 issue 中 Assignees 至自己：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f1b088680d34783ac2712106b77cf4e~tplv-k3u1fbpfcp-zoom-1.image" alt="s17463701222022"/></p><h3>3. fork &amp; clone</h3><p>fork Taro 源码至自己仓库：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d23dd5050964d1ea3aa0b2f75c1d0c9~tplv-k3u1fbpfcp-zoom-1.image" alt="s17280901222022"/></p><p>clone 个人仓库的 Taro 源码至本地：</p><pre><code>git clone https://github.com/jiaozitang/taro
</code></pre><h3>4. 本地开发环境</h3><p>在 Taro 源码项目中安装依赖并编译：</p><pre><code># 安装依赖
$ yarn

# 编译
$ yarn build
</code></pre><p>查看该 issue 涉及哪些 package，为这些 package 设置 yarn link，并在本地编译，使得调试项目能够 link 到开发中的源码：</p><blockquote><p>Taro package 说明见文档：<a href="https://taro-docs.jd.com/taro/docs/codebase-overview">Taro 仓库概览</a></p></blockquote><pre><code># yarn link
$ cd packages/taro-components
$ yarn link

# 本地编译
$ yarn dev
</code></pre><p>新建 Taro 项目用于调试 Taro 源码：</p><pre><code># 使用 npm 安装 CLI
$ npm install -g @tarojs/cli

# 初始化项目
$ taro init myApp

# yarn link
$ yarn link &quot;@tarojs/components&quot;
</code></pre><h3>5. 开始开发</h3><h4>5.1 功能开发</h4><p>通过以下步骤解决上述 <strong><a href="https://github.com/NervJS/taro/issues/8003">“textarea 组件 onLineChange 时间调用无效”</a></strong> issue：</p><blockquote><p>源码路径：packages/taro-components/src/components/textarea/textarea.tsx</p></blockquote><p>onLineChange 事件：</p><ul><li>新增 onLineChange 事件</li><li>监听输入事件，输入时通过行高计算行数</li><li>行数改变时触发 onLineChange</li></ul><p>auto-height 属性：</p><ul><li>新增 auto-height 属性</li><li>新增 auto-height 样式</li></ul><p>具体代码见：<a href="https://github.com/NervJS/taro/pull/10681/files">https://github.com/NervJS/taro/pull/10681/files</a></p><h4>5.2 更新测试用例</h4><p>在测试用例中添加对 onLineChange 事件、aotu-height 属性的测试。</p><blockquote><p>源码路径：packages/taro-components/<!-- -->_<!-- -->_<!-- -->tests<!-- -->_<!-- -->_<!-- -->/textarea.spec.js</p></blockquote><h4>5.3 更新文档</h4><p>在 README 中更新对 onLineChange、auto-height 的描述。</p><blockquote><p>源码地址：packages/taro-components/src/components/textarea/index.md</p></blockquote><h4>5.4 自测</h4><p>在本地测试项目 myApp 中，自测 onLineChange 事件、auto-height 属性功能是否正常，自测通过后，在 Taro 源码项目中跑自动化测试。</p><pre><code># 自动化测试
$ npm run test
</code></pre><h3>6. 提交 pull request</h3><p>测试通过后，在 github 中提交 pull requrst。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/711361ce7a3b4e8bb21920c717693e6e~tplv-k3u1fbpfcp-zoom-1.image" alt="s18260601222022"/></p><h3>7. code review 流程</h3><p>提交 pull request 后等待社区 code review，并及时跟进 code review 反馈进行修改。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ddab0a662824ad78e63b9ee2232d7c3~tplv-k3u1fbpfcp-zoom-1.image" alt="s09142901242022"/></p><h2>四、总结</h2><p>本文讲述了参与大型开源项目-Taro 的流程，其中以为 Taro 解决 issue 的视角，介绍了从认领 issue、解决 issue、贡献代码的完整过程。</p><p>在这个过程中，我们可以了解到如何参与开源项目并帮助开源项目解决问题，在开发工作中遇到开源项目的问题时，就可以愉快的参与进来了，不用因为一个小问题耽搁项目进度。</p><p>星星之火，可以燎原，在越来越多的开发者的参与下，开源社区的发展未来可期。</p><h2>参考资料</h2><ul><li><a href="https://juejin.cn/post/6844903918749614087">如何参与一个顶级开源项目</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[手写系列-实现一个铂金段位的 React]]></title>
            <link>https://jiaozitang.github.io/blog/2021/07/22/simple-react</link>
            <guid>/2021/07/22/simple-react</guid>
            <pubDate>Thu, 22 Jul 2021 19:11:14 GMT</pubDate>
            <description><![CDATA[为什么是铂金呢，因为和王者还有很远的距离。本文仅实现简单版本的 React，参考 React 16.8 的基本功能，包括虚拟 DOM、Fiber、Diff 算法、函数式组件、hooks 等。]]></description>
            <content:encoded><![CDATA[<p><img src="https://img12.360buyimg.com/ling/jfs/t1/190951/39/10504/64205/60d82ae2E380c664f/cbb7c4b34464cce7.png"/></p><blockquote><p>为什么是铂金呢，因为和王者还有很远的距离。本文仅实现简单版本的 React，参考 React 16.8 的基本功能，包括虚拟 DOM、Fiber、Diff 算法、函数式组件、hooks 等。</p></blockquote><h1>一、前言</h1><p>本文基于 <a href="https://pomb.us/build-your-own-react/">https://pomb.us/build-your-own-react/</a> 实现简单版 React。</p><p>本文学习思路来自 <a href="https://www.bilibili.com/video/BV1Ki4y1u7Vr?t=78z">卡颂-b站-React源码，你在第几层</a>。</p><p>模拟的版本为 React 16.8。</p><p>将实现以下功能：</p><ol><li><strong>createElement（虚拟 DOM）</strong>；</li><li><strong>render</strong>；</li><li><strong>可中断渲染</strong>；</li><li><strong>Fibers</strong>；</li><li><strong>Render and Commit Phases</strong> ；</li><li><strong>协调（Diff 算法）</strong>；</li><li><strong>函数组件</strong>；</li><li><strong>hooks</strong>；</li></ol><p>下面上正餐，请继续阅读。</p><h1>二、准备</h1><h2>1. React Demo</h2><p>先来看看一个简单的 React Demo，代码如下：</p><pre><code class="language-javascript">const element = &lt;div title=&quot;foo&quot;&gt;hello&lt;/div&gt;
const container = document.getElementById(&#x27;container&#x27;)
ReactDOM.render(element, container);
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo.html">reactDemo</a></p></blockquote><p>在浏览器中打开 reactDemo.html，展示如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e67cf968275e441db891b5530da0171e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><p>我们需要实现自己的 React，那么就需要知道上面的代码到底做了什么。</p><h3>1.1 element</h3><p><code>const element = &lt;div&gt;123&lt;/div&gt;</code> 实际上是 JSX 语法。</p><p><a href="https://zh-hans.reactjs.org/docs/glossary.html#jsx">React 官网</a> 对 JSX 的解释如下：</p><blockquote><p>JSX 是一个 JavaScript 语法扩展。它类似于模板语言，但它具有 JavaScript 的全部能力。JSX 最终会被 babel 编译为 React.createElement() 函数调用。</p></blockquote><p>通过 <a href="https://www.babeljs.cn/repl">babel 在线编译</a> <code>const element = &lt;div&gt;123&lt;/div&gt;</code> 。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/006372da0fb7468e9155bc8d69448b48~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><p>可知 <code>const element = &lt;div&gt;123&lt;/div&gt;</code> 经过编译后的实际代码如下：</p><pre><code class="language-javascript">const element = React.createElement(&quot;div&quot;, {
  title: &quot;foo&quot;
}, &quot;hello&quot;);
</code></pre><p>再来看看上文的 React.createElement 实际生成了一个怎么样的对象。</p><p>在 demo 中打印试试：</p><pre><code class="language-javascript">const element = &lt;div title=&quot;foo&quot;&gt;hello&lt;/div&gt;
console.log(element)
const container = document.getElementById(&#x27;container&#x27;)
ReactDOM.render(element, container);
</code></pre><p>可以看到输出的 element 如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b0e14c7e8734456891b2264cd160476~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><p>简化一下 element：</p><pre><code class="language-javascript">const element = {
    type: &#x27;div&#x27;,
    props: {
        title: &#x27;foo&#x27;,
        children: &#x27;hello&#x27;
    }
}
</code></pre><p>简单总结一下，<code>React.createElement</code> 实际上是生成了一个 element 对象，该对象拥有以下属性：</p><ul><li>type: 标签名</li><li>props<ul><li>title: 标签属性</li><li>children: 子节点</li></ul></li></ul><h3>1.2 render</h3><p><code>ReactDOM.render()</code> 将 element 添加到 id 为 container 的 DOM 节点中，下面我们将简单手写一个方法代替 <code>ReactDOM.render()</code>。</p><ol><li>创建标签名为 element.type 的节点；</li></ol><pre><code class="language-javascript">const node = document.createElement(element.type)
</code></pre><ol start="2"><li>设置 node 节点的 title 为 element.props.title；</li></ol><pre><code class="language-javascript">node[&quot;title&quot;] = element.props.title
</code></pre><ol start="3"><li>创建一个空的文本节点 text；</li></ol><pre><code class="language-javascript">const text = document.createTextNode(&quot;&quot;)
</code></pre><ol start="4"><li>设置文本节点的 nodeValue 为 element.props.children；</li></ol><pre><code class="language-javascript">text[&quot;nodeValue&quot;] = element.props.children
</code></pre><ol start="5"><li>将文本节点 text 添加进 node 节点；</li></ol><pre><code class="language-javascript">node.appendChild(text)
</code></pre><ol start="6"><li>将 node 节点添加进 container 节点</li></ol><pre><code class="language-javascript">container.appendChild(node)
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo2.html">reactDemo2</a></p></blockquote><p>运行源码，结果如下，和引入 React 的结果一致：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8033485bbe0a46e6b8f32c5f69315429~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><h1>三、开始</h1><p>上文通过模拟 React，简单代替了 React.createElement、ReactDOM.render 方法，接下来将真正开始实现 React 的各个功能。</p><h2>1. createElement（虚拟 DOM）</h2><p>上面有了解到 createElement 的作用是创建一个 element 对象，结构如下：</p><pre><code class="language-javascript">// 虚拟 DOM 结构
const element = {
    type: &#x27;div&#x27;, // 标签名
    props: { // 节点属性，包含 children
        title: &#x27;foo&#x27;, // title 属性
        children: &#x27;hello&#x27; // 子节点，注：实际上这里应该是数组结构，帮助我们存储更多子节点
    }
}
</code></pre><p>根据 element 的结构，设计了 createElement 函数，代码如下：</p><pre><code class="language-javascript">/**
 * 创建虚拟 DOM 结构
 * @param {type} 标签名
 * @param {props} 属性对象
 * @param {children} 子节点
 * @return {element} 虚拟 DOM
 */
function createElement (type, props, ...children) {
    return {
        type,
        props: {
            ...props,
            children: children.map(child =&gt; 
                typeof child === &#x27;object&#x27;
                ? child
                : createTextElement(child)
            )
        }
    }
}
</code></pre><p>这里有考虑到，当 children 是非对象时，应该创建一个 textElement 元素， 代码如下：</p><pre><code class="language-javascript">/**
 * 创建文本节点
 * @param {text} 文本值
 * @return {element} 虚拟 DOM
 */
function createTextElement (text) {
    return {
        type: &quot;TEXT_ELEMENT&quot;,
        props: {
            nodeValue: text,
            children: []
        }
    }
}
</code></pre><p>接下来试一下，代码如下：</p><pre><code class="language-javascript">const myReact = {
    createElement
}
const element = myReact.createElement(
  &quot;div&quot;,
  { id: &quot;foo&quot; },
  myReact.createElement(&quot;a&quot;, null, &quot;bar&quot;),
  myReact.createElement(&quot;b&quot;)
)
console.log(element)
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo3.html">reactDemo3</a></p></blockquote><p>得到的 element 对象如下：</p><pre><code class="language-javascript">const element = {
    &quot;type&quot;: &quot;div&quot;, 
    &quot;props&quot;: {
        &quot;id&quot;: &quot;foo&quot;, 
        &quot;children&quot;: [
            {
                &quot;type&quot;: &quot;a&quot;, 
                &quot;props&quot;: {
                    &quot;children&quot;: [
                        {
                            &quot;type&quot;: &quot;TEXT_ELEMENT&quot;, 
                            &quot;props&quot;: {
                                &quot;nodeValue&quot;: &quot;bar&quot;, 
                                &quot;children&quot;: [ ]
                            }
                        }
                    ]
                }
            }, 
            {
                &quot;type&quot;: &quot;b&quot;, 
                &quot;props&quot;: {
                    &quot;children&quot;: [ ]
                }
            }
        ]
    }
}
</code></pre><p><strong>JSX</strong></p><p>实际上我们在使用 react 开发的过程中，并不会这样创建组件：</p><pre><code class="language-javascript">const element = myReact.createElement(
  &quot;div&quot;,
  { id: &quot;foo&quot; },
  myReact.createElement(&quot;a&quot;, null, &quot;bar&quot;),
  myReact.createElement(&quot;b&quot;)
)
</code></pre><p>而是通过 JSX 语法，代码如下：</p><pre><code class="language-javascript">const element = (
    &lt;div id=&#x27;foo&#x27;&gt;
        &lt;a&gt;bar&lt;/a&gt;
        &lt;b&gt;&lt;/b&gt;
    &lt;/div&gt;
)
</code></pre><p>在 myReact 中，可以通过添加注释的形式，告诉 babel 转译我们指定的函数，来使用 JSX 语法，代码如下：</p><pre><code class="language-javascript">/** @jsx myReact.createElement */
const element = (
    &lt;div id=&#x27;foo&#x27;&gt;
        &lt;a&gt;bar&lt;/a&gt;
        &lt;b&gt;&lt;/b&gt;
    &lt;/div&gt;
)
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo4.html">reactDemo4</a></p></blockquote><h2>2. render</h2><p>render 函数帮助我们将 element 添加至真实节点中。</p><p>将分为以下步骤实现：</p><ol><li>创建 element.type 类型的 dom 节点，并添加至容器中；</li></ol><pre><code class="language-javascript">/**
 * 将虚拟 DOM 添加至真实 DOM
 * @param {element} 虚拟 DOM
 * @param {container} 真实 DOM
 */
function render (element, container) {
    const dom = document.createElement(element.type)
    container.appendChild(dom)
}
</code></pre><ol start="2"><li>将 element.children 都添加至 dom 节点中；</li></ol><pre><code class="language-javascript">element.props.children.forEach(child =&gt; 
    render(child, dom)
)
</code></pre><ol start="3"><li>对文本节点进行特殊处理；</li></ol><pre><code class="language-javascript">const dom = element.type === &#x27;TEXT_ELEMENT&#x27;
    ? document.createTextNode(&quot;&quot;)
    : document.createElement(element.type)
</code></pre><ol start="4"><li>将 element 的 props 属性添加至 dom；</li></ol><pre><code class="language-javascript">const isProperty = key =&gt; key !== &quot;children&quot;
Object.keys(element.props)
    .filter(isProperty)
    .forEach(name =&gt; {
      dom[name] = element.props[name]
})
</code></pre><p>以上我们实现了将 JSX 渲染到真实 DOM 的功能，接下来试一下，代码如下：</p><pre><code class="language-javascript">const myReact = {
    createElement,
    render
}
/** @jsx myReact.createElement */
const element = (
    &lt;div id=&#x27;foo&#x27;&gt;
        &lt;a&gt;bar&lt;/a&gt;
        &lt;b&gt;&lt;/b&gt;
    &lt;/div&gt;
)

myReact.render(element, document.getElementById(&#x27;container&#x27;))
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo5.html">reactDemo5</a></p></blockquote><p>结果如图，成功输出：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe4fe623e02e41d2bd81957c0019f12b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><h2>3. 可中断渲染（requestIdleCallback）</h2><p>再来看看上面写的 render 方法中关于子节点的处理，代码如下：</p><pre><code class="language-javascript">/**
 * 将虚拟 DOM 添加至真实 DOM
 * @param {element} 虚拟 DOM
 * @param {container} 真实 DOM
 */
function render (element, container) {
    // 省略
    // 遍历所有子节点，并进行渲染
    element.props.children.forEach(child =&gt;
        render(child, dom)
    )
    // 省略
}
</code></pre><p>这个递归调用是有问题的，一旦开始渲染，就会将所有节点及其子节点全部渲染完成这个进程才会结束。</p><p>当 dom tree 很大的情况下，在渲染过程中，页面上是卡住的状态，无法进行用户输入等交互操作。</p><p>可分为以下步骤解决上述问题：</p><ol><li>允许中断渲染工作，如果有优先级更高的工作插入，则暂时中断浏览器渲染，待完成该工作后，恢复浏览器渲染；</li><li>将渲染工作进行分解，分解成一个个小单元；</li></ol><p>使用 requestIdleCallback 来解决允许中断渲染工作的问题。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">window.requestIdleCallback</a> 将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。</p><blockquote><p>window.requestIdleCallback 详细介绍可查看文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">文档</a></p></blockquote><p>代码如下：</p><pre><code class="language-javascript">// 下一个工作单元
let nextUnitOfWork = null
/**
 * workLoop 工作循环函数
 * @param {deadline} 截止时间
 */
function workLoop(deadline) {
  // 是否应该停止工作循环函数
  let shouldYield = false
  
  // 如果存在下一个工作单元，且没有优先级更高的其他工作时，循环执行
  while (nextUnitOfWork &amp;&amp; !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    
    // 如果截止时间快到了，停止工作循环函数
    shouldYield = deadline.timeRemaining() &lt; 1
  }
  
  // 通知浏览器，空闲时间应该执行 workLoop
  requestIdleCallback(workLoop)
}
// 通知浏览器，空闲时间应该执行 workLoop
requestIdleCallback(workLoop)

// 执行单元事件，并返回下一个单元事件
function performUnitOfWork(nextUnitOfWork) {
  // TODO
}
</code></pre><p>performUnitOfWork 是用来执行单元事件，并返回下一个单元事件的，具体实现将在下文介绍。</p><h2>4. Fiber</h2><p>上文介绍了通过 requestIdleCallback 让浏览器在空闲时间渲染工作单元，避免渲染过久导致页面卡顿的问题。</p><blockquote><p>注：实际上 requestIdleCallback 功能并不稳定，不建议用于生产环境，本例仅用于模拟 React 的思路，React 本身并不是通过 requestIdleCallback 来实现让浏览器在空闲时间渲染工作单元的。</p></blockquote><p>另一方面，为了让渲染工作可以分离成一个个小单元，React 设计了 fiber。</p><p>每一个 element 都是一个 fiber 结构，每一个 fiber 都是一个渲染工作单元。</p><p>所以 <strong>fiber 既是一种数据结构，也是一个工作单元</strong>。</p><p>下文将通过简单的示例对 fiber 进行介绍。</p><p>假设需要渲染这样一个 element 树：</p><pre><code class="language-javascript">myReact.render(
  &lt;div&gt;
    &lt;h1&gt;
      &lt;p /&gt;
      &lt;a /&gt;
    &lt;/h1&gt;
    &lt;h2 /&gt;
  &lt;/div&gt;,
  container
)
</code></pre><p>生成的 fiber tree 如图：</p><p>橙色代表子节点，黄色代表父节点，蓝色代表兄弟节点。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a92a6b184ca4456aab76a73cff2ca4a3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><p>每个 fiber 都有一个链接指向它的第一个子节点、下一个兄弟节点和它的父节点。这种数据结构可以让我们更方便的查找下一个工作单元。</p><p>上图的箭头也表明了 fiber 的渲染过程，渲染过程详细描述如下：</p><ol><li>从 root 开始，找到第一个子节点 div；</li><li>找到 div 的第一个子节点 h1；</li><li>找到 h1 的第一个子节点 p；</li><li>找 p 的第一个子节点，<strong>如无子节点，则找下一个兄弟节点</strong>，找到 p 的兄弟节点 a；</li><li>找 a 的第一个子节点，<strong>如无子节点，也无兄弟节点，则找它的父节点的下一个兄弟节点</strong>，找到 a 的 父节点的兄弟节点 h2；</li><li>找 h2 的第一个子节点，找不到，找兄弟节点，找不到，找父节点 div 的兄弟节点，也找不到，继续找 div 的父节点的兄弟节点，找到 root；</li><li>第 6 步已经找到了 root 节点，渲染已全部完成。</li></ol><p>下面将渲染过程用代码实现。</p><ol><li>将 render 中创建 DOM 节点的部分抽离为 creactDOM 函数；</li></ol><pre><code class="language-javascript">/**
 * createDom 创建 DOM 节点
 * @param {fiber} fiber 节点
 * @return {dom} dom 节点
 */
function createDom (fiber) {
    // 如果是文本类型，创建空的文本节点，如果不是文本类型，按 type 类型创建节点
    const dom = fiber.type === &#x27;TEXT_ELEMENT&#x27;
        ? document.createTextNode(&quot;&quot;)
        : document.createElement(fiber.type)

    // isProperty 表示不是 children 的属性
    const isProperty = key =&gt; key !== &quot;children&quot;
    
    // 遍历 props，为 dom 添加属性
    Object.keys(fiber.props)
        .filter(isProperty)
        .forEach(name =&gt; {
            dom[name] = fiber.props[name]
        })
        
    // 返回 dom
    return dom
}
</code></pre><ol start="2"><li>在 render 中设置第一个工作单元为 fiber 根节点；</li></ol><p>fiber 根节点仅包含 children 属性，值为参数 fiber。</p><pre><code class="language-javascript">// 下一个工作单元
let nextUnitOfWork = null
/**
 * 将 fiber 添加至真实 DOM
 * @param {element} fiber
 * @param {container} 真实 DOM
 */
function render (element, container) {
    nextUnitOfWork = {
        dom: container,
        props: {
            children: [element]
        }
    }
}
</code></pre><ol start="3"><li>通过 requestIdleCallback 在浏览器空闲时，渲染 fiber；</li></ol><pre><code class="language-javascript">/**
 * workLoop 工作循环函数
 * @param {deadline} 截止时间
 */
function workLoop(deadline) {
  // 是否应该停止工作循环函数
  let shouldYield = false
  
  // 如果存在下一个工作单元，且没有优先级更高的其他工作时，循环执行
  while (nextUnitOfWork &amp;&amp; !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    
    // 如果截止时间快到了，停止工作循环函数
    shouldYield = deadline.timeRemaining() &lt; 1
  }
  
  // 通知浏览器，空闲时间应该执行 workLoop
  requestIdleCallback(workLoop)
}
// 通知浏览器，空闲时间应该执行 workLoop
requestIdleCallback(workLoop)
</code></pre><ol start="4"><li>渲染 fiber 的函数 performUnitOfWork；</li></ol><pre><code class="language-javascript">/**
 * performUnitOfWork 处理工作单元
 * @param {fiber} fiber
 * @return {nextUnitOfWork} 下一个工作单元
 */
function performUnitOfWork(fiber) {
  // TODO 添加 dom 节点
  // TODO 新建 filber
  // TODO 返回下一个工作单元（fiber）
}
</code></pre><p>4.1 添加 dom 节点</p><pre><code class="language-javascript">function performUnitOfWork(fiber) {
    // 如果 fiber 没有 dom 节点，为它创建一个 dom 节点
    if (!fiber.dom) {
        fiber.dom = createDom(fiber)
    }

    // 如果 fiber 有父节点，将 fiber.dom 添加至父节点
    if (fiber.parent) {
        fiber.parent.dom.appendChild(fiber.dom)
    }
}
</code></pre><p>4.2 新建 filber</p><pre><code class="language-javascript">function performUnitOfWork(fiber) {
    // ～～省略～～
    // 子节点
    const elements = fiber.props.children
    // 索引
    let index = 0
    // 上一个兄弟节点
    let prevSibling = null
    // 遍历子节点
    while (index &lt; elements.length) {
        const element = elements[index]

        // 创建 fiber
        const newFiber = {
            type: element.type,
            props: element.props,
            parent: fiber,
            dom: null,
        }

        // 将第一个子节点设置为 fiber 的子节点
        if (index === 0) {
            fiber.child = newFiber
        } else if (element) {
        // 第一个之外的子节点设置为该节点的兄弟节点
            prevSibling.sibling = newFiber
        }

        prevSibling = newFiber
        index++
    }
}
</code></pre><p>4.3 返回下一个工作单元（fiber）</p><pre><code class="language-javascript">
function performUnitOfWork(fiber) {
    // ～～省略～～
    // 如果有子节点，返回子节点
    if (fiber.child) {
        return fiber.child
    }
    let nextFiber = fiber
    while (nextFiber) {
        // 如果有兄弟节点，返回兄弟节点
        if (nextFiber.sibling) {
            return nextFiber.sibling
        }

        // 否则继续走 while 循环，直到找到 root。
        nextFiber = nextFiber.parent
    }
}
</code></pre><p>以上我们实现了将 fiber 渲染到页面的功能，且渲染过程是可中断的。</p><p>现在试一下，代码如下：</p><pre><code class="language-javascript">const element = (
    &lt;div&gt;
        &lt;h1&gt;
        &lt;p /&gt;
        &lt;a /&gt;
        &lt;/h1&gt;
        &lt;h2 /&gt;
    &lt;/div&gt;
)

myReact.render(element, document.getElementById(&#x27;container&#x27;))
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo7.html">reactDemo7</a></p></blockquote><p>如预期输出 dom，如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18c3cea8e3b042ebbf2f10eaffd9a18b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><h2>5. 渲染提交阶段</h2><p>由于渲染过程被我们做了可中断的，那么中断的时候，我们肯定不希望浏览器给用户展示的是渲染了一半的 UI。</p><p>对渲染提交阶段优化的处理如下：</p><ol><li>把 performUnitOfWork 中关于把子节点添加至父节点的逻辑删除；</li></ol><pre><code class="language-javascript">function performUnitOfWork(fiber) {
    // 把这段删了
    if (fiber.parent) {
       fiber.parent.dom.appendChild(fiber.dom)
    }
}
</code></pre><ol start="2"><li>新增一个根节点变量，存储 fiber 根节点；</li></ol><pre><code class="language-javascript">// 根节点
let wipRoot = null
function render (element, container) {
    wipRoot = {
        dom: container,
        props: {
            children: [element]
        }
    }
    // 下一个工作单元是根节点
    nextUnitOfWork = wipRoot
}
</code></pre><ol start="3"><li>当所有 fiber 都工作完成时，nextUnitOfWork 为 undefined，这时再渲染真实 DOM；</li></ol><pre><code class="language-javascript">function workLoop (deadline) {
    // 省略
    if (!nextUnitOfWork &amp;&amp; wipRoot) {
        commitRoot()
    }
    // 省略
}
</code></pre><ol start="4"><li>新增 commitRoot 函数，执行渲染真实 DOM 操作，递归将 fiber tree 渲染为真实 DOM；</li></ol><pre><code class="language-javascript">// 全部工作单元完成后，将 fiber tree 渲染为真实 DOM；
function commitRoot () {
    commitWork(wipRoot.child)
    // 需要设置为 null，否则 workLoop 在浏览器空闲时不断的执行。
    wipRoot = null
}
/**
 * performUnitOfWork 处理工作单元
 * @param {fiber} fiber
 */
function commitWork (fiber) {
    if (!fiber) return
    const domParent = fiber.parent.dom
    domParent.appendChild(fiber.dom)
    // 渲染子节点
    commitWork(fiber.child)
    // 渲染兄弟节点
    commitWork(fiber.sibling)
}
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo8.html">reactDemo8</a></p></blockquote><p>源码运行结果如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cccbab6b83a24ca3a9c45470ff9b37a0~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><h2>6. 协调（diff 算法）</h2><p>当 element 有更新时，需要将更新前的 fiber tree 和更新后的 fiber tree 进行比较，得到比较结果后，仅对有变化的 fiber 对应的 dom 节点进行更新。</p><p>通过协调，减少对真实 DOM 的操作次数。</p><h3>1. currentRoot</h3><p>新增 currentRoot 变量，保存根节点更新前的 fiber tree，为 fiber 新增 alternate 属性，保存 fiber 更新前的 fiber tree；</p><pre><code class="language-javascript">let currentRoot = null
function render (element, container) {
    wipRoot = {
        // 省略
        alternate: currentRoot
    }
}
function commitRoot () {
    commitWork(wipRoot.child)
    currentRoot = wipRoot
    wipRoot = null
}
</code></pre><h3>2. performUnitOfWork</h3><p>将 performUnitOfWork 中关于新建 fiber 的逻辑，抽离到 reconcileChildren 函数；</p><pre><code class="language-javascript">/**
 * 协调子节点
 * @param {fiber} fiber
 * @param {elements} fiber 的 子节点
 */
function reconcileChildren (fiber, elements) {
    // 用于统计子节点的索引值
    let index = 0
    // 上一个兄弟节点
    let prevSibling = null

    // 遍历子节点
    while (index &lt; elements.length) {
        const element = elements[index]

        // 新建 fiber
        const newFiber = {
            type: element.type,
            props: element.props,
            parent: fiber,
            dom: null,
        }

        // fiber的第一个子节点是它的子节点
        if (index === 0) {
            fiber.child = newFiber
        } else if (element) {
        // fiber 的其他子节点，是它第一个子节点的兄弟节点
            prevSibling.sibling = newFiber
        }

        // 把新建的 newFiber 赋值给 prevSibling，这样就方便为 newFiber 添加兄弟节点了
        prevSibling = newFiber
        
        // 索引值 + 1
        index++
    }
}
</code></pre><h3>3. reconcileChildren</h3><p>在 reconcileChildren 中对比新旧 fiber；</p><h4>3.1 当新旧 fiber 类型相同时</h4><p>保留 dom，仅更新 props，设置 effectTag 为 UPDATE；</p><pre><code class="language-javascript">function reconcileChildren (wipFiber, elements) {
    // ～～省略～～
    // oldFiber 可以在 wipFiber.alternate 中找到
    let oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child

    while (index &lt; elements.length || oldFiber != null) {
        const element = elements[index]
        let newFiber = null

        // fiber 类型是否相同
        const sameType =
            oldFiber &amp;&amp;
            element &amp;&amp;
            element.type == oldFiber.type

        // 如果类型相同，仅更新 props
        if (sameType) {
            newFiber = {
                type: oldFiber.type,
                props: element.props,
                dom: oldFiber.dom,
                parent: wipFiber,
                alternate: oldFiber,
                effectTag: &quot;UPDATE&quot;,
            }
        }
        // ～～省略～～
    }
    // ～～省略～～
}
</code></pre><h4>3.2 当新旧 fiber 类型不同，且有新元素时</h4><p>创建一个新的 dom 节点，设置 effectTag 为 PLACEMENT；</p><pre><code class="language-javascript">function reconcileChildren (wipFiber, elements) {
    // ～～省略～～
    if (element &amp;&amp; !sameType) {
        newFiber = {
            type: element.type,
            props: element.props,
            dom: null,
            parent: wipFiber,
            alternate: null,
            effectTag: &quot;PLACEMENT&quot;,
        }
    }
    // ～～省略～～
}
</code></pre><h4>3.3 当新旧 fiber 类型不同，且有旧 fiber 时</h4><p>删除旧 fiber，设置 effectTag 为 DELETION；</p><pre><code class="language-javascript">function reconcileChildren (wipFiber, elements) {
    // ～～省略～～
    if (oldFiber &amp;&amp; !sameType) {
        oldFiber.effectTag = &quot;DELETION&quot;
        deletions.push(oldFiber)
    }
    // ～～省略～～
}
</code></pre><h3>4. deletions</h3><p>新建 deletions 数组存储需删除的 fiber 节点，渲染 DOM 时，遍历 deletions 删除旧 fiber；</p><pre><code class="language-javascript">let deletions = null
function render (element, container) {
    // 省略
    // render 时，初始化 deletions 数组
    deletions = []
}

// 渲染 DOM 时，遍历 deletions 删除旧 fiber
function commitRoot () {
    deletions.forEach(commitWork)
}
</code></pre><h3>5. commitWork</h3><p>在 commitWork 中对 fiber 的 effectTag 进行判断，并分别处理。</p><h4>5.1 PLACEMENT</h4><p>当 fiber 的 effectTag 为 PLACEMENT 时，表示是新增 fiber，将该节点新增至父节点中。</p><pre><code class="language-javascript">if (
    fiber.effectTag === &quot;PLACEMENT&quot; &amp;&amp;
    fiber.dom != null
) {
    domParent.appendChild(fiber.dom)
}
</code></pre><h4>5.2 DELETION</h4><p>当 fiber 的 effectTag 为 DELETION 时，表示是删除 fiber，将父节点的该节点删除。</p><pre><code class="language-javascript">else if (fiber.effectTag === &quot;DELETION&quot;) {
    domParent.removeChild(fiber.dom)
}
</code></pre><h4>5.3 UPDATE</h4><p>当 fiber 的 effectTag 为 UPDATE 时，表示是更新 fiber，更新 props 属性。</p><pre><code class="language-javascript">else if (fiber.effectTag === &#x27;UPDATE&#x27; &amp;&amp; fiber.dom != null) {
    updateDom(fiber.dom, fiber.alternate.props, fiber.props)
}
</code></pre><p>updateDom 函数根据不同的更新类型，对 props 属性进行更新。</p><pre><code class="language-javascript">const isProperty = key =&gt; key !== &quot;children&quot;

// 是否是新属性
const isNew = (prev, next) =&gt; key =&gt; prev[key] !== next[key]

// 是否是旧属性
const isGone = (prev, next) =&gt; key =&gt; !(key in next)

function updateDom(dom, prevProps, nextProps) {
    // 删除旧属性
    Object.keys(prevProps)
        .filter(isProperty)
        .filter(isGone(prevProps, nextProps))
        .forEach(name =&gt; {
            dom[name] = &quot;&quot;
        })

    // 更新新属性
    Object.keys(nextProps)
        .filter(isProperty)
        .filter(isNew(prevProps, nextProps))
        .forEach(name =&gt; {
            dom[name] = nextProps[name]
        })
}
</code></pre><p>另外，为 updateDom 添加事件属性的更新、删除，便于追踪 fiber 事件的更新。</p><pre><code class="language-javascript">function updateDom(dom, prevProps, nextProps) {
    // ～～省略～～
    const isEvent = key =&gt; key.startsWith(&quot;on&quot;)
    //删除旧的或者有变化的事件
    Object.keys(prevProps)
        .filter(isEvent)
        .filter(
          key =&gt;
            !(key in nextProps) ||
            isNew(prevProps, nextProps)(key)
        )
        .forEach(name =&gt; {
          const eventType = name
            .toLowerCase()
            .substring(2)
          dom.removeEventListener(
            eventType,
            prevProps[name]
          )
        })

    // 注册新事件
    Object.keys(nextProps)
        .filter(isEvent)
        .filter(isNew(prevProps, nextProps))
        .forEach(name =&gt; {
        const eventType = name
            .toLowerCase()
            .substring(2)
        dom.addEventListener(
            eventType,
            nextProps[name]
        )
    })
    // ～～省略～～
}
</code></pre><p>替换 creactDOM 中设置 props 的逻辑。</p><pre><code class="language-javascript">function createDom (fiber) {
    const dom = fiber.type === &#x27;TEXT_ELEMENT&#x27;
        ? document.createTextNode(&quot;&quot;)
        : document.createElement(fiber.type)
    // 看这里鸭
    updateDom(dom, {}, fiber.props)
    return dom
}
</code></pre><p>新建一个包含输入表单项的例子，尝试更新 element，代码如下：</p><pre><code class="language-javascript">/** @jsx myReact.createElement */
const container = document.getElementById(&quot;container&quot;)

const updateValue = e =&gt; {
    rerender(e.target.value)
}

const rerender = value =&gt; {
    const element = (
        &lt;div&gt;
            &lt;input onInput={updateValue} value={value} /&gt;
            &lt;h2&gt;Hello {value}&lt;/h2&gt;
        &lt;/div&gt;
    )
    myReact.render(element, container)
}

rerender(&quot;World&quot;)
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo9.html">reactDemo9</a></p></blockquote><p>输出结果如图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e615196850b244c3930771375d93ba3c~tplv-k3u1fbpfcp-watermark.image" alt="12.gif"/></p><h2>7. 函数式组件</h2><p>先来看一个简单的函数式组件示例：</p><blockquote><p>myReact 还不支持函数式组件，下面代码运行会报错，这里仅用于比照函数式组件的常规使用方式。</p></blockquote><pre><code class="language-javascript">/** @jsx myReact.createElement */
const container = document.getElementById(&quot;container&quot;)

function App (props) {
    return (
        &lt;h1&gt;hi~ {props.name}&lt;/h1&gt;
    )
}

const element = (
    &lt;App name=&#x27;foo&#x27; /&gt;
)

myReact.render(element, container)
</code></pre><p>函数式组件和 html 标签组件相比，有以下两点不同：</p><ul><li>函数组件的 fiber 没有 dom 节点；</li><li>函数组件的 children 需要运行函数后得到；</li></ul><p>通过下列步骤实现函数组件：</p><ol><li>修改 performUnitOfWork，根据 fiber 类型，执行 fiber 工作单元；</li></ol><pre><code class="language-javascript">function performUnitOfWork(fiber) {
    // 是否是函数类型组件
    const isFunctionComponent = fiber &amp;&amp; fiber.type &amp;&amp; fiber.type instanceof Function
    // 如果是函数组件，执行 updateFunctionComponent 函数
    if (isFunctionComponent) {
        updateFunctionComponent(fiber)
    } else {
    // 如果不是函数组件，执行 updateHostComponent 函数
        updateHostComponent(fiber)
    }
    // 省略
}
</code></pre><ol start="2"><li>定义 updateHostComponent 函数，执行非函数组件；</li></ol><p>非函数式组件可直接将 fiber.props.children 作为参数传递。</p><pre><code class="language-javascript">function updateHostComponent(fiber) {
    if (!fiber.dom) {
        fiber.dom = createDom(fiber)
    }
    reconcileChildren(fiber, fiber.props.children)
}
</code></pre><ol start="3"><li>定义 updateFunctionComponent 函数，执行函数组件；</li></ol><p>函数组件需要运行来获得 fiber.children。</p><pre><code class="language-javascript">function updateFunctionComponent(fiber) {
    // fiber.type 就是函数组件本身，fiber.props 就是函数组件的参数
    const children = [fiber.type(fiber.props)]
    reconcileChildren(fiber, children)
}
</code></pre><ol start="4"><li>修改 commitWork 函数，兼容没有 dom 节点的 fiber；</li></ol><p>4.1 修改 domParent 的获取逻辑，通过 while 循环不断向上寻找，直到找到有 dom 节点的父 fiber；</p><pre><code class="language-javascript">function commitWork (fiber) {
    // 省略
    let domParentFiber = fiber.parent
    // 如果 fiber.parent 没有 dom 节点，则继续找 fiber.parent.parent.dom，直到有 dom 节点。
    while (!domParentFiber.dom) {
        domParentFiber = domParentFiber.parent
    }
    const domParent = domParentFiber.dom
    // 省略
}
</code></pre><p>4.2 修改删除节点的逻辑，当删除节点时，需要不断向下寻找，直到找到有 dom 节点的子 fiber；</p><pre><code class="language-javascript">function commitWork (fiber) {
    // 省略
    // 如果 fiber 的更新类型是删除，执行 commitDeletion
     else if (fiber.effectTag === &quot;DELETION&quot;) {
        commitDeletion(fiber.dom, domParent)
    }
    // 省略
}

// 删除节点
function commitDeletion (fiber, domParent) {
    // 如果该 fiber 有 dom 节点，直接删除
    if (fiber.dom) {
        domParent.removeChild(fiber.dom)
    } else {
    // 如果该 fiber 没有 dom 节点，则继续找它的子节点进行删除
        commitDeletion(fiber.child, domParent)
    }
}
</code></pre><p>下面试一下上面的例子，代码如下：</p><pre><code class="language-javascript">/** @jsx myReact.createElement */
const container = document.getElementById(&quot;container&quot;)

function App (props) {
    return (
        &lt;h1&gt;hi~ {props.name}&lt;/h1&gt;
    )
}

const element = (
    &lt;App name=&#x27;foo&#x27; /&gt;
)

myReact.render(element, container)
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo10.html">reactDemo10</a></p></blockquote><p>运行结果如图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a920eb5c41974c15b2db269dc95cb7f9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><h2>8. hooks</h2><p>下面继续为 myReact 添加管理状态的功能，期望是函数组件拥有自己的状态，且可以获取、更新状态。</p><p>一个拥有计数功能的函数组件如下：</p><pre><code class="language-javascript">function Counter() {
    const [state, setState] = myReact.useState(1)
    return (
        &lt;h1 onClick={() =&gt; setState(c =&gt; c + 1)}&gt;
        Count: {state}
        &lt;/h1&gt;
    )
}
const element = &lt;Counter /&gt;
</code></pre><p>已知需要一个 useState 方法用来获取、更新状态。</p><p>这里再重申一下，<strong>渲染函数组件的前提是，执行该函数组件</strong>，因此，上述 Counter 想要更新计数，就会在每次更新都执行一次 Counter 函数。</p><p>通过以下步骤实现：</p><ol><li>新增全局变量 wipFiber；</li></ol><pre><code class="language-javascript">// 当前工作单元 fiber
let wipFiber = null
function updateFunctionComponent(fiber) {
    wipFiber = fiber
    // 当前工作单元 fiber 的 hook
    wipFiber.hook = []
    // 省略
}
</code></pre><ol start="2"><li>新增 useState 函数；</li></ol><pre><code class="language-javascript">// initial 表示初始参数，在本例中，initial=1
function useState (initial) {
    // 是否有旧钩子，旧钩子存储了上一次更新的 hook
    const oldHook =
        wipFiber.alternate &amp;&amp;
        wipFiber.alternate.hook

    // 初始化钩子，钩子的状态是旧钩子的状态或者初始状态
    const hook = {
        state: oldHook ? oldHook.state : initial,
        queue: [],
    }

    // 从旧的钩子队列中获取所有动作，然后将它们一一应用到新的钩子状态
    const actions = oldHook ? oldHook.queue : []
    actions.forEach(action =&gt; {
        hook.state = action(hook.state)
    })

    // 设置钩子状态
    const setState = action =&gt; {
        // 将动作添加至钩子队列
        hook.queue.push(action)
        // 更新渲染
        wipRoot = {
            dom: currentRoot.dom,
            props: currentRoot.props,
            alternate: currentRoot,
        }
        nextUnitOfWork = wipRoot
        deletions = []
    }

    // 把钩子添加至工作单元
    wipFiber.hook = hook
    
    // 返回钩子的状态和设置钩子的函数
    return [hook.state, setState]
}
</code></pre><p>下面运行一下计数组件，代码如下：</p><pre><code class="language-javascript">function Counter() {
    const [state, setState] = myReact.useState(1)
    return (
        &lt;h1 onClick={() =&gt; setState(c =&gt; c + 1)}&gt;
        Count: {state}
        &lt;/h1&gt;
    )
}
const element = &lt;Counter /&gt;
</code></pre><blockquote><p>本例完整源码见：<a href="https://github.com/jiaozitang/web-learn-note/blob/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/React/reactDemo11.html">reactDemo11</a></p></blockquote><p>运行结果如图：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2940b3bb0bb34940891cc1903067b2b3~tplv-k3u1fbpfcp-watermark.image" alt="123.gif"/></p><p>本章节简单实现了 myReact 的 hooks 功能。</p><p>撒花完结，react 还有很多实现值得我们去学习和研究，希望有下期，和大家一起手写 react 的更多功能。</p><h1>总结</h1><p>本文参考 <a href="https://pomb.us/build-your-own-react/">pomb.us</a> 进行学习，实现了包括虚拟 DOM、Fiber、Diff 算法、函数式组件、hooks 等功能的自定义 React。</p><p>在实现过程中小编对 React 的基本术语及实现思路有了大概的掌握，<a href="https://pomb.us/build-your-own-react/">pomb.us</a> 是非常适合初学者的学习资料，可以直接通过 <a href="https://pomb.us/build-your-own-react/">pomb.us</a> 进行学习，也推荐跟着本文一步步实现 React 的常见功能。</p><p>本文源码： <a href="https://github.com/jiaozitang/web-learn-note/tree/main/src/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/Promise">github源码</a> 。</p><p>建议跟着一步步敲，进行实操练习。</p><p>希望能对你有所帮助，感谢阅读～</p><p>别忘了点个赞鼓励一下我哦，笔芯❤️</p><h1>参考资料</h1><ul><li><p><a href="https://pomb.us/build-your-own-react/">https://pomb.us/build-your-own-react/</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1Ki4y1u7Vr?t=78z">卡颂-b站-React源码，你在第几层</a> </p></li><li><p><a href="https://jelly.jd.com/article/60aceb6b27393b0169c85231">手写一个简单的 React</a></p></li></ul>]]></content:encoded>
        </item>
    </channel>
</rss>
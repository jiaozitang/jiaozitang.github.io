<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><title data-react-helmet="true">offer收割机之前端工程化篇 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jiaozitang.github.io/docs/收割机/offer收割机之前端工程化篇"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="offer收割机之前端工程化篇 | My Site"><meta data-react-helmet="true" name="description" content="一、Git"><meta data-react-helmet="true" property="og:description" content="一、Git"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://jiaozitang.github.io/docs/收割机/offer收割机之前端工程化篇"><link data-react-helmet="true" rel="alternate" href="https://jiaozitang.github.io/docs/收割机/offer收割机之前端工程化篇" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jiaozitang.github.io/docs/收割机/offer收割机之前端工程化篇" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.1098517f.css">
<link rel="preload" href="/assets/js/runtime~main.55023f49.js" as="script">
<link rel="preload" href="/assets/js/main.2bcd511e.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">My Site</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/front-end/code">前端</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jiaozitang/blog" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">🌜</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">🌞</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_TwRn" href="/docs/front-end">front-end</a><button aria-label="Toggle the collapsible sidebar category &#x27;front-end&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_TwRn" href="/docs/收割机/前端面试准备">收割机</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/前端面试准备">前端面试准备</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/程序员面试软技能">程序员面试软技能</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之HTML篇">offer收割机之HTML篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之CSS篇">offer收割机之CSS篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之JavaScript篇">offer收割机之JavaScript篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之性能优化篇">offer收割机之性能优化篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/收割机/offer收割机之前端工程化篇">offer收割机之前端工程化篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之计算机网络篇">offer收割机之计算机网络篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之浏览器原理篇">offer收割机之浏览器原理篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之手写代码篇">offer收割机之手写代码篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/LeetCode面试常考题目">LeetCode面试常考题目</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之Vue篇">offer收割机之Vue篇</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>offer收割机之前端工程化篇</h1></header><h2 class="anchor anchorWithStickyNavbar_y2LR" id="一git">一、Git<a class="hash-link" href="#一git" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="1-git-和-svn-的区别">1. git 和 svn 的区别<a class="hash-link" href="#1-git-和-svn-的区别" title="Direct link to heading">​</a></h3><ul><li>git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器出现问题，就没有办法使用 svn 来提交代码。</li><li>svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。</li><li>svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。</li><li><strong>GIT 把内容按元数据方式存储，而 SVN 是按文件：</strong>因为 git 目录是处于个人机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。</li><li><strong>GIT 分支和 SVN 的分支不同：</strong>svn 会发生分支遗漏的情况，而 git 可以同一个工作目录下快速的在几个分支间切换，很容易发现未被合并的分支，简单而快捷的合并这些文件。</li><li><strong>GIT 没有一个全局的版本号，而 SVN 有</strong></li><li><strong>GIT 的内容完整性要优于 SVN：</strong>GIT 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="2-经常使用的-git-命令">2. 经常使用的 git 命令？<a class="hash-link" href="#2-经常使用的-git-命令" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">git init                     // 新建 git 代码库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git add                      // 添加指定文件到暂存区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git rm                       // 删除工作区文件，并且将这次删除放入暂存区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git commit -m [message]      // 提交暂存区到仓库区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git branch                   // 列出所有分支</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git checkout -b [branch]     // 新建一个分支，并切换到该分支</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git status                   // 显示有变更文件的状态</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="3-git-pull-和-git-fetch-的区别">3. git pull 和 git fetch 的区别<a class="hash-link" href="#3-git-pull-和-git-fetch-的区别" title="Direct link to heading">​</a></h3><ul><li>git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</li><li>git pull 会将远程仓库的变化下载下来，并和当前分支合并。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="4-git-rebase-和-git-merge-的区别">4. git rebase 和 git merge 的区别<a class="hash-link" href="#4-git-rebase-和-git-merge-的区别" title="Direct link to heading">​</a></h3><p>git merge 和 git rebase 都是用于分支合并，关键<strong>在</strong> <strong>commit 记录的处理上不同</strong>：</p><ul><li>git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。</li><li>git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="二webpack">二、Webpack<a class="hash-link" href="#二webpack" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="1-webpack与gruntgulp的不同">1. <strong>webpack</strong>与<strong>grunt</strong>、<strong>gulp</strong>的不同？<a class="hash-link" href="#1-webpack与gruntgulp的不同" title="Direct link to heading">​</a></h3><p><strong>Grunt<!-- -->*<!-- -->*</strong>、Gulp 是基于任务运⾏的⼯具<!-- -->*<!-- -->*<!-- -->： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插件，能⽅便的打造各种⼯作流。</p><p><strong>Webpack 是基于模块化打包的⼯具:</strong> ⾃动化处理模块，webpack 把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。</p><p>因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤ npm script 代替 Grunt、Gulp，npm script 同样可以打造任务流。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="2-webpackrollupparcel优劣">2. <strong>webpack</strong>、<strong>rollup</strong>、<strong>parcel</strong>优劣？<a class="hash-link" href="#2-webpackrollupparcel优劣" title="Direct link to heading">​</a></h3><ul><li>webpack 适⽤于⼤型复杂的前端站点构建: webpack 有强⼤的 loader 和插件⽣态,打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况更适合⽂件依赖复杂的应⽤开发。</li><li>rollup 适⽤于基础库的打包，如 vue、d3 等: Rollup 就是将各个模块打包进⼀个⽂件中，并且通过 Tree-shaking 来删除⽆⽤的代码,可以最⼤程度上降低代码体积,但是 rollup 没有 webpack 如此多的的如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适合库的开发。</li><li>parcel 适⽤于简单的实验性项⽬: 他可以满⾜低⻔槛的快速看到效果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项⽬或者实验项⽬不建议使⽤。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="3-有哪些常的loader">3. 有哪些常⻅的<strong>Loader</strong>？<a class="hash-link" href="#3-有哪些常的loader" title="Direct link to heading">​</a></h3><ul><li>file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件</li><li>url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去</li><li>source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试</li><li>image-loader：加载并且压缩图⽚⽂件</li><li>babel-loader：把 ES6 转换成 ES5</li><li>css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性</li><li>style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul><p><strong>注意：</strong>在 Webpack 中，loader 的执行顺序是<strong>从右向左</strong>执行的。因为 webpack 选择了<strong>compose 这样的函数式编程方式</strong>，这种方式的表达式执行是从右向左的。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="4-有哪些常的plugin">4. 有哪些常⻅的<strong>Plugin</strong>？<a class="hash-link" href="#4-有哪些常的plugin" title="Direct link to heading">​</a></h3><ul><li>define-plugin：定义环境变量</li><li>html-webpack-plugin：简化 html ⽂件创建</li><li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码</li><li>webpack-parallel-uglify-plugin: 多核压缩，提⾼压缩速度</li><li>webpack-bundle-analyzer: 可视化 webpack 输出⽂件的体积</li><li>mini-css-extract-plugin: CSS 提取到单独的⽂件中，⽀持按需加载</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="5-bundlechunkmodule是什么">5. <strong>bundle</strong>，<strong>chunk</strong>，<strong>module</strong>是什么？<a class="hash-link" href="#5-bundlechunkmodule是什么" title="Direct link to heading">​</a></h3><ul><li>bundle：是由 webpack 打包出来的⽂件；</li><li>chunk：代码块，⼀个 chunk 由多个模块组合⽽成，⽤于代码的合并和分割；</li><li>module：是开发中的单个模块，在 webpack 的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack 会从配置的 entry 中递归开始找出所有依赖的模块。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="6-loader和plugin的不同">6. <strong>Loader</strong>和<strong>Plugin</strong>的不同？<a class="hash-link" href="#6-loader和plugin的不同" title="Direct link to heading">​</a></h3><p>不同的作⽤:</p><ul><li><strong>Loader</strong>直译为&quot;加载器&quot;。Webpack 将⼀切⽂件视为模块，但是 webpack 原⽣是只能解析 js ⽂件，如果想将其他⽂件也打包的话，就会⽤到 loader 。 所以 Loader 的作⽤是让 webpack 拥有了加载和解析⾮ JavaScript ⽂件的能⼒。</li><li><strong>Plugin</strong>直译为&quot;插件&quot;。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><p><strong>不同的⽤法<!-- -->*<!-- -->*</strong>:<!-- -->*<!-- -->*</p><ul><li><strong>Loader</strong>在 module.rules 中配置，也就是说他作为模块的解析规则⽽存在。 类型为数组，每⼀项都是⼀个 Object ，⾥⾯描述了对于什么类型的⽂件（ test ），使⽤什么加载( loader )和使⽤的参数（ options ）</li><li><strong>Plugin</strong>在 plugins 中单独配置。 类型为数组，每⼀项是⼀个 plugin 的实例，参数都通过构造函数传⼊。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="7-webpack的构建流程">7. <strong>webpack</strong>的构建流程<strong>?</strong><a class="hash-link" href="#7-webpack的构建流程" title="Direct link to heading">​</a></h3><p>Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程：</p><ol><li>初始化参数：从配置⽂件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：⽤上⼀步得到的参数初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法开始执⾏编译；</li><li>确定⼊⼝：根据配置中的 entry 找出所有的⼊⼝⽂件；</li><li>编译模块：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理；</li><li>完成模块编译：在经过第 4 步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。</li></ol><p>在以上过程中，Webpack 会在特定的时间点⼴播出特定的事件，插件在监听到感兴趣的事件后会执⾏特定的逻辑，并且插件可以调⽤ Webpack 提供的 API 改变 Webpack 的运⾏结果。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="8-编写loader或plugin的思路">8. 编写<strong>loader</strong>或<strong>plugin</strong>的思路？<a class="hash-link" href="#8-编写loader或plugin的思路" title="Direct link to heading">​</a></h3><p>Loader 像⼀个&quot;翻译官&quot;把读到的源⽂件内容转义成新的⽂件内容，并且每个 Loader 通过链式操作，将源⽂件⼀步步翻译成想要的样⼦。</p><p>编写 Loader 时要遵循单⼀原则，每个 Loader 只做⼀种&quot;转义&quot;⼯作。 每个 Loader 的拿到的是源⽂件内容（source），可以通过返回值的⽅式将处理后的内容输出，也可以调⽤ this.callback() ⽅法，将内容返回给 webpack。 还可以通过 this.async() ⽣成⼀个 callback 函数，再⽤这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发 loader 的⼯具函数集——loader-utils 。</p><p>相对于 Loader ⽽⾔，Plugin 的编写就灵活了许多。 webpack 在运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="9-webpack的热更新是如何做到的说明其原理">9. <strong>webpack</strong>的热更新是如何做到的？说明其原理？<a class="hash-link" href="#9-webpack的热更新是如何做到的说明其原理" title="Direct link to heading">​</a></h3><p>webpack 的热更新⼜称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。</p><p>原理：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615910527011-339c57ce-22b2-4660-bcb5-93a7c6ec113b.png?x-oss-process=image%2Fresize%2Cw_1500" alt="image.png"></p><p>⾸先要知道 server 端和 client 端都做了处理⼯作：</p><ol><li>第⼀步，在 webpack 的 watch 模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack 监听到⽂件变化，根据配置⽂</li></ol><p>件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</p><ol><li>第⼆步是 webpack-dev-server 和 webpack 之间的接⼝交互，⽽在这⼀步，主要是 dev-server 的中间件 webpack- dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调⽤ webpack 暴露的 API 对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。</li><li>第三步是 webpack-dev-server 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进⾏ live reload。注意，这⼉是浏览器刷新，和 HMR 是两个概念。</li><li>第四步也是 webpack-dev-server 代码的⼯作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建⽴⼀个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态⽂件变化的信息。浏览器端根据这些 socket 消息进⾏不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后⾯的步骤根据这⼀ hash 值来进⾏模块热替换。</li><li>webpack-dev-server/client 端并不能够请求更新的代码，也不会执⾏热更模块操作，⽽把这些⼯作⼜交回给了 webpack，webpack/hot/dev-server 的⼯作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。</li><li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上⼀步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回⼀个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</li><li>⽽第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进⾏对⽐，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。</li><li>最后⼀步，当 HMR 失败后，回退到 live reload 操作，也就是进⾏浏览器刷新来获取最新打包代码。</li></ol><h3 class="anchor anchorWithStickyNavbar_y2LR" id="10-如何webpack来优化前端性能">10. 如何⽤<strong>webpack</strong>来优化前端性能？<a class="hash-link" href="#10-如何webpack来优化前端性能" title="Direct link to heading">​</a></h3><p>⽤ webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p><ul><li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤ webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS ⽂件， 利⽤ cssnano （css-loader?minimize）来压缩 css</li><li><strong>利⽤<!-- -->*<!-- -->*</strong>CDN<!-- -->*<strong>*<!-- -->加速</strong>: 在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径。可以利⽤ webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径</li><li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 webpack 时追加参数 --optimize-minimize 来实现</li><li><strong>Code Splitting:</strong> 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存</li><li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin 插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="11-如何提webpack的打包速度">11. 如何提⾼<strong>webpack</strong>的打包速度<strong>?</strong><a class="hash-link" href="#11-如何提webpack的打包速度" title="Direct link to heading">​</a></h3><ul><li>happypack: 利⽤进程并⾏编译 loader,利⽤缓存来使得 rebuild 更快,遗憾的是作者表示已经不会继续开发此项⽬,类似的替代者是 thread-loader</li><li>外部扩展(externals): 将不怎么需要更新的第三⽅库脱离 webpack 打包，不被打⼊ bundle 中，从⽽减少打包时间，⽐如 jQuery ⽤ script 标签引⼊</li><li>dll: 采⽤ webpack 的 DllPlugin 和 DllReferencePlugin 引⼊ dll，让⼀些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间</li><li>利⽤缓存: webpack.cache 、babel-loader.cacheDirectory、 HappyPack.cache 都可以利⽤缓存提⾼ rebuild 效率缩⼩⽂件搜索范围: ⽐如 babel-loader 插件,如果你的⽂件仅存在于 src 中,那么可以 include: path.resolve(<!-- -->_<!-- -->_<!-- -->dirname,&#x27;src&#x27;) ,当然绝⼤多数情况下这种操作的提升有限，除⾮不⼩⼼ build 了 node_modules ⽂件</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="12-如何提webpack的构建速度">12. 如何提⾼<strong>webpack</strong>的构建速度？<a class="hash-link" href="#12-如何提webpack的构建速度" title="Direct link to heading">​</a></h3><ol><li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码</li><li>通过 externals 配置来提取常⽤库</li><li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的 npm 包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li><li>使⽤ Happypack 实现多线程加速编译</li><li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度</li><li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码</li></ol><h3 class="anchor anchorWithStickyNavbar_y2LR" id="13-怎么配置单应怎么配置多应">13. 怎么配置单⻚应⽤？怎么配置多⻚应⽤？<a class="hash-link" href="#13-怎么配置单应怎么配置多应" title="Direct link to heading">​</a></h3><p>单⻚应⽤可以理解为 webpack 的标准模式，直接在 entry 中指定单⻚应⽤的⼊⼝即可，这⾥不再赘述多⻚应⽤的话，可以使⽤ webpack 的 AutoWebPlugin 来完成简单⾃动化的构建，但是前提是项⽬的⽬录结构必须遵守他预设的规范。 多⻚应⽤中要注意的是：</p><ul><li>每个⻚⾯都有公共的代码，可以将这些代码抽离出来，避免重复的加载。⽐如，每个⻚⾯都引⽤了同⼀套 css 样式表</li><li>随着业务的不断扩展，⻚⾯可能会不断的追加，所以⼀定要让⼊⼝的配置⾜够灵活，避免每次添加新⻚⾯还需要修改构建配置</li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="三其他">三、其他<a class="hash-link" href="#三其他" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="1-babel的原理是什么"><strong>1. Babel</strong>的原理是什么<strong>?</strong><a class="hash-link" href="#1-babel的原理是什么" title="Direct link to heading">​</a></h3><p>babel 的转译过程也分为三个阶段，这三步具体是：</p><ul><li><strong>解析 Parse</strong>: 将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程；</li><li><strong>转换 Transform</strong>: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作；</li><li><strong>⽣成 Generate</strong>: 将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615908675152-69682ae3-d0b3-4552-a32e-39c2022b1db0.png?x-oss-process=image%2Fresize%2Cw_1500" alt="image.png"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/收割机/7.offer收割机之前端工程化篇.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/收割机/offer收割机之性能优化篇"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">offer收割机之性能优化篇</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/收割机/offer收割机之计算机网络篇"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">offer收割机之计算机网络篇</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#一git" class="table-of-contents__link toc-highlight">一、Git</a><ul><li><a href="#1-git-和-svn-的区别" class="table-of-contents__link toc-highlight">1. git 和 svn 的区别</a></li><li><a href="#2-经常使用的-git-命令" class="table-of-contents__link toc-highlight">2. 经常使用的 git 命令？</a></li><li><a href="#3-git-pull-和-git-fetch-的区别" class="table-of-contents__link toc-highlight">3. git pull 和 git fetch 的区别</a></li><li><a href="#4-git-rebase-和-git-merge-的区别" class="table-of-contents__link toc-highlight">4. git rebase 和 git merge 的区别</a></li></ul></li><li><a href="#二webpack" class="table-of-contents__link toc-highlight">二、Webpack</a><ul><li><a href="#1-webpack与gruntgulp的不同" class="table-of-contents__link toc-highlight">1. <strong>webpack</strong>与<strong>grunt</strong>、<strong>gulp</strong>的不同？</a></li><li><a href="#2-webpackrollupparcel优劣" class="table-of-contents__link toc-highlight">2. <strong>webpack</strong>、<strong>rollup</strong>、<strong>parcel</strong>优劣？</a></li><li><a href="#3-有哪些常的loader" class="table-of-contents__link toc-highlight">3. 有哪些常⻅的<strong>Loader</strong>？</a></li><li><a href="#4-有哪些常的plugin" class="table-of-contents__link toc-highlight">4. 有哪些常⻅的<strong>Plugin</strong>？</a></li><li><a href="#5-bundlechunkmodule是什么" class="table-of-contents__link toc-highlight">5. <strong>bundle</strong>，<strong>chunk</strong>，<strong>module</strong>是什么？</a></li><li><a href="#6-loader和plugin的不同" class="table-of-contents__link toc-highlight">6. <strong>Loader</strong>和<strong>Plugin</strong>的不同？</a></li><li><a href="#7-webpack的构建流程" class="table-of-contents__link toc-highlight">7. <strong>webpack</strong>的构建流程<strong>?</strong></a></li><li><a href="#8-编写loader或plugin的思路" class="table-of-contents__link toc-highlight">8. 编写<strong>loader</strong>或<strong>plugin</strong>的思路？</a></li><li><a href="#9-webpack的热更新是如何做到的说明其原理" class="table-of-contents__link toc-highlight">9. <strong>webpack</strong>的热更新是如何做到的？说明其原理？</a></li><li><a href="#10-如何webpack来优化前端性能" class="table-of-contents__link toc-highlight">10. 如何⽤<strong>webpack</strong>来优化前端性能？</a></li><li><a href="#11-如何提webpack的打包速度" class="table-of-contents__link toc-highlight">11. 如何提⾼<strong>webpack</strong>的打包速度<strong>?</strong></a></li><li><a href="#12-如何提webpack的构建速度" class="table-of-contents__link toc-highlight">12. 如何提⾼<strong>webpack</strong>的构建速度？</a></li><li><a href="#13-怎么配置单应怎么配置多应" class="table-of-contents__link toc-highlight">13. 怎么配置单⻚应⽤？怎么配置多⻚应⽤？</a></li></ul></li><li><a href="#三其他" class="table-of-contents__link toc-highlight">三、其他</a><ul><li><a href="#1-babel的原理是什么" class="table-of-contents__link toc-highlight"><strong>1. Babel</strong>的原理是什么<strong>?</strong></a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.55023f49.js"></script>
<script src="/assets/js/main.2bcd511e.js"></script>
</body>
</html>
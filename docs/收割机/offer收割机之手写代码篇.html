<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><title data-react-helmet="true">offer收割机之手写代码篇 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jiaozitang.github.io/docs/收割机/offer收割机之手写代码篇"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="offer收割机之手写代码篇 | My Site"><meta data-react-helmet="true" name="description" content="手写代码面试题.png"><meta data-react-helmet="true" property="og:description" content="手写代码面试题.png"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://jiaozitang.github.io/docs/收割机/offer收割机之手写代码篇"><link data-react-helmet="true" rel="alternate" href="https://jiaozitang.github.io/docs/收割机/offer收割机之手写代码篇" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jiaozitang.github.io/docs/收割机/offer收割机之手写代码篇" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.1098517f.css">
<link rel="preload" href="/assets/js/runtime~main.8b388713.js" as="script">
<link rel="preload" href="/assets/js/main.c7c69549.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">My Site</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/front-end/code">前端</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jiaozitang/blog" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">🌜</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">🌞</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_TwRn" href="/docs/front-end">front-end</a><button aria-label="Toggle the collapsible sidebar category &#x27;front-end&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_TwRn" href="/docs/收割机/前端面试准备">收割机</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/前端面试准备">前端面试准备</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/程序员面试软技能">程序员面试软技能</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之HTML篇">offer收割机之HTML篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之CSS篇">offer收割机之CSS篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之JavaScript篇">offer收割机之JavaScript篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之性能优化篇">offer收割机之性能优化篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之前端工程化篇">offer收割机之前端工程化篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之计算机网络篇">offer收割机之计算机网络篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之浏览器原理篇">offer收割机之浏览器原理篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/收割机/offer收割机之手写代码篇">offer收割机之手写代码篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/LeetCode面试常考题目">LeetCode面试常考题目</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/收割机/offer收割机之Vue篇">offer收割机之Vue篇</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>offer收割机之手写代码篇</h1></header><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1621676946378-71d6b405-ef4e-42e4-9e42-f9c9aafcefb6.png?x-oss-process=image%2Fresize%2Cw_1038" alt="手写代码面试题.png"></p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="一javascript-基础">一、JavaScript 基础<a class="hash-link" href="#一javascript-基础" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="1-手写-objectcreate">1. 手写 Object.create<a class="hash-link" href="#1-手写-objectcreate" title="Direct link to heading">​</a></h3><p>思路：将传入的对象作为原型</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function create(obj) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  function F() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  F.prototype = obj</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new F()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="2-手写-instanceof-方法">2. 手写 instanceof 方法<a class="hash-link" href="#2-手写-instanceof-方法" title="Direct link to heading">​</a></h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><p>实现步骤：</p><ol><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ol><p>具体实现：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function myInstanceof(left, right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let proto = Object.getPrototypeOf(left), // 获取对象的原型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      prototype = right.prototype; // 获取构造函数的 prototype 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断构造函数的 prototype 对象是否在对象的原型链上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!proto) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (proto === prototype) return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proto = Object.getPrototypeOf(proto);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="3-手写-new-操作符">3. 手写 new 操作符<a class="hash-link" href="#3-手写-new-操作符" title="Direct link to heading">​</a></h3><p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function objectFactory() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let newObject = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let constructor = Array.prototype.shift.call(arguments);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let result = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断参数是否是一个函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof constructor !== &quot;function&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.error(&quot;type error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  newObject = Object.create(constructor.prototype);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 将 this 指向新建对象，并执行函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  result = constructor.apply(newObject, arguments);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断返回对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断返回结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return flag ? result : newObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">objectFactory(构造函数, 初始化参数);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="4-手写-promise">4. 手写 Promise<a class="hash-link" href="#4-手写-promise" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const PENDING = &quot;pending&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const RESOLVED = &quot;resolved&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const REJECTED = &quot;rejected&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function MyPromise(fn) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 保存初始化状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var self = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 初始化状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  this.state = PENDING;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 用于保存 resolve 或者 rejected 传入的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  this.value = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 用于保存 resolve 的回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  this.resolvedCallbacks = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 用于保存 reject 的回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  this.rejectedCallbacks = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 状态转变为 resolved 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  function resolve(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value instanceof MyPromise) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return value.then(resolve, reject);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 只有状态为 pending 时才能转变，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (self.state === PENDING) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 修改状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.state = RESOLVED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置传入的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.resolvedCallbacks.forEach(callback =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          callback(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 状态转变为 rejected 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  function reject(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 只有状态为 pending 时才能转变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (self.state === PENDING) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 修改状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.state = REJECTED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置传入的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.rejectedCallbacks.forEach(callback =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          callback(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 将两个方法传入函数执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn(resolve, reject);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } catch (e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遇到错误时，捕获错误，执行 reject 函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reject(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MyPromise.prototype.then = function(onResolved, onRejected) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  onResolved =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    typeof onResolved === &quot;function&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ? onResolved</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      : function(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  onRejected =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    typeof onRejected === &quot;function&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ? onRejected</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      : function(error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          throw error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 如果是等待状态，则将函数加入对应列表中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (this.state === PENDING) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.resolvedCallbacks.push(onResolved);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.rejectedCallbacks.push(onRejected);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 如果状态已经凝固，则直接执行对应状态的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (this.state === RESOLVED) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onResolved(this.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (this.state === REJECTED) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onRejected(this.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="5-手写-promisethen">5. 手写 Promise.then<a class="hash-link" href="#5-手写-promisethen" title="Direct link to heading">​</a></h3><p><code>then</code> 方法返回一个新的 <code>promise</code> 实例，为了在 <code>promise</code> 状态发生变化时（<code>resolve</code> / <code>reject</code> 被调用时）再执行 <code>then</code> 里的函数，我们使用一个 <code>callbacks</code> 数组先把传给 then 的函数暂存起来，等状态改变时再调用。</p><p><strong>那么，怎么保证后一个</strong> <code>**then**</code> <strong>里的方法在前一个</strong> <code>**then**</code><strong>（可能是异步）结束之后再执行呢？</strong></p><p>我们可以将传给 <code>then</code> 的函数和新 <code>promise</code> 的 <code>resolve</code> 一起 <code>push</code> 到前一个 <code>promise</code> 的 <code>callbacks</code> 数组中，达到承前启后的效果：</p><ul><li>承前：当前一个 <code>promise</code> 完成后，调用其 <code>resolve</code> 变更状态，在这个 <code>resolve</code> 里会依次调用 <code>callbacks</code> 里的回调，这样就执行了 <code>then</code> 里的方法了</li><li>启后：上一步中，当 <code>then</code> 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 <code>promise</code> 的 <code>resolve</code>，让其状态变更，这又会依次调用新 <code>promise</code> 的 <code>callbacks</code> 数组里的方法，循环往复。。如果返回的结果是个 <code>promise</code>，则需要等它完成之后再触发新 <code>promise</code> 的 <code>resolve</code>，所以可以在其结果的 <code>then</code> 里调用新 <code>promise</code> 的 <code>resolve</code></li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">then(onFulfilled, onReject){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 保存前一个promise的this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const self = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new MyPromise((resolve, reject) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 封装前一个promise成功时执行的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      let fulfilled = () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          const result = onFulfilled(self.value); // 承前</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return result instanceof MyPromise? result.then(resolve, reject) : resolve(result); //启后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }catch(err){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          reject(err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 封装前一个promise失败时执行的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      let rejected = () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          const result = onReject(self.reason);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return result instanceof MyPromise? result.then(resolve, reject) : reject(result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }catch(err){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          reject(err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      switch(self.status){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case PENDING:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          self.onFulfilledCallbacks.push(fulfilled);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          self.onRejectedCallbacks.push(rejected);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case FULFILLED:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          fulfilled();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case REJECT:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          rejected();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>注意：</strong></p><ul><li>连续多个 <code>then</code> 里的回调方法是同步注册的，但注册到了不同的 <code>callbacks</code> 数组中，因为每次 <code>then</code> 都返回新的 <code>promise</code> 实例（参考上面的例子和图）</li><li>注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 <code>callbacks</code> 数组中提前注册的回调</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="6-手写-promiseall">6. 手写 Promise.all<a class="hash-link" href="#6-手写-promiseall" title="Direct link to heading">​</a></h3><p><strong>1) 核心思路</strong></p><ol><li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数</li><li>这个方法返回一个新的 promise 对象，</li><li>遍历传入的参数，用 Promise.resolve()将参数&quot;包一层&quot;，使其变成一个 promise 对象</li><li>参数所有回调成功才是成功，返回值数组与参数顺序一致</li><li>参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。</li></ol><p><strong>2）实现代码</strong></p><p>一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function promiseAll(promises) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new Promise(function(resolve, reject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(!Array.isArray(promises)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new TypeError(`argument must be a array`)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var resolvedCounter = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var promiseNum = promises.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var resolvedResult = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 0; i &lt; promiseNum; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Promise.resolve(promises[i]).then(value=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resolvedCounter++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resolvedResult[i] = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (resolvedCounter == promiseNum) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return resolve(resolvedResult)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      },error=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return reject(error)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let p1 = new Promise(function (resolve, reject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(function () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resolve(1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, 1000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let p2 = new Promise(function (resolve, reject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(function () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resolve(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, 2000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let p3 = new Promise(function (resolve, reject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(function () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resolve(3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, 3000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">promiseAll([p3, p1, p2]).then(res =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(res) // [3, 1, 2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="7-手写-promiserace">7. 手写 Promise.race<a class="hash-link" href="#7-手写-promiserace" title="Direct link to heading">​</a></h3><p>该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态<strong>只能改变一次</strong>, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Promise.race = function (args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new Promise((resolve, reject) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 0, len = args.length; i &lt; len; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      args[i].then(resolve, reject)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="8-手写防抖函数">8. 手写防抖函数<a class="hash-link" href="#8-手写防抖函数" title="Direct link to heading">​</a></h3><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 函数防抖的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function debounce(fn, wait) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let timer = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let context = this,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        args = arguments;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (timer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      clearTimeout(timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      timer = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 设置定时器，使事件间隔指定事件后执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    timer = setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      fn.apply(context, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="9-手写节流函数">9. 手写节流函数<a class="hash-link" href="#9-手写节流函数" title="Direct link to heading">​</a></h3><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 函数节流的实现;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function throttle(fn, delay) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let curTime = Date.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let context = this,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        args = arguments,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nowTime = Date.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果两次时间间隔超过了指定时间，则执行函数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (nowTime - curTime &gt;= delay) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      curTime = Date.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return fn.apply(context, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="10-手写类型判断函数">10. 手写类型判断函数<a class="hash-link" href="#10-手写类型判断函数" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function getType(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断数据是 null 的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (value === null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return value + &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断数据是引用类型的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof value === &quot;object&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let valueClass = Object.prototype.toString.call(value),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      type = valueClass.split(&quot; &quot;)[1].split(&quot;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return type.join(&quot;&quot;).toLowerCase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 判断数据是基本数据类型的情况和函数的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return typeof value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="11-手写-call-函数">11. 手写 call 函数<a class="hash-link" href="#11-手写-call-函数" title="Direct link to heading">​</a></h3><p>call 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ol><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// call函数实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Function.prototype.myCall = function(context) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断调用对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof this !== &quot;function&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.error(&quot;type error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 获取参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let args = [...arguments].slice(1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      result = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断 context 是否传入，如果未传入则设置为 window</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  context = context || window;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 将调用函数设为对象的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  context.fn = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 调用函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  result = context.fn(...args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 将属性删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  delete context.fn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="12-手写-apply-函数">12. 手写 apply 函数<a class="hash-link" href="#12-手写-apply-函数" title="Direct link to heading">​</a></h3><p>apply 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ol><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// apply 函数实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Function.prototype.myApply = function(context) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断调用对象是否为函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof this !== &quot;function&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw new TypeError(&quot;Error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let result = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断 context 是否存在，如果未传入则为 window</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  context = context || window;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 将函数设为对象的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  context.fn = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 调用方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (arguments[1]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = context.fn(...arguments[1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = context.fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 将属性删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  delete context.fn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="13-手写-bind-函数">13. 手写 bind 函数<a class="hash-link" href="#13-手写-bind-函数" title="Direct link to heading">​</a></h3><p>bind 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ol><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// bind 函数实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Function.prototype.myBind = function(context) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 判断调用对象是否为函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof this !== &quot;function&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw new TypeError(&quot;Error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 获取参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var args = [...arguments].slice(1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      fn = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return function Fn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据调用方式，传入不同绑定值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return fn.apply(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this instanceof Fn ? this : context,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      args.concat(...arguments)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="14-函数柯里化的实现">14. 函数柯里化的实现<a class="hash-link" href="#14-函数柯里化的实现" title="Direct link to heading">​</a></h3><p>函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function curry(fn, args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 获取函数需要的参数长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let length = fn.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  args = args || [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let subArgs = args.slice(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 拼接得到现有的所有参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 0; i &lt; arguments.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      subArgs.push(arguments[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 判断参数的长度是否已经满足函数所需参数的长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (subArgs.length &gt;= length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 如果满足，执行函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return fn.apply(this, subArgs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 如果不满足，递归返回科里化的函数，等待参数的传入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return curry.call(this, fn, subArgs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// es6 实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function curry(fn, ...args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="15-实现-ajax-请求">15. 实现 AJAX 请求<a class="hash-link" href="#15-实现-ajax-请求" title="Direct link to heading">​</a></h3><p>AJAX 是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建 AJAX 请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发 onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const SERVER_URL = &quot;/server&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let xhr = new XMLHttpRequest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建 Http 请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xhr.open(&quot;GET&quot;, SERVER_URL, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 设置状态监听函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xhr.onreadystatechange = function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (this.readyState !== 4) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 当请求成功时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (this.status === 200) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    handle(this.response);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.error(this.statusText);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 设置请求失败时的监听函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xhr.onerror = function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(this.statusText);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 设置请求头信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xhr.responseType = &quot;json&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 发送 Http 请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xhr.send(null);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="16-使用-promise-封装-ajax-请求">16. 使用 Promise 封装 AJAX 请求<a class="hash-link" href="#16-使用-promise-封装-ajax-请求" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// promise 封装实现：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function getJSON(url) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 创建一个 promise 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let promise = new Promise(function(resolve, reject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let xhr = new XMLHttpRequest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 新建一个 http 请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    xhr.open(&quot;GET&quot;, url, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 设置状态的监听函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    xhr.onreadystatechange = function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (this.readyState !== 4) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 当请求成功或失败时，改变 promise 的状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (this.status === 200) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resolve(this.response);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reject(new Error(this.statusText));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 设置错误监听函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    xhr.onerror = function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      reject(new Error(this.statusText));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 设置响应的数据类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    xhr.responseType = &quot;json&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 设置请求头信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 发送 http 请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    xhr.send(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return promise;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="17-实现浅拷贝">17. 实现浅拷贝<a class="hash-link" href="#17-实现浅拷贝" title="Direct link to heading">​</a></h3><p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="1objectassign">（1）Object.assign()<a class="hash-link" href="#1objectassign" title="Direct link to heading">​</a></h4><p><code>Object.assign()</code>是 ES6 中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。</p><p><strong>注意：</strong></p><ul><li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li><li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li><li>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let target = {a: 1};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let object2 = {b: 2};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let object3 = {c: 3};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object.assign(target,object2,object3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(target);  // {a: 1, b: 2, c: 3}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="2扩展运算符">（2）扩展运算符<a class="hash-link" href="#2扩展运算符" title="Direct link to heading">​</a></h4><p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = { ...obj };</code></p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let obj1 = {a:1,b:{c:1}}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let obj2 = {...obj1};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">obj1.a = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(obj1); //{a:2,b:{c:1}}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(obj2); //{a:1,b:{c:1}}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">obj1.b.c = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(obj1); //{a:2,b:{c:2}}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(obj2); //{a:1,b:{c:2}}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="3数组方法实现数组浅拷贝">（3）数组方法实现数组浅拷贝<a class="hash-link" href="#3数组方法实现数组浅拷贝" title="Direct link to heading">​</a></h4><h6 class="anchor anchorWithStickyNavbar_y2LR" id="1arrayprototypeslice"><strong>1）Array.prototype.slice</strong><a class="hash-link" href="#1arrayprototypeslice" title="Direct link to heading">​</a></h6><ul><li><code>slice()</code>方法是 JavaScript 数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1,2,3,4];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(arr.slice()); // [1,2,3,4]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(arr.slice() === arr); //false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h6 class="anchor anchorWithStickyNavbar_y2LR" id="2arrayprototypeconcat"><strong>2）Array.prototype.concat</strong><a class="hash-link" href="#2arrayprototypeconcat" title="Direct link to heading">​</a></h6><ul><li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1,2,3,4];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(arr.concat()); // [1,2,3,4]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(arr.concat() === arr); //false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="4手写实现浅拷贝">（4）手写实现浅拷贝<a class="hash-link" href="#4手写实现浅拷贝" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 浅拷贝的实现;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function shallowCopy(object) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 只拷贝对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!object || typeof object !== &quot;object&quot;) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 根据 object 的类型判断是新建一个数组还是对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let newObject = Array.isArray(object) ? [] : {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 遍历 object，并且判断是 object 的属性才拷贝</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let key in object) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (object.hasOwnProperty(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      newObject[key] = object[key];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return newObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}// 浅拷贝的实现;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function shallowCopy(object) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 只拷贝对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!object || typeof object !== &quot;object&quot;) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 根据 object 的类型判断是新建一个数组还是对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let newObject = Array.isArray(object) ? [] : {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 遍历 object，并且判断是 object 的属性才拷贝</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let key in object) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (object.hasOwnProperty(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      newObject[key] = object[key];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return newObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}// 浅拷贝的实现;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function shallowCopy(object) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 只拷贝对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!object || typeof object !== &quot;object&quot;) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 根据 object 的类型判断是新建一个数组还是对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let newObject = Array.isArray(object) ? [] : {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 遍历 object，并且判断是 object 的属性才拷贝</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let key in object) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (object.hasOwnProperty(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      newObject[key] = object[key];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return newObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="18-实现深拷贝">18. 实现深拷贝<a class="hash-link" href="#18-实现深拷贝" title="Direct link to heading">​</a></h3><ul><li><strong>浅拷贝：</strong>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。</li><li><strong>深拷贝：</strong>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="1jsonstringify">（1）JSON.stringify()<a class="hash-link" href="#1jsonstringify" title="Direct link to heading">​</a></h4><ul><li><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON 字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</li><li>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let obj1 = {  a: 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              b: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 c: 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let obj2 = JSON.parse(JSON.stringify(obj1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">obj1.a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">obj1.b.c = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(obj1); // {a: 1, b: {c: 1}}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(obj2); // {a: 0, b: {c: 0}}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="2函数库-lodash-的_clonedeep-方法">（2）函数库 lodash 的<!-- -->_<!-- -->.cloneDeep 方法<a class="hash-link" href="#2函数库-lodash-的_clonedeep-方法" title="Direct link to heading">​</a></h4><p>该函数库也有提供<!-- -->_<!-- -->.cloneDeep 用来做 Deep Copy</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var _ = require(&#x27;lodash&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var obj1 = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b: { f: { g: 1 } },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c: [1, 2, 3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var obj2 = _.cloneDeep(obj1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(obj1.b.f === obj2.b.f);// false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="3手写实现深拷贝函数">（3）手写实现深拷贝函数<a class="hash-link" href="#3手写实现深拷贝函数" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 深拷贝的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function deepCopy(object) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!object || typeof object !== &quot;object&quot;) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let newObject = Array.isArray(object) ? [] : {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let key in object) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (object.hasOwnProperty(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      newObject[key] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        typeof object[key] === &quot;object&quot; ? deepCopy(object[key]) : object[key];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return newObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="二数据处理">二、数据处理<a class="hash-link" href="#二数据处理" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="1-实现日期格式化函数">1. 实现日期格式化函数<a class="hash-link" href="#1-实现日期格式化函数" title="Direct link to heading">​</a></h3><p>输入：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">dateFormat(new Date(&#x27;2020-12-01&#x27;), &#x27;yyyy/MM/dd&#x27;) // 2020/12/01</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dateFormat(new Date(&#x27;2020-04-01&#x27;), &#x27;yyyy/MM/dd&#x27;) // 2020/04/01</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dateFormat(new Date(&#x27;2020-04-01&#x27;), &#x27;yyyy年MM月dd日&#x27;) // 2020年04月01日</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const dateFormat = (dateInput, format)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var day = dateInput.getDate()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var month = dateInput.getMonth() + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var year = dateInput.getFullYear()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    format = format.replace(/yyyy/, year)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    format = format.replace(/MM/,month)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    format = format.replace(/dd/,day)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return format</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="2-交换-ab-的值不能用临时变量">2. 交换 a,b 的值，不能用临时变量<a class="hash-link" href="#2-交换-ab-的值不能用临时变量" title="Direct link to heading">​</a></h3><p>巧妙的利用两个数的和、差：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = a + b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b = a - b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a = a - b</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="3-实现数组的乱序输出">3. 实现数组的乱序输出<a class="hash-link" href="#3-实现数组的乱序输出" title="Direct link to heading">​</a></h3><p>主要的实现思路就是：</p><ul><li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li><li>第二次取出数据数组第二个元素，随机产生一个除了索引为 1 的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li><li>按照上面的规律执行，直到遍历完成</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var arr = [1,2,3,4,5,6,7,8,9,10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (var i = 0; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(arr)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>还有一方法就是倒序遍历：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var arr = [1,2,3,4,5,6,7,8,9,10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let length = arr.length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    randomIndex,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    randomIndex = Math.floor(Math.random() * length--);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    temp = arr[length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    arr[length] = arr[randomIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    arr[randomIndex] = temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(arr)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="4-实现数组元素求和">4. 实现数组元素求和<a class="hash-link" href="#4-实现数组元素求和" title="Direct link to heading">​</a></h3><ul><li>arr=<!-- -->[1,2,3,4,5,6,7,8,9,10]<!-- -->，求和</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr=[1,2,3,4,5,6,7,8,9,10]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let sum = arr.reduce( (total,i) =&gt; total += i,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(sum);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>arr=[1,2,3,[<!-- -->[4,5]<!-- -->,6],7,8,9]，求和</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var = arr=[1,2,3,[[4,5],6],7,8,9]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let arr= arr.toString().split(&#x27;,&#x27;).reduce( (total,i) =&gt; total += Number(i),0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(arr);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>递归实现：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1, 2, 3, 4, 5, 6]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function add(arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (arr.length == 1) return arr[0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr[0] + add(arr.slice(1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(add(arr)) // 21</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="5-实现数组的扁平化">5. 实现数组的扁平化<a class="hash-link" href="#5-实现数组的扁平化" title="Direct link to heading">​</a></h3><p><strong>（1）递归实现</strong></p><p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1, [2, [3, 4, 5]]];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function flatten(arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let result = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for(let i = 0; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(Array.isArray(arr[i])) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      result = result.concat(flatten(arr[i]));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      result.push(arr[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">flatten(arr);  //  [1, 2, 3, 4，5]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>（2）reduce 函数迭代</strong></p><p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用 reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1, [2, [3, 4]]];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function flatten(arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr.reduce(function(prev, next){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, [])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>（3）扩展运算符实现</strong></p><p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1, [2, [3, 4]]];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function flatten(arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (arr.some(item =&gt; Array.isArray(item))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr = [].concat(...arr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>（4）split 和 toString</strong></p><p>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1, [2, [3, 4]]];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function flatten(arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr.toString().split(&#x27;,&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。</p><p><strong>（5）<!-- -->*<!-- -->*</strong>ES6 中的 flat<!-- -->*<!-- -->*</p><p>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p><p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1, [2, [3, 4]]];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function flatten(arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return arr.flat(Infinity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。</p><p><strong>（6）正则和 JSON 方法</strong></p><p>在第 4 种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1, [2, [3, [4, 5]]], 6];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function flatten(arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let str = JSON.stringify(arr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  str = str.replace(/(\[|\])/g, &#x27;&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  str = &#x27;[&#x27; + str + &#x27;]&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return JSON.parse(str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="6-实现数组去重">6. 实现数组去重<a class="hash-link" href="#6-实现数组去重" title="Direct link to heading">​</a></h3><p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。</p><p>ES6 方法（使用数据结构集合）：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>ES5 方法：使用 map 存储不重复的数字</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uniqueArray(array); // [1, 2, 3, 5, 9, 8]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function uniqueArray(array) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let map = {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let res = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for(var i = 0; i &lt; array.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(!map.hasOwnProperty([array[i]])) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      map[array[i]] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      res.push(array[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="7-实现数组的-flat-方法">7. 实现数组的 flat 方法<a class="hash-link" href="#7-实现数组的-flat-方法" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function _flat(arr, depth) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if(!Array.isArray(arr) || depth &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return arr.reduce((prev, cur) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Array.isArray(cur)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return prev.concat(_flat(cur, depth - 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return prev.concat(cur);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }, []);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="8-实现数组的-push-方法">8. 实现数组的 push 方法<a class="hash-link" href="#8-实现数组的-push-方法" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Array.prototype.push = function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for( let i = 0 ; i &lt; arguments.length ; i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this[this.length] = arguments[i] ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="9-实现数组的-filter-方法">9. 实现数组的 filter 方法<a class="hash-link" href="#9-实现数组的-filter-方法" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Array.prototype._filter = function(fn) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (typeof fn !== &quot;function&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw Error(&#x27;参数必须是一个函数&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const res = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 0, len = this.length; i &lt; len; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn(this[i]) &amp;&amp; res.push(this[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="10-实现数组的-map-方法">10. 实现数组的 map 方法<a class="hash-link" href="#10-实现数组的-map-方法" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Array.prototype._map = function(fn) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (typeof fn !== &quot;function&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw Error(&#x27;参数必须是一个函数&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const res = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 0, len = this.length; i &lt; len; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res.push(fn(this[i]));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="11-实现字符串的-repeat-方法">11. 实现字符串的 repeat 方法<a class="hash-link" href="#11-实现字符串的-repeat-方法" title="Direct link to heading">​</a></h3><p>输入字符串 s，以及其重复的次数，输出重复的结果，例如输入 abc，2，输出 abcabc。</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function repeat(s, n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (new Array(n + 1)).join(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>递归：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function repeat(s, n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (n &gt; 0) ? s.concat(repeat(s, --n)) : &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="12-实现字符串翻转">12. 实现字符串翻转<a class="hash-link" href="#12-实现字符串翻转" title="Direct link to heading">​</a></h3><p>在字符串的原型链上添加一个方法，实现字符串翻转：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">String.prototype._reverse = function(a){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var obj = new String();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var res = obj._reverse (&#x27;hello&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(res);    // olleh</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="13-将数字每千分位用逗号隔开">13. 将数字每千分位用逗号隔开<a class="hash-link" href="#13-将数字每千分位用逗号隔开" title="Direct link to heading">​</a></h3><p><strong>数字有小数版本：</strong></p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let format = n =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let num = n.toString() // 转成字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let decimals = &#x27;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断是否有小数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    num.indexOf(&#x27;.&#x27;) &gt; -1 ? decimals = num.split(&#x27;.&#x27;)[1] : decimals</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let len = num.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (len &lt;= 3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return num</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let temp = &#x27;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let remainder = len % 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        decimals ? temp = &#x27;.&#x27; + decimals : temp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (remainder &gt; 0) { // 不是3的整数倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return num.slice(0, remainder) + &#x27;,&#x27; + num.slice(remainder, len).match(/\d{3}/g).join(&#x27;,&#x27;) + temp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else { // 是3的整数倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return num.slice(0, len).match(/\d{3}/g).join(&#x27;,&#x27;) + temp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">format(12323.33)  // &#x27;12,323.33&#x27;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>数字无小数版本：</strong></p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let format = n =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let num = n.toString()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let len = num.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (len &lt;= 3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return num</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let remainder = len % 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (remainder &gt; 0) { // 不是3的整数倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return num.slice(0, remainder) + &#x27;,&#x27; + num.slice(remainder, len).match(/\d{3}/g).join(&#x27;,&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else { // 是3的整数倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return num.slice(0, len).match(/\d{3}/g).join(&#x27;,&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">format(1232323)  // &#x27;1,232,323&#x27;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="14-实现非负大整数相加">14. 实现非负大整数相加<a class="hash-link" href="#14-实现非负大整数相加" title="Direct link to heading">​</a></h3><p>JavaScript 对数值有范围的限制，限制如下：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Number.MAX_VALUE // 1.7976931348623157e+308</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Number.MAX_SAFE_INTEGER // 9007199254740991</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Number.MIN_VALUE // 5e-324</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Number.MIN_SAFE_INTEGER // -9007199254740991</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>如果想要对一个超大的整数(<code>&gt; Number.MAX_SAFE_INTEGER</code>)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。</p><p>实现一个算法进行大数的相加：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function sumBigNumber(a, b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let res = &#x27;&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let temp = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  a = a.split(&#x27;&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  b = b.split(&#x27;&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (a.length || b.length || temp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    temp += ~~a.pop() + ~~b.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    res = (temp % 10) + res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    temp  = temp &gt; 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return res.replace(/^0+/, &#x27;&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>其主要的思路如下：</p><ul><li>首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化</li><li>初始化 res，temp 来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算</li><li>将两个数组的对应的位进行相加，两个数相加的结果可能大于 10，所以可能要仅为，对 10 进行取余操作，将结果保存在当前位</li><li>判断当前位是否大于 9，也就是是否会进位，若是则将 temp 赋值为 true，因为在加法运算中，true 会自动隐式转化为 1，以便于下一次相加</li><li>重复上述操作，直至计算结束</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="13-实现-add123">13. 实现 add(1)(2)(3)<a class="hash-link" href="#13-实现-add123" title="Direct link to heading">​</a></h3><p>函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p><p>1）粗暴版</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function add (a) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return function (b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return function (c) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return a + b + c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(add(1)(2)(3)); // 6</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>2）柯里化解决方案</p><ul><li>参数长度固定</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var add = function (m) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var temp = function (n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return add(m + n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  temp.toString = function () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(add(3)(4)(5)); // 12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(add(3)(6)(9)(25)); // 43</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>对于 add(3)(4)(5)，其执行过程如下：</p><ol><li>先执行 add(3)，此时 m=3，并且返回 temp 函数；</li><li>执行 temp(4)，这个函数内执行 add(m+n)，n 是此次传进来的数值 4，m 值还是上一步中的 3，所以 add(m+n)=add(3+4)=add(7)，此时 m=7，并且返回 temp 函数</li><li>执行 temp(5)，这个函数内执行 add(m+n)，n 是此次传进来的数值 5，m 值还是上一步中的 7，所以 add(m+n)=add(7+5)=add(12)，此时 m=12，并且返回 temp 函数</li><li>由于后面没有传入参数，等于返回的 temp 函数不被执行而是打印，了解 JS 的朋友都知道对象的 toString 是修改对象转换字符串的方法，因此代码中 temp 函数的 toString 函数 return m 值，而 m 值是最后一步执行函数时的值 m=12，所以返回值是 12。</li></ol><ul><li>参数长度不固定</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function add (...args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //求和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return args.reduce((a, b) =&gt; a + b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function currying (fn) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let args = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return function temp (...newArgs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (newArgs.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            args = [</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ...args,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ...newArgs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return temp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let val = fn.apply(this, args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            args = [] //保证再次调用时清空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return val</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let addCurry = currying(add)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(addCurry(1)(2)(3)(4, 5)())  //15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(addCurry(1)(2)(3, 4, 5)())  //15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(addCurry(1)(2, 3, 4, 5)())  //15</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="14-实现类数组转化为数组">14. 实现类数组转化为数组<a class="hash-link" href="#14-实现类数组转化为数组" title="Direct link to heading">​</a></h3><p>类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Array.prototype.slice.call(arrayLike);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Array.prototype.splice.call(arrayLike, 0);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Array.prototype.concat.apply([], arrayLike);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>通过 Array.from 方法来实现转换</li></ul><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Array.from(arrayLike);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="15-使用-reduce-求和">15. 使用 reduce 求和<a class="hash-link" href="#15-使用-reduce-求和" title="Direct link to heading">​</a></h3><p>arr = <!-- -->[1,2,3,4,5,6,7,8,9,10]<!-- -->，求和</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1,2,3,4,5,6,7,8,9,10]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr.reduce((prev, cur) =&gt; { return prev + cur }, 0)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>arr = [1,2,3,[<!-- -->[4,5]<!-- -->,6],7,8,9]，求和</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1,2,3,4,5,6,7,8,9,10]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr.flat(Infinity).reduce((prev, cur) =&gt; { return prev + cur }, 0)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>arr = <!-- -->[{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]<!-- -->，求和</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [{a:9, b:3, c:4}, {a:1, b:3}, {a:3}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr.reduce((prev, cur) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return prev + cur[&quot;a&quot;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}, 0)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="16-将-js-对象转化为树形结构">16. 将 js 对象转化为树形结构<a class="hash-link" href="#16-将-js-对象转化为树形结构" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 转换前：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">source = [{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            id: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pid: 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            name: &#x27;body&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            id: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pid: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            name: &#x27;title&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            id: 3,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pid: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            name: &#x27;div&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 转换为:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tree = [{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          id: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          pid: 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          name: &#x27;body&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          children: [{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            id: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pid: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            name: &#x27;title&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            children: [{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              id: 3,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              pid: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              name: &#x27;div&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>代码实现：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function jsonToTree(data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 初始化结果数组，并判断输入数据的格式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let result = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if(!Array.isArray(data)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 使用map，将当前对象的id与当前对象对应存储起来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let map = {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  data.forEach(item =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map[item.id] = item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  data.forEach(item =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let parent = map[item.pid];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(parent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (parent.children || (parent.children = [])).push(item);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      result.push(item);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="17-使用-es5-和-es6-求函数参数的和">17. 使用 ES5 和 ES6 求函数参数的和<a class="hash-link" href="#17-使用-es5-和-es6-求函数参数的和" title="Direct link to heading">​</a></h3><p>ES5：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function sum() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sum = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Array.prototype.forEach.call(arguments, function(item) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sum += item * 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return sum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>ES6：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function sum(...nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sum = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nums.forEach(function(item) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sum += item * 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return sum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="18-解析-url-params-为对象">18. 解析 URL Params 为对象<a class="hash-link" href="#18-解析-url-params-为对象" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let url = &#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">parseParam(url)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{ user: &#x27;anonymous&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  city: &#x27;北京&#x27;, // 中文需解码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  enabled: true, // 未指定值得 key 约定为 true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function parseParam(url) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const paramsArr = paramsStr.split(&#x27;&amp;&#x27;); // 将字符串以 &amp; 分割后存到数组中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let paramsObj = {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 将 params 存到对象中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  paramsArr.forEach(param =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (/=/.test(param)) { // 处理有 value 的参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      let [key, val] = param.split(&#x27;=&#x27;); // 分割 key 和 value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val = decodeURIComponent(val); // 解码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        paramsObj[key] = [].concat(paramsObj[key], val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else { // 如果对象没有这个 key，创建 key 并设置值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        paramsObj[key] = val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else { // 处理没有 value 的参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      paramsObj[param] = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return paramsObj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="三场景应用">三、场景应用<a class="hash-link" href="#三场景应用" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="1-循环打印红黄绿">1. 循环打印红黄绿<a class="hash-link" href="#1-循环打印红黄绿" title="Direct link to heading">​</a></h3><p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p><p>三个亮灯函数：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function red() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;red&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function green() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;green&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function yellow() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;yellow&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="1用-callback-实现">（1）用 callback 实现<a class="hash-link" href="#1用-callback-实现" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const task = (timer, light, callback) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (light === &#x27;red&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            red()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (light === &#x27;green&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            green()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (light === &#x27;yellow&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            yellow()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        callback()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, timer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task(3000, &#x27;red&#x27;, () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    task(2000, &#x27;green&#x27;, () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        task(1000, &#x27;yellow&#x27;, Function.prototype)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p><p>上面提到过递归，可以递归亮灯的一个周期：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const step = () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    task(3000, &#x27;red&#x27;, () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        task(2000, &#x27;green&#x27;, () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            task(1000, &#x27;yellow&#x27;, step)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">step()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="2用-promise-实现">（2）用 promise 实现<a class="hash-link" href="#2用-promise-实现" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const task = (timer, light) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new Promise((resolve, reject) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (light === &#x27;red&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                red()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (light === &#x27;green&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                green()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (light === &#x27;yellow&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                yellow()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            resolve()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, timer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const step = () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    task(3000, &#x27;red&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .then(() =&gt; task(2000, &#x27;green&#x27;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .then(() =&gt; task(2100, &#x27;yellow&#x27;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .then(step)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">step()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="3用-asyncawait-实现">（3）用 async/await 实现<a class="hash-link" href="#3用-asyncawait-实现" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const taskRunner =  async () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    await task(3000, &#x27;red&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    await task(2000, &#x27;green&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    await task(2100, &#x27;yellow&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    taskRunner()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">taskRunner()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="2-实现每隔一秒打印-1234">2. 实现每隔一秒打印 1,2,3,4<a class="hash-link" href="#2-实现每隔一秒打印-1234" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 使用闭包实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (var i = 0; i &lt; 5; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (function(i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      console.log(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, i * 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 let 块级作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (let i = 0; i &lt; 5; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  setTimeout(function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }, i * 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="3-小孩报数问题">3. 小孩报数问题<a class="hash-link" href="#3-小孩报数问题" title="Direct link to heading">​</a></h3><p>有 30 个小孩儿，编号从 1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function childNum(num, count){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let allplayer = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(let i = 0; i &lt; num; i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        allplayer[i] = i + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let exitCount = 0;    // 离开人数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let counter = 0;      // 记录报数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let curIndex = 0;     // 当前下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(exitCount &lt; num - 1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(allplayer[curIndex] !== 0) counter++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(counter == count){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            allplayer[curIndex] = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            counter = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            exitCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        curIndex++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(curIndex == num){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            curIndex = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(i = 0; i &lt; num; i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(allplayer[i] !== 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return allplayer[i]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">childNum(30, 3)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="4-用-promise-实现图片的异步加载">4. 用 Promise 实现图片的异步加载<a class="hash-link" href="#4-用-promise-实现图片的异步加载" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let imageAsync=(url)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new Promise((resolve,reject)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let img = new Image();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                img.src = url;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                img.οnlοad=()=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    console.log(`图片请求成功，此处进行通用操作`);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    resolve(image);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                img.οnerrοr=(err)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    console.log(`失败，此处进行失败的通用操作`);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    reject(err);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">imageAsync(&quot;url&quot;).then(()=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;加载成功&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}).catch((error)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;加载失败&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="5-实现发布-订阅模式">5. 实现发布-订阅模式<a class="hash-link" href="#5-实现发布-订阅模式" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class EventCenter{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 1. 定义事件容器，用来装事件数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let handlers = {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 2. 添加事件方法，参数：事件名 事件方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  addEventListener(type, handler) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建新数组容器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!this.handlers[type]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.handlers[type] = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 存入事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.handlers[type].push(handler)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 3. 触发事件，参数：事件名 事件参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dispatchEvent(type, params) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若没有注册该事件则抛出错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!this.handlers[type]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return new Error(&#x27;该事件未注册&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 触发事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.handlers[type].forEach(handler =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      handler(...params)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  removeEventListener(type, handler) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!this.handlers[type]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return new Error(&#x27;事件无效&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!handler) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 移除事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      delete this.handlers[type]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      const index = this.handlers[type].findIndex(el =&gt; el === handler)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (index === -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Error(&#x27;无该绑定事件&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 移除事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.handlers[type].splice(index, 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (this.handlers[type].length === 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        delete this.handlers[type]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="6-查找文章中出现频率最高的单词">6. 查找文章中出现频率最高的单词<a class="hash-link" href="#6-查找文章中出现频率最高的单词" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function findMostWord(article) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 合法性判断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!article) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 参数处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  article = article.trim().toLowerCase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let wordList = article.match(/[a-z]+/g),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    visited = [],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maxNum = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maxWord = &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  article = &quot; &quot; + wordList.join(&quot;  &quot;) + &quot; &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 遍历判断单词出现次数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  wordList.forEach(function(item) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (visited.indexOf(item) &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 加入 visited</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      visited.push(item);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      let word = new RegExp(&quot; &quot; + item + &quot; &quot;, &quot;g&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        num = article.match(word).length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (num &gt; maxNum) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        maxNum = num;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        maxWord = item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return maxWord + &quot;  &quot; + maxNum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="7-封装异步的-fetch使用-async-await-方式来使用">7. 封装异步的 fetch，使用 async await 方式来使用<a class="hash-link" href="#7-封装异步的-fetch使用-async-await-方式来使用" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">(async () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class HttpRequestUtil {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        async get(url) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const res = await fetch(url);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const data = await res.json();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        async post(url, data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const res = await fetch(url, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                method: &#x27;POST&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                headers: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                body: JSON.stringify(data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const result = await res.json();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        async put(url, data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const res = await fetch(url, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                method: &#x27;PUT&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                headers: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                data: JSON.stringify(data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const result = await res.json();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        async delete(url, data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const res = await fetch(url, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                method: &#x27;DELETE&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                headers: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                data: JSON.stringify(data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const result = await res.json();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const httpRequestUtil = new HttpRequestUtil();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const res = await httpRequestUtil.get(&#x27;http://golderbrother.cn/&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(res);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})();</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="8-实现-prototype-继承">8. 实现 prototype 继承<a class="hash-link" href="#8-实现-prototype-继承" title="Direct link to heading">​</a></h3><p>所谓的原型链继承就是让新实例的原型等于父类的实例：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">//父方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function SupperFunction(flag1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.flag1 = flag1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//子方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function SubFunction(flag2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.flag2 = flag2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//父实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var superInstance = new SupperFunction(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//子继承父</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SubFunction.prototype = superInstance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//子实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var subInstance = new SubFunction(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//子调用自己和父的属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">subInstance.flag1;   // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">subInstance.flag2;   // false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="9-实现双向数据绑定">9. 实现双向数据绑定<a class="hash-link" href="#9-实现双向数据绑定" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">let obj = {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let input = document.getElementById(&#x27;input&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let span = document.getElementById(&#x27;span&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 数据劫持</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object.defineProperty(obj, &#x27;text&#x27;, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  configurable: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  enumerable: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  get() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;获取数据了&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set(newVal) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;数据更新了&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input.value = newVal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    span.innerHTML = newVal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输入监听</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">input.addEventListener(&#x27;keyup&#x27;, function(e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  obj.text = e.target.value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="10-实现简单路由">10. 实现简单路由<a class="hash-link" href="#10-实现简单路由" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// hash路由</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Route{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  constructor(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 路由存储对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.routes = {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前hash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.currentHash = &#x27;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 绑定this，避免监听时this指向改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.freshRoute = this.freshRoute.bind(this)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 监听</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    window.addEventListener(&#x27;load&#x27;, this.freshRoute, false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    window.addEventListener(&#x27;hashchange&#x27;, this.freshRoute, false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 存储</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  storeRoute (path, cb) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.routes[path] = cb || function () {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  freshRoute () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.currentHash = location.hash.slice(1) || &#x27;/&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.routes[this.currentHash]()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="11-实现斐波那契数列">11. 实现斐波那契数列<a class="hash-link" href="#11-实现斐波那契数列" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 递归</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function fn (n){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(n==0) return 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(n==1) return 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return fn(n-2)+fn(n-1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 优化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function fibonacci2(n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const arr = [1, 1, 2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const arrLen = arr.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n &lt;= arrLen) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arr[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = arrLen; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr.push(arr[i - 1] + arr[ i - 2]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return arr[arr.length - 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 非递归</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function fn(n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pre1 = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pre2 = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let current = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n &lt;= 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return current;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 2; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pre1 = pre2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pre2 = current;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        current = pre1 + pre2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return current;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="12-字符串出现的不重复最长长度">12. 字符串出现的不重复最长长度<a class="hash-link" href="#12-字符串出现的不重复最长长度" title="Direct link to heading">​</a></h3><p>用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var lengthOfLongestSubstring = function (s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let map = new Map();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let i = -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let res = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let n = s.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let j = 0; j &lt; n; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (map.has(s[j])) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            i = Math.max(i, map.get(s[j]))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res = Math.max(res, j - i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.set(s[j], j)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="13-使用-settimeout-实现-setinterval">13. 使用 setTimeout 实现 setInterval<a class="hash-link" href="#13-使用-settimeout-实现-setinterval" title="Direct link to heading">​</a></h3><p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p><p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p><p>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function mySetInterval(fn, timeout) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 控制器，控制定时器是否继续执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var timer = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flag: true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 设置递归函数，模拟定时器执行。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  function interval() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (timer.flag) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      setTimeout(interval, timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 启动定时器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  setTimeout(interval, timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 返回控制器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return timer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="14-实现-jsonp">14. 实现 jsonp<a class="hash-link" href="#14-实现-jsonp" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 动态的加载js文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function addScript(src) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const script = document.createElement(&#x27;script&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  script.src = src;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  script.type = &quot;text/javascript&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  document.body.appendChild(script);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">addScript(&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 设置一个全局的callback函数来接收回调结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function handleRes(res) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(res);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 接口返回的数据格式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">handleRes({a: 1, b: 2});</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="15-判断对象是否存在循环引用">15. 判断对象是否存在循环引用<a class="hash-link" href="#15-判断对象是否存在循环引用" title="Direct link to heading">​</a></h3><p>循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用<code>JSON.stringify()</code>对该类对象进行序列化，就会报错: <code>Converting circular structure to JSON.</code></p><p>下面方法可以用来判断一个对象中是否已存在循环引用：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const isCycleObject = (obj,parent) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const parentArr = parent || [obj];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(let i in obj) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(typeof obj[i] === &#x27;object&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let flag = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parentArr.forEach((pObj) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(pObj === obj[i]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    flag = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(flag) return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(flag) return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const b = {a};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const c = {b};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const o = {d:{a:3},c}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">o.c.b.aa = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(isCycleObject(o)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>查找有序二维数组的目标值：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var findNumberIn2DArray = function(matrix, target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (matrix == null || matrix.length == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let row = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let column = matrix[0].length - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (row &lt; matrix.length &amp;&amp; column &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (matrix[row][column] == target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (matrix[row][column] &gt; target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            column--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            row++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>二维数组斜向打印：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function printMatrix(arr){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let m = arr.length, n = arr[0].length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let res = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 左上角，从0 到 n - 1 列进行打印</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let k = 0; k &lt; n; k++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 0, j = k; i &lt; m &amp;&amp; j &gt;= 0; i++, j--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      res.push(arr[i][j]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 右下角，从1 到 n - 1 行进行打印</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let k = 1; k &lt; m; k++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = k, j = n - 1; i &lt; m &amp;&amp; j &gt;= 0; i++, j--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      res.push(arr[i][j]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/收割机/10.offer收割机之手写代码篇.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/收割机/offer收割机之浏览器原理篇"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">offer收割机之浏览器原理篇</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/收割机/LeetCode面试常考题目"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">LeetCode面试常考题目</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#一javascript-基础" class="table-of-contents__link toc-highlight">一、JavaScript 基础</a><ul><li><a href="#1-手写-objectcreate" class="table-of-contents__link toc-highlight">1. 手写 Object.create</a></li><li><a href="#2-手写-instanceof-方法" class="table-of-contents__link toc-highlight">2. 手写 instanceof 方法</a></li><li><a href="#3-手写-new-操作符" class="table-of-contents__link toc-highlight">3. 手写 new 操作符</a></li><li><a href="#4-手写-promise" class="table-of-contents__link toc-highlight">4. 手写 Promise</a></li><li><a href="#5-手写-promisethen" class="table-of-contents__link toc-highlight">5. 手写 Promise.then</a></li><li><a href="#6-手写-promiseall" class="table-of-contents__link toc-highlight">6. 手写 Promise.all</a></li><li><a href="#7-手写-promiserace" class="table-of-contents__link toc-highlight">7. 手写 Promise.race</a></li><li><a href="#8-手写防抖函数" class="table-of-contents__link toc-highlight">8. 手写防抖函数</a></li><li><a href="#9-手写节流函数" class="table-of-contents__link toc-highlight">9. 手写节流函数</a></li><li><a href="#10-手写类型判断函数" class="table-of-contents__link toc-highlight">10. 手写类型判断函数</a></li><li><a href="#11-手写-call-函数" class="table-of-contents__link toc-highlight">11. 手写 call 函数</a></li><li><a href="#12-手写-apply-函数" class="table-of-contents__link toc-highlight">12. 手写 apply 函数</a></li><li><a href="#13-手写-bind-函数" class="table-of-contents__link toc-highlight">13. 手写 bind 函数</a></li><li><a href="#14-函数柯里化的实现" class="table-of-contents__link toc-highlight">14. 函数柯里化的实现</a></li><li><a href="#15-实现-ajax-请求" class="table-of-contents__link toc-highlight">15. 实现 AJAX 请求</a></li><li><a href="#16-使用-promise-封装-ajax-请求" class="table-of-contents__link toc-highlight">16. 使用 Promise 封装 AJAX 请求</a></li><li><a href="#17-实现浅拷贝" class="table-of-contents__link toc-highlight">17. 实现浅拷贝</a></li><li><a href="#18-实现深拷贝" class="table-of-contents__link toc-highlight">18. 实现深拷贝</a></li></ul></li><li><a href="#二数据处理" class="table-of-contents__link toc-highlight">二、数据处理</a><ul><li><a href="#1-实现日期格式化函数" class="table-of-contents__link toc-highlight">1. 实现日期格式化函数</a></li><li><a href="#2-交换-ab-的值不能用临时变量" class="table-of-contents__link toc-highlight">2. 交换 a,b 的值，不能用临时变量</a></li><li><a href="#3-实现数组的乱序输出" class="table-of-contents__link toc-highlight">3. 实现数组的乱序输出</a></li><li><a href="#4-实现数组元素求和" class="table-of-contents__link toc-highlight">4. 实现数组元素求和</a></li><li><a href="#5-实现数组的扁平化" class="table-of-contents__link toc-highlight">5. 实现数组的扁平化</a></li><li><a href="#6-实现数组去重" class="table-of-contents__link toc-highlight">6. 实现数组去重</a></li><li><a href="#7-实现数组的-flat-方法" class="table-of-contents__link toc-highlight">7. 实现数组的 flat 方法</a></li><li><a href="#8-实现数组的-push-方法" class="table-of-contents__link toc-highlight">8. 实现数组的 push 方法</a></li><li><a href="#9-实现数组的-filter-方法" class="table-of-contents__link toc-highlight">9. 实现数组的 filter 方法</a></li><li><a href="#10-实现数组的-map-方法" class="table-of-contents__link toc-highlight">10. 实现数组的 map 方法</a></li><li><a href="#11-实现字符串的-repeat-方法" class="table-of-contents__link toc-highlight">11. 实现字符串的 repeat 方法</a></li><li><a href="#12-实现字符串翻转" class="table-of-contents__link toc-highlight">12. 实现字符串翻转</a></li><li><a href="#13-将数字每千分位用逗号隔开" class="table-of-contents__link toc-highlight">13. 将数字每千分位用逗号隔开</a></li><li><a href="#14-实现非负大整数相加" class="table-of-contents__link toc-highlight">14. 实现非负大整数相加</a></li><li><a href="#13-实现-add123" class="table-of-contents__link toc-highlight">13. 实现 add(1)(2)(3)</a></li><li><a href="#14-实现类数组转化为数组" class="table-of-contents__link toc-highlight">14. 实现类数组转化为数组</a></li><li><a href="#15-使用-reduce-求和" class="table-of-contents__link toc-highlight">15. 使用 reduce 求和</a></li><li><a href="#16-将-js-对象转化为树形结构" class="table-of-contents__link toc-highlight">16. 将 js 对象转化为树形结构</a></li><li><a href="#17-使用-es5-和-es6-求函数参数的和" class="table-of-contents__link toc-highlight">17. 使用 ES5 和 ES6 求函数参数的和</a></li><li><a href="#18-解析-url-params-为对象" class="table-of-contents__link toc-highlight">18. 解析 URL Params 为对象</a></li></ul></li><li><a href="#三场景应用" class="table-of-contents__link toc-highlight">三、场景应用</a><ul><li><a href="#1-循环打印红黄绿" class="table-of-contents__link toc-highlight">1. 循环打印红黄绿</a></li><li><a href="#2-实现每隔一秒打印-1234" class="table-of-contents__link toc-highlight">2. 实现每隔一秒打印 1,2,3,4</a></li><li><a href="#3-小孩报数问题" class="table-of-contents__link toc-highlight">3. 小孩报数问题</a></li><li><a href="#4-用-promise-实现图片的异步加载" class="table-of-contents__link toc-highlight">4. 用 Promise 实现图片的异步加载</a></li><li><a href="#5-实现发布-订阅模式" class="table-of-contents__link toc-highlight">5. 实现发布-订阅模式</a></li><li><a href="#6-查找文章中出现频率最高的单词" class="table-of-contents__link toc-highlight">6. 查找文章中出现频率最高的单词</a></li><li><a href="#7-封装异步的-fetch使用-async-await-方式来使用" class="table-of-contents__link toc-highlight">7. 封装异步的 fetch，使用 async await 方式来使用</a></li><li><a href="#8-实现-prototype-继承" class="table-of-contents__link toc-highlight">8. 实现 prototype 继承</a></li><li><a href="#9-实现双向数据绑定" class="table-of-contents__link toc-highlight">9. 实现双向数据绑定</a></li><li><a href="#10-实现简单路由" class="table-of-contents__link toc-highlight">10. 实现简单路由</a></li><li><a href="#11-实现斐波那契数列" class="table-of-contents__link toc-highlight">11. 实现斐波那契数列</a></li><li><a href="#12-字符串出现的不重复最长长度" class="table-of-contents__link toc-highlight">12. 字符串出现的不重复最长长度</a></li><li><a href="#13-使用-settimeout-实现-setinterval" class="table-of-contents__link toc-highlight">13. 使用 setTimeout 实现 setInterval</a></li><li><a href="#14-实现-jsonp" class="table-of-contents__link toc-highlight">14. 实现 jsonp</a></li><li><a href="#15-判断对象是否存在循环引用" class="table-of-contents__link toc-highlight">15. 判断对象是否存在循环引用</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8b388713.js"></script>
<script src="/assets/js/main.c7c69549.js"></script>
</body>
</html>